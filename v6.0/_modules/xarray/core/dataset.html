
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>xarray.core.dataset &#8212; v6.0.26</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css?v=9d77a3fd" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../../_static/documentation_options.js?v=c73c0f3e"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/xarray/core/dataset';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.15.4';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://raw.githubusercontent.com/driftlesslabs/larch/docs/docs/switcher.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '6.0';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = false;
        </script>
    <link rel="icon" href="../../../_static/larch_favicon.png"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search these docs..."
         aria-label="Search these docs..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/larch-logo.png" class="logo__image only-light" alt="v6.0.26 - Home"/>
    <script>document.write(`<img src="../../../_static/larch-logo.png" class="logo__image only-dark" alt="v6.0.26 - Home"/>`);</script>
  
  
</a></div>
    
      <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-2"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-2"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-2"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-2">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../user-guide/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api/index.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../examples/index.html">
    Examples
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../user-guide/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api/index.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../examples/index.html">
    Examples
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">xarray.core.dataset</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for xarray.core.dataset</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Collection</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">MutableMapping</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">html</span> <span class="kn">import</span> <span class="n">escape</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">methodcaller</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">PathLike</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">EllipsisType</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">IO</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">overload</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="n">is_extension_array_dtype</span>

<span class="c1"># remove once numpy 2.0 is the oldest supported version</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">numpy.exceptions</span> <span class="kn">import</span> <span class="n">RankWarning</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">RankWarning</span>  <span class="c1"># type: ignore[no-redef,attr-defined,unused-ignore]</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">xarray.coding.calendar_ops</span> <span class="kn">import</span> <span class="n">convert_calendar</span><span class="p">,</span> <span class="n">interp_calendar</span>
<span class="kn">from</span> <span class="nn">xarray.coding.cftimeindex</span> <span class="kn">import</span> <span class="n">CFTimeIndex</span><span class="p">,</span> <span class="n">_parse_array_of_cftime_strings</span>
<span class="kn">from</span> <span class="nn">xarray.core</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">alignment</span><span class="p">,</span>
    <span class="n">duck_array_ops</span><span class="p">,</span>
    <span class="n">formatting</span><span class="p">,</span>
    <span class="n">formatting_html</span><span class="p">,</span>
    <span class="n">ops</span><span class="p">,</span>
    <span class="n">utils</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">xarray.core</span> <span class="kn">import</span> <span class="n">dtypes</span> <span class="k">as</span> <span class="n">xrdtypes</span>
<span class="kn">from</span> <span class="nn">xarray.core._aggregations</span> <span class="kn">import</span> <span class="n">DatasetAggregations</span>
<span class="kn">from</span> <span class="nn">xarray.core.alignment</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_broadcast_helper</span><span class="p">,</span>
    <span class="n">_get_broadcast_dims_map_common_coords</span><span class="p">,</span>
    <span class="n">align</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">xarray.core.arithmetic</span> <span class="kn">import</span> <span class="n">DatasetArithmetic</span>
<span class="kn">from</span> <span class="nn">xarray.core.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DataWithCoords</span><span class="p">,</span>
    <span class="n">_contains_datetime_like_objects</span><span class="p">,</span>
    <span class="n">get_chunksizes</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">xarray.core.computation</span> <span class="kn">import</span> <span class="n">unify_chunks</span>
<span class="kn">from</span> <span class="nn">xarray.core.coordinates</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Coordinates</span><span class="p">,</span>
    <span class="n">DatasetCoordinates</span><span class="p">,</span>
    <span class="n">assert_coordinate_consistent</span><span class="p">,</span>
    <span class="n">create_coords_with_default_indexes</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">xarray.core.duck_array_ops</span> <span class="kn">import</span> <span class="n">datetime_to_numeric</span>
<span class="kn">from</span> <span class="nn">xarray.core.indexes</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Index</span><span class="p">,</span>
    <span class="n">Indexes</span><span class="p">,</span>
    <span class="n">PandasIndex</span><span class="p">,</span>
    <span class="n">PandasMultiIndex</span><span class="p">,</span>
    <span class="n">assert_no_index_corrupted</span><span class="p">,</span>
    <span class="n">create_default_index_implicit</span><span class="p">,</span>
    <span class="n">filter_indexes_from_coords</span><span class="p">,</span>
    <span class="n">isel_indexes</span><span class="p">,</span>
    <span class="n">remove_unused_levels_categories</span><span class="p">,</span>
    <span class="n">roll_indexes</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">xarray.core.indexing</span> <span class="kn">import</span> <span class="n">is_fancy_indexer</span><span class="p">,</span> <span class="n">map_index_queries</span>
<span class="kn">from</span> <span class="nn">xarray.core.merge</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">dataset_merge_method</span><span class="p">,</span>
    <span class="n">dataset_update_method</span><span class="p">,</span>
    <span class="n">merge_coordinates_without_align</span><span class="p">,</span>
    <span class="n">merge_core</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">xarray.core.missing</span> <span class="kn">import</span> <span class="n">get_clean_interp_index</span>
<span class="kn">from</span> <span class="nn">xarray.core.options</span> <span class="kn">import</span> <span class="n">OPTIONS</span><span class="p">,</span> <span class="n">_get_keep_attrs</span>
<span class="kn">from</span> <span class="nn">xarray.core.types</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Bins</span><span class="p">,</span>
    <span class="n">NetcdfWriteModes</span><span class="p">,</span>
    <span class="n">QuantileMethods</span><span class="p">,</span>
    <span class="n">Self</span><span class="p">,</span>
    <span class="n">T_ChunkDim</span><span class="p">,</span>
    <span class="n">T_ChunksFreq</span><span class="p">,</span>
    <span class="n">T_DataArray</span><span class="p">,</span>
    <span class="n">T_DataArrayOrSet</span><span class="p">,</span>
    <span class="n">T_Dataset</span><span class="p">,</span>
    <span class="n">ZarrWriteModes</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">xarray.core.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Default</span><span class="p">,</span>
    <span class="n">Frozen</span><span class="p">,</span>
    <span class="n">FrozenMappingWarningOnValuesAccess</span><span class="p">,</span>
    <span class="n">HybridMappingProxy</span><span class="p">,</span>
    <span class="n">OrderedSet</span><span class="p">,</span>
    <span class="n">_default</span><span class="p">,</span>
    <span class="n">decode_numpy_dict_values</span><span class="p">,</span>
    <span class="n">drop_dims_from_indexers</span><span class="p">,</span>
    <span class="n">either_dict_or_kwargs</span><span class="p">,</span>
    <span class="n">emit_user_level_warning</span><span class="p">,</span>
    <span class="n">infix_dims</span><span class="p">,</span>
    <span class="n">is_dict_like</span><span class="p">,</span>
    <span class="n">is_duck_array</span><span class="p">,</span>
    <span class="n">is_duck_dask_array</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
    <span class="n">maybe_wrap_array</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">xarray.core.variable</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">IndexVariable</span><span class="p">,</span>
    <span class="n">Variable</span><span class="p">,</span>
    <span class="n">as_variable</span><span class="p">,</span>
    <span class="n">broadcast_variables</span><span class="p">,</span>
    <span class="n">calculate_dimensions</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">xarray.namedarray.parallelcompat</span> <span class="kn">import</span> <span class="n">get_chunked_array_type</span><span class="p">,</span> <span class="n">guess_chunkmanager</span>
<span class="kn">from</span> <span class="nn">xarray.namedarray.pycompat</span> <span class="kn">import</span> <span class="n">array_type</span><span class="p">,</span> <span class="n">is_chunked_array</span>
<span class="kn">from</span> <span class="nn">xarray.plot.accessor</span> <span class="kn">import</span> <span class="n">DatasetPlotAccessor</span>
<span class="kn">from</span> <span class="nn">xarray.util.deprecation_helpers</span> <span class="kn">import</span> <span class="n">_deprecate_positional_args</span><span class="p">,</span> <span class="n">deprecate_dims</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">dask.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span> <span class="k">as</span> <span class="n">DaskDataFrame</span>
    <span class="kn">from</span> <span class="nn">dask.delayed</span> <span class="kn">import</span> <span class="n">Delayed</span>
    <span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">ArrayLike</span>

    <span class="kn">from</span> <span class="nn">xarray.backends</span> <span class="kn">import</span> <span class="n">AbstractDataStore</span><span class="p">,</span> <span class="n">ZarrStore</span>
    <span class="kn">from</span> <span class="nn">xarray.backends.api</span> <span class="kn">import</span> <span class="n">T_NetcdfEngine</span><span class="p">,</span> <span class="n">T_NetcdfTypes</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>
    <span class="kn">from</span> <span class="nn">xarray.core.groupby</span> <span class="kn">import</span> <span class="n">DatasetGroupBy</span>
    <span class="kn">from</span> <span class="nn">xarray.core.merge</span> <span class="kn">import</span> <span class="n">CoercibleMapping</span><span class="p">,</span> <span class="n">CoercibleValue</span><span class="p">,</span> <span class="n">_MergeResult</span>
    <span class="kn">from</span> <span class="nn">xarray.core.resample</span> <span class="kn">import</span> <span class="n">DatasetResample</span>
    <span class="kn">from</span> <span class="nn">xarray.core.rolling</span> <span class="kn">import</span> <span class="n">DatasetCoarsen</span><span class="p">,</span> <span class="n">DatasetRolling</span>
    <span class="kn">from</span> <span class="nn">xarray.core.types</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">CFCalendar</span><span class="p">,</span>
        <span class="n">CoarsenBoundaryOptions</span><span class="p">,</span>
        <span class="n">CombineAttrsOptions</span><span class="p">,</span>
        <span class="n">CompatOptions</span><span class="p">,</span>
        <span class="n">DataVars</span><span class="p">,</span>
        <span class="n">DatetimeLike</span><span class="p">,</span>
        <span class="n">DatetimeUnitOptions</span><span class="p">,</span>
        <span class="n">Dims</span><span class="p">,</span>
        <span class="n">DsCompatible</span><span class="p">,</span>
        <span class="n">ErrorOptions</span><span class="p">,</span>
        <span class="n">ErrorOptionsWithWarn</span><span class="p">,</span>
        <span class="n">GroupInput</span><span class="p">,</span>
        <span class="n">InterpOptions</span><span class="p">,</span>
        <span class="n">JoinOptions</span><span class="p">,</span>
        <span class="n">PadModeOptions</span><span class="p">,</span>
        <span class="n">PadReflectOptions</span><span class="p">,</span>
        <span class="n">QueryEngineOptions</span><span class="p">,</span>
        <span class="n">QueryParserOptions</span><span class="p">,</span>
        <span class="n">ReindexMethodOptions</span><span class="p">,</span>
        <span class="n">ResampleCompatible</span><span class="p">,</span>
        <span class="n">SideOptions</span><span class="p">,</span>
        <span class="n">T_ChunkDimFreq</span><span class="p">,</span>
        <span class="n">T_DatasetPadConstantValues</span><span class="p">,</span>
        <span class="n">T_Xarray</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="kn">from</span> <span class="nn">xarray.core.weighted</span> <span class="kn">import</span> <span class="n">DatasetWeighted</span>
    <span class="kn">from</span> <span class="nn">xarray.groupers</span> <span class="kn">import</span> <span class="n">Grouper</span><span class="p">,</span> <span class="n">Resampler</span>
    <span class="kn">from</span> <span class="nn">xarray.namedarray.parallelcompat</span> <span class="kn">import</span> <span class="n">ChunkManagerEntrypoint</span>


<span class="c1"># list of attributes of pd.DatetimeIndex that are ndarrays of time info</span>
<span class="n">_DATETIMEINDEX_COMPONENTS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;year&quot;</span><span class="p">,</span>
    <span class="s2">&quot;month&quot;</span><span class="p">,</span>
    <span class="s2">&quot;day&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hour&quot;</span><span class="p">,</span>
    <span class="s2">&quot;minute&quot;</span><span class="p">,</span>
    <span class="s2">&quot;second&quot;</span><span class="p">,</span>
    <span class="s2">&quot;microsecond&quot;</span><span class="p">,</span>
    <span class="s2">&quot;nanosecond&quot;</span><span class="p">,</span>
    <span class="s2">&quot;date&quot;</span><span class="p">,</span>
    <span class="s2">&quot;time&quot;</span><span class="p">,</span>
    <span class="s2">&quot;dayofyear&quot;</span><span class="p">,</span>
    <span class="s2">&quot;weekofyear&quot;</span><span class="p">,</span>
    <span class="s2">&quot;dayofweek&quot;</span><span class="p">,</span>
    <span class="s2">&quot;quarter&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">def</span> <span class="nf">_get_virtual_variable</span><span class="p">(</span>
    <span class="n">variables</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">:</span> <span class="n">Mapping</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get a virtual variable (e.g., &#39;time.year&#39;) from a dict of xarray.Variable</span>
<span class="sd">    objects (if possible)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

    <span class="k">if</span> <span class="n">dim_sizes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dim_sizes</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim_sizes</span><span class="p">[</span><span class="n">key</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">IndexVariable</span><span class="p">((</span><span class="n">key</span><span class="p">,),</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">variable</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="n">split_key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_key</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="n">ref_name</span><span class="p">,</span> <span class="n">var_name</span> <span class="o">=</span> <span class="n">split_key</span>
    <span class="n">ref_var</span> <span class="o">=</span> <span class="n">variables</span><span class="p">[</span><span class="n">ref_name</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">_contains_datetime_like_objects</span><span class="p">(</span><span class="n">ref_var</span><span class="p">):</span>
        <span class="n">ref_var</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">ref_var</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ref_var</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ref_var</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
    <span class="n">virtual_var</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">ref_var</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ref_name</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">virtual_var</span>


<span class="k">def</span> <span class="nf">_get_chunk</span><span class="p">(</span><span class="n">var</span><span class="p">:</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">chunkmanager</span><span class="p">:</span> <span class="n">ChunkManagerEntrypoint</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return map from each dim to chunk sizes, accounting for backend&#39;s preferred chunks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">IndexVariable</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Determine the explicit requested chunks.</span>
    <span class="n">preferred_chunks</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;preferred_chunks&quot;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="n">preferred_chunk_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="n">preferred_chunks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">chunks</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">):</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>
    <span class="n">chunk_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">preferred_chunk_sizes</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">preferred_chunk_sizes</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">preferred_chunk_shape</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">chunk_shape</span> <span class="o">=</span> <span class="n">chunkmanager</span><span class="o">.</span><span class="n">normalize_chunks</span><span class="p">(</span>
        <span class="n">chunk_shape</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">var</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">previous_chunks</span><span class="o">=</span><span class="n">preferred_chunk_shape</span>
    <span class="p">)</span>

    <span class="c1"># Warn where requested chunks break preferred chunks, provided that the variable</span>
    <span class="c1"># contains data.</span>
    <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">chunk_sizes</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">chunk_shape</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">preferred_chunk_sizes</span> <span class="o">=</span> <span class="n">preferred_chunks</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Determine the stop indices of the preferred chunks, but omit the last stop</span>
            <span class="c1"># (equal to the dim size).  In particular, assume that when a sequence</span>
            <span class="c1"># expresses the preferred chunks, the sequence sums to the size.</span>
            <span class="n">preferred_stops</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="n">preferred_chunk_sizes</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">preferred_chunk_sizes</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">preferred_chunk_sizes</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">itertools</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">preferred_chunk_sizes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="c1"># Gather any stop indices of the specified chunks that are not a stop index</span>
            <span class="c1"># of a preferred chunk.  Again, omit the last stop, assuming that it equals</span>
            <span class="c1"># the dim size.</span>
            <span class="n">breaks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">chunk_sizes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span>
                <span class="n">preferred_stops</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">breaks</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;The specified chunks separate the stored chunks along &quot;</span>
                    <span class="sa">f</span><span class="s1">&#39;dimension &quot;</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s1">&quot; starting at index </span><span class="si">{</span><span class="nb">min</span><span class="p">(</span><span class="n">breaks</span><span class="p">)</span><span class="si">}</span><span class="s1">. This could &#39;</span>
                    <span class="s2">&quot;degrade performance. Instead, consider rechunking after loading.&quot;</span>
                <span class="p">)</span>

    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">chunk_shape</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_maybe_chunk</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">var</span><span class="p">:</span> <span class="n">Variable</span><span class="p">,</span>
    <span class="n">chunks</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">T_ChunkDim</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">token</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">lock</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">name_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xarray-&quot;</span><span class="p">,</span>
    <span class="n">overwrite_encoded_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">inline_array</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">chunked_array_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">ChunkManagerEntrypoint</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">from_array_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Variable</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">xarray.namedarray.daskmanager</span> <span class="kn">import</span> <span class="n">DaskManager</span>

    <span class="k">if</span> <span class="n">chunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="n">chunks</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="n">chunked_array_type</span> <span class="o">=</span> <span class="n">guess_chunkmanager</span><span class="p">(</span>
            <span class="n">chunked_array_type</span>
        <span class="p">)</span>  <span class="c1"># coerce string to ChunkManagerEntrypoint type</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunked_array_type</span><span class="p">,</span> <span class="n">DaskManager</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">dask.base</span> <span class="kn">import</span> <span class="n">tokenize</span>

            <span class="c1"># when rechunking by different amounts, make sure dask names change</span>
            <span class="c1"># by providing chunks as an input to tokenize.</span>
            <span class="c1"># subtle bugs result otherwise. see GH3350</span>
            <span class="c1"># we use str() for speed, and use the name for the final array name on the next line</span>
            <span class="n">token2</span> <span class="o">=</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">token</span> <span class="k">if</span> <span class="n">token</span> <span class="k">else</span> <span class="n">var</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
            <span class="n">name2</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name_prefix</span><span class="si">}{</span><span class="n">name</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">token2</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">from_array_kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">consolidate_dask_from_array_kwargs</span><span class="p">(</span>
                <span class="n">from_array_kwargs</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
                <span class="n">lock</span><span class="o">=</span><span class="n">lock</span><span class="p">,</span>
                <span class="n">inline_array</span><span class="o">=</span><span class="n">inline_array</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span>
            <span class="n">chunks</span><span class="p">,</span>
            <span class="n">chunked_array_type</span><span class="o">=</span><span class="n">chunked_array_type</span><span class="p">,</span>
            <span class="n">from_array_kwargs</span><span class="o">=</span><span class="n">from_array_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">overwrite_encoded_chunks</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">chunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">var</span><span class="o">.</span><span class="n">encoding</span><span class="p">[</span><span class="s2">&quot;chunks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">var</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">var</span>


<span class="k">def</span> <span class="nf">as_dataset</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cast the given object to a Dataset.</span>

<span class="sd">    Handles Datasets, DataArrays and dictionaries of variables. A new Dataset</span>
<span class="sd">    object is only created if the provided object is not already one.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;to_dataset&quot;</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span>


<span class="k">def</span> <span class="nf">_get_func_args</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">param_names</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use `inspect.signature` to try accessing `func` args. Otherwise, ensure</span>
<span class="sd">    they are provided by user.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">func_args</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">func_args</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">param_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Unable to inspect `func` signature, and `param_names` was not provided.&quot;</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="n">param_names</span><span class="p">:</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">param_names</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">func_args</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">func_args</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`param_names` must be provided because `func` takes variable length arguments.&quot;</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">func_args</span>


<span class="k">def</span> <span class="nf">_initialize_curvefit_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">func_args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set initial guess and bounds for curvefit.</span>
<span class="sd">    Priority: 1) passed args 2) func signature 3) scipy defaults</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">xarray.core.computation</span> <span class="kn">import</span> <span class="n">where</span>

    <span class="k">def</span> <span class="nf">_initialize_feasible</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">):</span>
        <span class="c1"># Mimics functionality of scipy.optimize.minpack._initialize_feasible</span>
        <span class="n">lb_finite</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span>
        <span class="n">ub_finite</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span>
            <span class="n">lb_finite</span><span class="p">,</span>
            <span class="n">where</span><span class="p">(</span>
                <span class="n">ub_finite</span><span class="p">,</span>
                <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">lb</span> <span class="o">+</span> <span class="n">ub</span><span class="p">),</span>  <span class="c1"># both bounds finite</span>
                <span class="n">lb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># lower bound finite, upper infinite</span>
            <span class="p">),</span>
            <span class="n">where</span><span class="p">(</span>
                <span class="n">ub_finite</span><span class="p">,</span>
                <span class="n">ub</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># lower bound infinite, upper finite</span>
                <span class="mi">0</span><span class="p">,</span>  <span class="c1"># both bounds infinite</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">p0</span>

    <span class="n">param_defaults</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">}</span>
    <span class="n">bounds_defaults</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">func_args</span> <span class="ow">and</span> <span class="n">func_args</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">func_args</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">param_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_args</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">default</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">:</span>
            <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
            <span class="n">bounds_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
            <span class="n">param_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span>
                <span class="p">(</span><span class="n">param_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lb</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">param_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ub</span><span class="p">),</span>
                <span class="n">_initialize_feasible</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">),</span>
                <span class="n">param_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p0</span><span class="p">:</span>
            <span class="n">param_defaults</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">p0</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">param_defaults</span><span class="p">,</span> <span class="n">bounds_defaults</span>


<span class="k">def</span> <span class="nf">merge_data_and_coords</span><span class="p">(</span><span class="n">data_vars</span><span class="p">:</span> <span class="n">DataVars</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_MergeResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Used in Dataset.__init__.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">Coordinates</span><span class="p">):</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">create_coords_with_default_indexes</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">data_vars</span><span class="p">)</span>

    <span class="c1"># exclude coords from alignment (all variables in a Coordinates object should</span>
    <span class="c1"># already be aligned together) and use coordinates&#39; indexes to align data_vars</span>
    <span class="k">return</span> <span class="n">merge_core</span><span class="p">(</span>
        <span class="p">[</span><span class="n">data_vars</span><span class="p">,</span> <span class="n">coords</span><span class="p">],</span>
        <span class="n">compat</span><span class="o">=</span><span class="s2">&quot;broadcast_equals&quot;</span><span class="p">,</span>
        <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span>
        <span class="n">explicit_coords</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span>
        <span class="n">indexes</span><span class="o">=</span><span class="n">coords</span><span class="o">.</span><span class="n">xindexes</span><span class="p">,</span>
        <span class="n">priority_arg</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">skip_align_args</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span>


<span class="k">class</span> <span class="nc">DataVariables</span><span class="p">(</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">]):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_dataset&quot;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span> <span class="o">=</span> <span class="n">dataset</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">key</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_variables</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_coord_names</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">length</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;something is wrong with Dataset._coord_names&quot;</span>
        <span class="k">return</span> <span class="n">length</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_variables</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_coord_names</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataArray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">formatting</span><span class="o">.</span><span class="n">data_vars_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]:</span>
        <span class="n">all_variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">variables</span>
        <span class="k">return</span> <span class="n">Frozen</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">all_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">})</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Frozen</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mapping from data variable names to dtypes.</span>

<span class="sd">        Cannot be modified directly, but is updated when adding new variables.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.dtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">dtypes</span>

    <span class="k">def</span> <span class="nf">_ipython_key_completions_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide method for the key-autocompletions in IPython.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">key</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_ipython_key_completions_</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_coord_names</span>
        <span class="p">]</span>


<span class="k">class</span> <span class="nc">_LocIndexer</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T_Dataset</span><span class="p">]):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dataset&quot;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">T_Dataset</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T_Dataset</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can only lookup dictionaries from Dataset.loc&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;can only set locations defined by dictionaries from Dataset.loc.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; Got: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># set new values</span>
        <span class="n">dim_indexers</span> <span class="o">=</span> <span class="n">map_index_queries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">dim_indexers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="n">dim_indexers</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>


<div class="viewcode-block" id="Dataset">
<a class="viewcode-back" href="../../../api/generated/larch.Dataset.html#larch.Dataset">[docs]</a>
<span class="k">class</span> <span class="nc">Dataset</span><span class="p">(</span>
    <span class="n">DataWithCoords</span><span class="p">,</span>
    <span class="n">DatasetAggregations</span><span class="p">,</span>
    <span class="n">DatasetArithmetic</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">],</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A multi-dimensional, in memory, array database.</span>

<span class="sd">    A dataset resembles an in-memory representation of a NetCDF file,</span>
<span class="sd">    and consists of variables, coordinates and attributes which</span>
<span class="sd">    together form a self describing dataset.</span>

<span class="sd">    Dataset implements the mapping interface with keys given by variable</span>
<span class="sd">    names and values given by DataArray objects for each variable name.</span>

<span class="sd">    By default, pandas indexes are created for one dimensional variables with</span>
<span class="sd">    name equal to their dimension (i.e., :term:`Dimension coordinate`) so those</span>
<span class="sd">    variables can be readily used as coordinates for label based indexing. When a</span>
<span class="sd">    :py:class:`~xarray.Coordinates` object is passed to ``coords``, any existing</span>
<span class="sd">    index(es) built from those coordinates will be added to the Dataset.</span>

<span class="sd">    To load data from a file or file-like object, use the `open_dataset`</span>
<span class="sd">    function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_vars : dict-like, optional</span>
<span class="sd">        A mapping from variable names to :py:class:`~xarray.DataArray`</span>
<span class="sd">        objects, :py:class:`~xarray.Variable` objects or to tuples of</span>
<span class="sd">        the form ``(dims, data[, attrs])`` which can be used as</span>
<span class="sd">        arguments to create a new ``Variable``. Each dimension must</span>
<span class="sd">        have the same length in all variables in which it appears.</span>

<span class="sd">        The following notations are accepted:</span>

<span class="sd">        - mapping {var name: DataArray}</span>
<span class="sd">        - mapping {var name: Variable}</span>
<span class="sd">        - mapping {var name: (dimension name, array-like)}</span>
<span class="sd">        - mapping {var name: (tuple of dimension names, array-like)}</span>
<span class="sd">        - mapping {dimension name: array-like}</span>
<span class="sd">          (if array-like is not a scalar it will be automatically moved to coords,</span>
<span class="sd">          see below)</span>

<span class="sd">        Each dimension must have the same length in all variables in</span>
<span class="sd">        which it appears.</span>
<span class="sd">    coords : :py:class:`~xarray.Coordinates` or dict-like, optional</span>
<span class="sd">        A :py:class:`~xarray.Coordinates` object or another mapping in</span>
<span class="sd">        similar form as the `data_vars` argument, except that each item</span>
<span class="sd">        is saved on the dataset as a &quot;coordinate&quot;.</span>
<span class="sd">        These variables have an associated meaning: they describe</span>
<span class="sd">        constant/fixed/independent quantities, unlike the</span>
<span class="sd">        varying/measured/dependent quantities that belong in</span>
<span class="sd">        `variables`.</span>

<span class="sd">        The following notations are accepted for arbitrary mappings:</span>

<span class="sd">        - mapping {coord name: DataArray}</span>
<span class="sd">        - mapping {coord name: Variable}</span>
<span class="sd">        - mapping {coord name: (dimension name, array-like)}</span>
<span class="sd">        - mapping {coord name: (tuple of dimension names, array-like)}</span>
<span class="sd">        - mapping {dimension name: array-like}</span>
<span class="sd">          (the dimension name is implicitly set to be the same as the</span>
<span class="sd">          coord name)</span>

<span class="sd">        The last notation implies either that the coordinate value is a scalar</span>
<span class="sd">        or that it is a 1-dimensional array and the coord name is the same as</span>
<span class="sd">        the dimension name (i.e., a :term:`Dimension coordinate`). In the latter</span>
<span class="sd">        case, the 1-dimensional array will be assumed to give index values</span>
<span class="sd">        along the dimension with the same name.</span>

<span class="sd">        Alternatively, a :py:class:`~xarray.Coordinates` object may be used in</span>
<span class="sd">        order to explicitly pass indexes (e.g., a multi-index or any custom</span>
<span class="sd">        Xarray index) or to bypass the creation of a default index for any</span>
<span class="sd">        :term:`Dimension coordinate` included in that object.</span>

<span class="sd">    attrs : dict-like, optional</span>
<span class="sd">        Global attributes to save on this dataset.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example dataset, we will represent measurements of the temperature</span>
<span class="sd">    and pressure that were made under various conditions:</span>

<span class="sd">    * the measurements were made on four different days;</span>
<span class="sd">    * they were made at two separate locations, which we will represent using</span>
<span class="sd">      their latitude and longitude; and</span>
<span class="sd">    * they were made using three instrument developed by three different</span>
<span class="sd">      manufacturers, which we will refer to using the strings `&#39;manufac1&#39;`,</span>
<span class="sd">      `&#39;manufac2&#39;`, and `&#39;manufac3&#39;`.</span>

<span class="sd">    &gt;&gt;&gt; np.random.seed(0)</span>
<span class="sd">    &gt;&gt;&gt; temperature = 15 + 8 * np.random.randn(2, 3, 4)</span>
<span class="sd">    &gt;&gt;&gt; precipitation = 10 * np.random.rand(2, 3, 4)</span>
<span class="sd">    &gt;&gt;&gt; lon = [-99.83, -99.32]</span>
<span class="sd">    &gt;&gt;&gt; lat = [42.25, 42.21]</span>
<span class="sd">    &gt;&gt;&gt; instruments = [&quot;manufac1&quot;, &quot;manufac2&quot;, &quot;manufac3&quot;]</span>
<span class="sd">    &gt;&gt;&gt; time = pd.date_range(&quot;2014-09-06&quot;, periods=4)</span>
<span class="sd">    &gt;&gt;&gt; reference_time = pd.Timestamp(&quot;2014-09-05&quot;)</span>

<span class="sd">    Here, we initialize the dataset with multiple dimensions. We use the string</span>
<span class="sd">    `&quot;loc&quot;` to represent the location dimension of the data, the string</span>
<span class="sd">    `&quot;instrument&quot;` to represent the instrument manufacturer dimension, and the</span>
<span class="sd">    string `&quot;time&quot;` for the time dimension.</span>

<span class="sd">    &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">    ...     data_vars=dict(</span>
<span class="sd">    ...         temperature=([&quot;loc&quot;, &quot;instrument&quot;, &quot;time&quot;], temperature),</span>
<span class="sd">    ...         precipitation=([&quot;loc&quot;, &quot;instrument&quot;, &quot;time&quot;], precipitation),</span>
<span class="sd">    ...     ),</span>
<span class="sd">    ...     coords=dict(</span>
<span class="sd">    ...         lon=(&quot;loc&quot;, lon),</span>
<span class="sd">    ...         lat=(&quot;loc&quot;, lat),</span>
<span class="sd">    ...         instrument=instruments,</span>
<span class="sd">    ...         time=time,</span>
<span class="sd">    ...         reference_time=reference_time,</span>
<span class="sd">    ...     ),</span>
<span class="sd">    ...     attrs=dict(description=&quot;Weather related data.&quot;),</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; ds</span>
<span class="sd">    &lt;xarray.Dataset&gt; Size: 552B</span>
<span class="sd">    Dimensions:         (loc: 2, instrument: 3, time: 4)</span>
<span class="sd">    Coordinates:</span>
<span class="sd">        lon             (loc) float64 16B -99.83 -99.32</span>
<span class="sd">        lat             (loc) float64 16B 42.25 42.21</span>
<span class="sd">      * instrument      (instrument) &lt;U8 96B &#39;manufac1&#39; &#39;manufac2&#39; &#39;manufac3&#39;</span>
<span class="sd">      * time            (time) datetime64[ns] 32B 2014-09-06 ... 2014-09-09</span>
<span class="sd">        reference_time  datetime64[ns] 8B 2014-09-05</span>
<span class="sd">    Dimensions without coordinates: loc</span>
<span class="sd">    Data variables:</span>
<span class="sd">        temperature     (loc, instrument, time) float64 192B 29.11 18.2 ... 9.063</span>
<span class="sd">        precipitation   (loc, instrument, time) float64 192B 4.562 5.684 ... 1.613</span>
<span class="sd">    Attributes:</span>
<span class="sd">        description:  Weather related data.</span>

<span class="sd">    Find out where the coldest temperature was and what values the</span>
<span class="sd">    other variables had:</span>

<span class="sd">    &gt;&gt;&gt; ds.isel(ds.temperature.argmin(...))</span>
<span class="sd">    &lt;xarray.Dataset&gt; Size: 80B</span>
<span class="sd">    Dimensions:         ()</span>
<span class="sd">    Coordinates:</span>
<span class="sd">        lon             float64 8B -99.32</span>
<span class="sd">        lat             float64 8B 42.21</span>
<span class="sd">        instrument      &lt;U8 32B &#39;manufac3&#39;</span>
<span class="sd">        time            datetime64[ns] 8B 2014-09-06</span>
<span class="sd">        reference_time  datetime64[ns] 8B 2014-09-05</span>
<span class="sd">    Data variables:</span>
<span class="sd">        temperature     float64 8B -5.424</span>
<span class="sd">        precipitation   float64 8B 9.884</span>
<span class="sd">    Attributes:</span>
<span class="sd">        description:  Weather related data.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_attrs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="n">_coord_names</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span>
    <span class="n">_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="n">_encoding</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">_close</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">_indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span>
    <span class="n">_variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;_attrs&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_cache&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_coord_names&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_dims&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_encoding&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_close&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_indexes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_variables&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__weakref__&quot;</span><span class="p">,</span>
    <span class="p">)</span>

<div class="viewcode-block" id="Dataset.__init__">
<a class="viewcode-back" href="../../../api/generated/larch.Dataset.html#larch.Dataset.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="c1"># could make a VariableArgs to use more generally, and refine these</span>
        <span class="c1"># categories</span>
        <span class="n">data_vars</span><span class="p">:</span> <span class="n">DataVars</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">coords</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attrs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_vars</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">both_data_and_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">data_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">both_data_and_coords</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;variables </span><span class="si">{</span><span class="n">both_data_and_coords</span><span class="si">!r}</span><span class="s2"> are found in both data_vars and coords&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">_variables</span>

        <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">merge_data_and_coords</span><span class="p">(</span>
            <span class="n">data_vars</span><span class="p">,</span> <span class="n">coords</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span> <span class="k">if</span> <span class="n">attrs</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">=</span> <span class="n">coord_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="n">dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="o">=</span> <span class="n">indexes</span></div>


    <span class="c1"># TODO: dirty workaround for mypy 1.5 error with inherited DatasetOpsMixin vs. Mapping</span>
    <span class="c1"># related to https://github.com/python/mypy/issues/9319?</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">DsCompatible</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>  <span class="c1"># type: ignore[override]</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_store</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">store</span><span class="p">,</span> <span class="n">decoder</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new dataset from the contents of a backends.*DataStore</span>
<span class="sd">        object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span><span class="p">,</span> <span class="n">attributes</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">decoder</span><span class="p">:</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">attributes</span> <span class="o">=</span> <span class="n">decoder</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">attributes</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attributes</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">set_close</span><span class="p">(</span><span class="n">store</span><span class="o">.</span><span class="n">close</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Frozen</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Low level interface to Dataset contents as dict of Variable objects.</span>

<span class="sd">        This ordered dictionary is frozen to prevent mutation that could</span>
<span class="sd">        violate Dataset invariants. It contains all variable objects</span>
<span class="sd">        constituting the Dataset, including both data variables and</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Frozen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary of global attributes on this dataset&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span>

    <span class="nd">@attrs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="n">value</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary of global encoding attributes on this dataset&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span>

    <span class="nd">@encoding</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset_encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;reset_encoding is deprecated since 2023.11, use `drop_encoding` instead&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_encoding</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">drop_encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new Dataset without encoding on the dataset or any of its</span>
<span class="sd">        variables/coords.&quot;&quot;&quot;</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">drop_encoding</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="p">{})</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dims</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Frozen</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mapping from dimension names to lengths.</span>

<span class="sd">        Cannot be modified directly, but is updated when adding new variables.</span>

<span class="sd">        Note that type of this object differs from `DataArray.dims`.</span>
<span class="sd">        See `Dataset.sizes` and `DataArray.sizes` for consistently named</span>
<span class="sd">        properties. This property will be changed to return a type more consistent with</span>
<span class="sd">        `DataArray.dims` in the future, i.e. a set of dimension names.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.sizes</span>
<span class="sd">        DataArray.dims</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FrozenMappingWarningOnValuesAccess</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Frozen</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mapping from dimension names to lengths.</span>

<span class="sd">        Cannot be modified directly, but is updated when adding new variables.</span>

<span class="sd">        This is an alias for `Dataset.dims` provided for the benefit of</span>
<span class="sd">        consistency with `DataArray.sizes`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.sizes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Frozen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Frozen</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mapping from data variable names to dtypes.</span>

<span class="sd">        Cannot be modified directly, but is updated when adding new variables.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.dtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Frozen</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="n">n</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Manually trigger loading and/or computation of this dataset&#39;s data</span>
<span class="sd">        from disk or a remote source into memory and return this dataset.</span>
<span class="sd">        Unlike compute, the original dataset is modified and returned.</span>

<span class="sd">        Normally, it should not be necessary to call this method in user code,</span>
<span class="sd">        because all xarray functions should either work on deferred data or</span>
<span class="sd">        load data automatically. However, this method can be necessary when</span>
<span class="sd">        working with many file objects on disk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional keyword arguments passed on to ``dask.compute``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.compute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># access .data to coerce everything to numpy or dask arrays</span>
        <span class="n">lazy_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">_data</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">is_chunked_array</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">lazy_data</span><span class="p">:</span>
            <span class="n">chunkmanager</span> <span class="o">=</span> <span class="n">get_chunked_array_type</span><span class="p">(</span><span class="o">*</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

            <span class="c1"># evaluate all the chunked arrays simultaneously</span>
            <span class="n">evaluated_data</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunkmanager</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span>
                <span class="o">*</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lazy_data</span><span class="p">,</span> <span class="n">evaluated_data</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="c1"># load everything else sequentially</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lazy_data</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__dask_tokenize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">dask.base</span> <span class="kn">import</span> <span class="n">normalize_token</span>

        <span class="k">return</span> <span class="n">normalize_token</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__dask_graph__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">graphs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">graphs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graphs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">graphs</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">dask.highlevelgraph</span> <span class="kn">import</span> <span class="n">HighLevelGraph</span>

                <span class="k">return</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">dask</span> <span class="kn">import</span> <span class="n">sharedict</span>

                <span class="k">return</span> <span class="n">sharedict</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__dask_keys__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">dask</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="n">v</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">dask</span><span class="o">.</span><span class="n">is_dask_collection</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__dask_layers__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">dask</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">v</span><span class="o">.</span><span class="n">__dask_layers__</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">dask</span><span class="o">.</span><span class="n">is_dask_collection</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="p">(),</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">__dask_optimize__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>

        <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="o">.</span><span class="n">__dask_optimize__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">__dask_scheduler__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>

        <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="o">.</span><span class="n">__dask_scheduler__</span>

    <span class="k">def</span> <span class="nf">__dask_postcompute__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dask_postcompute</span><span class="p">,</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__dask_postpersist__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dask_postpersist</span><span class="p">,</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">_dask_postcompute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Variable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">dask</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">results_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">dask</span><span class="o">.</span><span class="n">is_dask_collection</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="n">rebuild</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">__dask_postcompute__</span><span class="p">()</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">rebuild</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">results_iter</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_construct_direct</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dask_postpersist</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dsk</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">rename</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">dask</span> <span class="kn">import</span> <span class="n">is_dask_collection</span>
        <span class="kn">from</span> <span class="nn">dask.highlevelgraph</span> <span class="kn">import</span> <span class="n">HighLevelGraph</span>
        <span class="kn">from</span> <span class="nn">dask.optimization</span> <span class="kn">import</span> <span class="n">cull</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dask_collection</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dsk</span><span class="p">,</span> <span class="n">HighLevelGraph</span><span class="p">):</span>
                <span class="c1"># dask &gt;= 2021.3</span>
                <span class="c1"># __dask_postpersist__() was called by dask.highlevelgraph.</span>
                <span class="c1"># Don&#39;t use dsk.cull(), as we need to prevent partial layers:</span>
                <span class="c1"># https://github.com/dask/dask/issues/7137</span>
                <span class="n">layers</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">__dask_layers__</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">rename</span><span class="p">:</span>
                    <span class="n">layers</span> <span class="o">=</span> <span class="p">[</span><span class="n">rename</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">]</span>
                <span class="n">dsk2</span> <span class="o">=</span> <span class="n">dsk</span><span class="o">.</span><span class="n">cull_layers</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">rename</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
                <span class="c1"># At the moment of writing, this is only for forward compatibility.</span>
                <span class="c1"># replace_name_in_key requires dask &gt;= 2021.3.</span>
                <span class="kn">from</span> <span class="nn">dask.base</span> <span class="kn">import</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">replace_name_in_key</span>

                <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">replace_name_in_key</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">rename</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">())</span>
                <span class="p">]</span>
                <span class="n">dsk2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cull</span><span class="p">(</span><span class="n">dsk</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># __dask_postpersist__() was called by dask.optimize or dask.persist</span>
                <span class="n">dsk2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cull</span><span class="p">(</span><span class="n">dsk</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">())</span>

            <span class="n">rebuild</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">__dask_postpersist__</span><span class="p">()</span>
            <span class="c1"># rename was added in dask 2021.3</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;rename&quot;</span><span class="p">:</span> <span class="n">rename</span><span class="p">}</span> <span class="k">if</span> <span class="n">rename</span> <span class="k">else</span> <span class="p">{}</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">rebuild</span><span class="p">(</span><span class="n">dsk2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_construct_direct</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Manually trigger loading and/or computation of this dataset&#39;s data</span>
<span class="sd">        from disk or a remote source into memory and return a new dataset.</span>
<span class="sd">        Unlike load, the original dataset is left unaltered.</span>

<span class="sd">        Normally, it should not be necessary to call this method in user code,</span>
<span class="sd">        because all xarray functions should either work on deferred data or</span>
<span class="sd">        load data automatically. However, this method can be necessary when</span>
<span class="sd">        working with many file objects on disk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional keyword arguments passed on to ``dask.compute``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object : Dataset</span>
<span class="sd">            New object with lazy data variables and coordinates as in-memory arrays.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.compute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_persist_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Persist all Dask arrays in memory&quot;&quot;&quot;</span>
        <span class="c1"># access .data to coerce everything to numpy or dask arrays</span>
        <span class="n">lazy_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">_data</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">is_duck_dask_array</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">lazy_data</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">dask</span>

            <span class="c1"># evaluate all the dask arrays simultaneously</span>
            <span class="n">evaluated_data</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">persist</span><span class="p">(</span><span class="o">*</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lazy_data</span><span class="p">,</span> <span class="n">evaluated_data</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">persist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Trigger computation, keeping data as dask arrays</span>

<span class="sd">        This operation can be used to trigger computation on underlying dask</span>
<span class="sd">        arrays, similar to ``.compute()`` or ``.load()``.  However this</span>
<span class="sd">        operation keeps the data as dask arrays. This is particularly useful</span>
<span class="sd">        when using the dask.distributed scheduler and you want to load a large</span>
<span class="sd">        amount of data into distributed memory.</span>
<span class="sd">        Like compute (but unlike load), the original dataset is left unaltered.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional keyword arguments passed on to ``dask.persist``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object : Dataset</span>
<span class="sd">            New object with all dask-backed coordinates and data variables as persisted dask arrays.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.persist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span><span class="o">.</span><span class="n">_persist_inplace</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_construct_direct</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span>
        <span class="n">coord_names</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="n">dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attrs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">close</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shortcut around __init__ for internal use when we want to skip</span>
<span class="sd">        costly validation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">calculate_dimensions</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">=</span> <span class="n">coord_names</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="n">dims</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_indexes</span> <span class="o">=</span> <span class="n">indexes</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="n">attrs</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_close</span> <span class="o">=</span> <span class="n">close</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="n">encoding</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">coord_names</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attrs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Default</span> <span class="o">=</span> <span class="n">_default</span><span class="p">,</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Default</span> <span class="o">=</span> <span class="n">_default</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fastpath constructor for internal use.</span>

<span class="sd">        Returns an object with optionally with replaced attributes.</span>

<span class="sd">        Explicitly passed arguments are *not* copied when placed on the new</span>
<span class="sd">        dataset. It is up to the caller to ensure that they have the right type</span>
<span class="sd">        and are not used elsewhere.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span> <span class="o">=</span> <span class="n">variables</span>
            <span class="k">if</span> <span class="n">coord_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">=</span> <span class="n">coord_names</span>
            <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="n">dims</span>
            <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_default</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="n">attrs</span>
            <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="o">=</span> <span class="n">indexes</span>
            <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_default</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="n">encoding</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">coord_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="n">_default</span><span class="p">:</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="n">_default</span><span class="p">:</span>
                <span class="n">encoding</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_direct</span><span class="p">(</span>
                <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">encoding</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_replace_with_new_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span>
        <span class="n">coord_names</span><span class="p">:</span> <span class="nb">set</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attrs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Default</span> <span class="o">=</span> <span class="n">_default</span><span class="p">,</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replace variables with recalculated dimensions.&quot;&quot;&quot;</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">calculate_dimensions</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_replace_vars_and_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span>
        <span class="n">coord_names</span><span class="p">:</span> <span class="nb">set</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attrs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Default</span> <span class="o">=</span> <span class="n">_default</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deprecated version of _replace_with_new_dims().</span>

<span class="sd">        Unlike _replace_with_new_dims(), this method always recalculates</span>
<span class="sd">        indexes from variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">calculate_dimensions</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_overwrite_indexes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">],</span>
        <span class="n">variables</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">drop_variables</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">drop_indexes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">rename_dims</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maybe replace indexes.</span>

<span class="sd">        This function may do a lot more depending on index query</span>
<span class="sd">        results.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">indexes</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">drop_variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">drop_variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">drop_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">drop_indexes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">new_variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_indexes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>

        <span class="n">index_variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">no_index_variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">old_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">old_var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">var</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">old_var</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
                <span class="n">var</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">old_var</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                <span class="n">index_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">no_index_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
            <span class="n">new_indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">index_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_coord_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">new_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="c1"># append no-index variables at the end</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">no_index_variables</span><span class="p">:</span>
            <span class="n">new_variables</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">new_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">no_index_variables</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">drop_indexes</span><span class="p">:</span>
            <span class="n">new_indexes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">drop_variables</span><span class="p">:</span>
            <span class="n">new_variables</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">new_indexes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">new_coord_names</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">replaced</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">new_variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">new_coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">new_indexes</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">rename_dims</span><span class="p">:</span>
            <span class="c1"># skip rename indexes: they should already have the right name(s)</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">replaced</span><span class="o">.</span><span class="n">_rename_dims</span><span class="p">(</span><span class="n">rename_dims</span><span class="p">)</span>
            <span class="n">new_variables</span><span class="p">,</span> <span class="n">new_coord_names</span> <span class="o">=</span> <span class="n">replaced</span><span class="o">.</span><span class="n">_rename_vars</span><span class="p">({},</span> <span class="n">rename_dims</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">replaced</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span>
                <span class="n">variables</span><span class="o">=</span><span class="n">new_variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">new_coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">replaced</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">DataVars</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a copy of this dataset.</span>

<span class="sd">        If `deep=True`, a deep copy is made of each of the component variables.</span>
<span class="sd">        Otherwise, a shallow copy of each of the component variable is made, so</span>
<span class="sd">        that the underlying memory region of the new dataset is the same as in</span>
<span class="sd">        the original dataset.</span>

<span class="sd">        Use `data` to create a new object with the same structure as</span>
<span class="sd">        original but entirely new data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep : bool, default: False</span>
<span class="sd">            Whether each component variable is loaded into memory and copied onto</span>
<span class="sd">            the new object. Default is False.</span>
<span class="sd">        data : dict-like or None, optional</span>
<span class="sd">            Data to use in the new object. Each item in `data` must have same</span>
<span class="sd">            shape as corresponding data variable in original. When `data` is</span>
<span class="sd">            used, `deep` is ignored for the data variables and only used for</span>
<span class="sd">            coords.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object : Dataset</span>
<span class="sd">            New object with dimensions, attributes, coordinates, name, encoding,</span>
<span class="sd">            and optionally data copied from original.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Shallow copy versus deep copy</span>

<span class="sd">        &gt;&gt;&gt; da = xr.DataArray(np.random.randn(2, 3))</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     {&quot;foo&quot;: da, &quot;bar&quot;: (&quot;x&quot;, [-1, 2])},</span>
<span class="sd">        ...     coords={&quot;x&quot;: [&quot;one&quot;, &quot;two&quot;]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds.copy()</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 88B</span>
<span class="sd">        Dimensions:  (dim_0: 2, dim_1: 3, x: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U3 24B &#39;one&#39; &#39;two&#39;</span>
<span class="sd">        Dimensions without coordinates: dim_0, dim_1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (dim_0, dim_1) float64 48B 1.764 0.4002 0.9787 2.241 1.868 -0.9773</span>
<span class="sd">            bar      (x) int64 16B -1 2</span>

<span class="sd">        &gt;&gt;&gt; ds_0 = ds.copy(deep=False)</span>
<span class="sd">        &gt;&gt;&gt; ds_0[&quot;foo&quot;][0, 0] = 7</span>
<span class="sd">        &gt;&gt;&gt; ds_0</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 88B</span>
<span class="sd">        Dimensions:  (dim_0: 2, dim_1: 3, x: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U3 24B &#39;one&#39; &#39;two&#39;</span>
<span class="sd">        Dimensions without coordinates: dim_0, dim_1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (dim_0, dim_1) float64 48B 7.0 0.4002 0.9787 2.241 1.868 -0.9773</span>
<span class="sd">            bar      (x) int64 16B -1 2</span>

<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 88B</span>
<span class="sd">        Dimensions:  (dim_0: 2, dim_1: 3, x: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U3 24B &#39;one&#39; &#39;two&#39;</span>
<span class="sd">        Dimensions without coordinates: dim_0, dim_1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (dim_0, dim_1) float64 48B 7.0 0.4002 0.9787 2.241 1.868 -0.9773</span>
<span class="sd">            bar      (x) int64 16B -1 2</span>

<span class="sd">        Changing the data using the ``data`` argument maintains the</span>
<span class="sd">        structure of the original object, but with the new data. Original</span>
<span class="sd">        object is unaffected.</span>

<span class="sd">        &gt;&gt;&gt; ds.copy(data={&quot;foo&quot;: np.arange(6).reshape(2, 3), &quot;bar&quot;: [&quot;a&quot;, &quot;b&quot;]})</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 80B</span>
<span class="sd">        Dimensions:  (dim_0: 2, dim_1: 3, x: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U3 24B &#39;one&#39; &#39;two&#39;</span>
<span class="sd">        Dimensions without coordinates: dim_0, dim_1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (dim_0, dim_1) int64 48B 0 1 2 3 4 5</span>
<span class="sd">            bar      (x) &lt;U1 8B &#39;a&#39; &#39;b&#39;</span>

<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 88B</span>
<span class="sd">        Dimensions:  (dim_0: 2, dim_1: 3, x: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U3 24B &#39;one&#39; &#39;two&#39;</span>
<span class="sd">        Dimensions without coordinates: dim_0, dim_1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (dim_0, dim_1) float64 48B 7.0 0.4002 0.9787 2.241 1.868 -0.9773</span>
<span class="sd">            bar      (x) int64 16B -1 2</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.DataFrame.copy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_copy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">deep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">DataVars</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">memo</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data must be dict-like&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">var_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">data_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">keys_not_in_vars</span> <span class="o">=</span> <span class="n">data_keys</span> <span class="o">-</span> <span class="n">var_keys</span>
            <span class="k">if</span> <span class="n">keys_not_in_vars</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Data must only contain variables in original &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dataset. Extra variables: </span><span class="si">{</span><span class="n">keys_not_in_vars</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">keys_missing_from_data</span> <span class="o">=</span> <span class="n">var_keys</span> <span class="o">-</span> <span class="n">data_keys</span>
            <span class="k">if</span> <span class="n">keys_missing_from_data</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Data must contain all variables in original &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dataset. Data is missing </span><span class="si">{</span><span class="n">keys_missing_from_data</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">indexes</span><span class="p">,</span> <span class="n">index_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">copy_indexes</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">index_vars</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_vars</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">_copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>

        <span class="n">attrs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span> <span class="k">if</span> <span class="n">deep</span> <span class="k">else</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">)</span>
        <span class="n">encoding</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span> <span class="k">if</span> <span class="n">deep</span> <span class="k">else</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Coerces wrapped data and coordinates into numpy arrays, returning a Dataset.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.as_numpy</span>
<span class="sd">        DataArray.to_numpy : Returns only the data as a numpy.ndarray object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numpy_variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">as_numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="o">=</span><span class="n">numpy_variables</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_copy_listed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new Dataset with the listed variables from this dataset and</span>
<span class="sd">        the all relevant coordinates. Skips all validation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">ref_name</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">_get_virtual_variable</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span>
                <span class="p">)</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
                <span class="k">if</span> <span class="n">ref_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="ow">or</span> <span class="n">ref_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">coord_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">var_name</span><span class="p">,)</span> <span class="o">==</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">index</span><span class="p">,</span> <span class="n">index_vars</span> <span class="o">=</span> <span class="n">create_default_index_implicit</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>
                    <span class="n">indexes</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">index</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">index_vars</span><span class="p">})</span>
                    <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">index_vars</span><span class="p">)</span>
                    <span class="n">coord_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">index_vars</span><span class="p">)</span>

        <span class="n">needed_dims</span><span class="p">:</span> <span class="n">OrderedSet</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedSet</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">needed_dims</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>

        <span class="n">dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">needed_dims</span><span class="p">}</span>

        <span class="c1"># preserves ordering of coordinates</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">needed_dims</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">coord_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="n">indexes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">filter_indexes_from_coords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_dataarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a DataArray by indexing this dataset&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">variable</span> <span class="o">=</span> <span class="n">_get_virtual_variable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">)</span>

        <span class="n">needed_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>

        <span class="n">coords</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># preserve ordering</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">needed_dims</span><span class="p">:</span>
                <span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="n">indexes</span> <span class="o">=</span> <span class="n">filter_indexes_from_coords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_attr_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Places to look-up items for attribute-style access&quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_item_sources</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_item_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Places to look-up items for key-completion&quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span>
        <span class="k">yield</span> <span class="n">HybridMappingProxy</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

        <span class="c1"># virtual coordinates</span>
        <span class="k">yield</span> <span class="n">HybridMappingProxy</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The &#39;in&#39; operator will return true or false depending on whether</span>
<span class="sd">        &#39;key&#39; is an array in the dataset or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
        <span class="c1"># needed because __getattr__ is returning Any and otherwise</span>
        <span class="c1"># this class counts as part of the SupportsArray Protocol</span>
        <span class="n">__array__</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore[var-annotated,unused-ignore]</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;cannot directly convert an xarray.Dataset into a &quot;</span>
                <span class="s2">&quot;numpy array. Instead, create an xarray.DataArray &quot;</span>
                <span class="s2">&quot;first, either with indexing on the Dataset or by &quot;</span>
                <span class="s2">&quot;invoking the `to_dataarray()` method.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Total bytes consumed by the data arrays of all variables in this dataset.</span>

<span class="sd">        If the backend array for any variable does not include ``nbytes``, estimates</span>
<span class="sd">        the total bytes for that array based on the ``size`` and ``dtype``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">nbytes</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_LocIndexer</span><span class="p">[</span><span class="n">Self</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute for location based indexing. Only supports __getitem__,</span>
<span class="sd">        and only when the key is a dict of the form {dim: labels}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_LocIndexer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataArray</span><span class="p">:</span> <span class="o">...</span>

    <span class="c1"># Mapping is Iterable</span>
    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span> <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span> <span class="o">|</span> <span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Access variables or coordinates of this dataset as a</span>
<span class="sd">        :py:class:`~xarray.DataArray` or a subset of variables or a indexed dataset.</span>

<span class="sd">        Indexing with a list of names will return a new ``Dataset`` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.formatting</span> <span class="kn">import</span> <span class="n">shorten_list_repr</span>

        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">**</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">hashable</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_dataarray</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;No variable named </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2">. Variables on the dataset include </span><span class="si">{</span><span class="n">shorten_list_repr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span><span class="w"> </span><span class="n">max_items</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="c1"># If someone attempts `ds[&#39;foo&#39; , &#39;bar&#39;]` instead of `ds[[&#39;foo&#39;, &#39;bar&#39;]]`</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Hint: use a list to select multiple variables, for example `ds[</span><span class="si">{</span><span class="p">[</span><span class="n">d</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">key</span><span class="p">]</span><span class="si">}</span><span class="s2">]`&quot;</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">iterable_of_hashable</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_listed</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported key-type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add an array to this dataset.</span>
<span class="sd">        Multiple arrays can be added at the same time, in which case each of</span>
<span class="sd">        the following operations is applied to the respective value.</span>

<span class="sd">        If key is dict-like, update all variables in the dataset</span>
<span class="sd">        one by one with the given value at the given location.</span>
<span class="sd">        If the given value is also a dataset, select corresponding variables</span>
<span class="sd">        in the given value and in the dataset to be changed.</span>

<span class="sd">        If value is a `</span>
<span class="sd">        from .dataarray import DataArray`, call its `select_vars()` method, rename it</span>
<span class="sd">        to `key` and merge the contents of the resulting dataset into this</span>
<span class="sd">        dataset.</span>

<span class="sd">        If value is a `Variable` object (or tuple of form</span>
<span class="sd">        ``(dims, data[, attrs])``), add it to this dataset as a new</span>
<span class="sd">        variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="c1"># check for consistency and convert value to dataset</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_check</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="c1"># loop over dataset variables and set new values</span>
            <span class="n">processed</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">var</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="n">processed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">processed</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                            <span class="s2">&quot;An error occurred while setting values of the&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; variable &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;. The following variables have&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; been successfully updated:</span><span class="se">\n</span><span class="si">{</span><span class="n">processed</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">e</span>

        <span class="k">elif</span> <span class="n">utils</span><span class="o">.</span><span class="n">hashable</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot assign a Dataset to a single key - only a DataArray or Variable &quot;</span>
                    <span class="s2">&quot;object can be stored under a single key.&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span><span class="p">})</span>

        <span class="k">elif</span> <span class="n">utils</span><span class="o">.</span><span class="n">iterable_of_hashable</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">keylist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keylist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empty list of variables to be set&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keylist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">keylist</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">value</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keylist</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Different lengths of variables to be set &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">keylist</span><span class="p">)</span><span class="si">}</span><span class="s2">) and data used as input for &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;setting (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keylist</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot assign single DataArray to multiple keys&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keylist</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported key-type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setitem_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Consistency check for __setitem__</span>

<span class="sd">        When assigning values to a subset of a Dataset, do consistency check beforehand</span>
<span class="sd">        to avoid leaving the dataset in a partially updated state when an error occurs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.alignment</span> <span class="kn">import</span> <span class="n">align</span>
        <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="n">missing_vars</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">data_vars</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">missing_vars</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Variables </span><span class="si">{</span><span class="n">missing_vars</span><span class="si">}</span><span class="s2"> in new values&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; not available in original dataset:</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">Number</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Dataset assignment only accepts DataArrays, Datasets, and scalars.&quot;</span>
            <span class="p">)</span>

        <span class="n">new_value</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># test indexing</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">var_k</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;: indexer </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> not available&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                <span class="c1"># check consistency of dimensions</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_k</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;: dimension &#39;</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">&#39; appears in new values &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;but not in the indexed original data&quot;</span>
                        <span class="p">)</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var_k</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dims</span> <span class="o">!=</span> <span class="n">val</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;: dimension order differs between&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot; original and new data:</span><span class="se">\n</span><span class="si">{</span><span class="n">dims</span><span class="si">}</span><span class="se">\n</span><span class="s2">vs.</span><span class="se">\n</span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">dims</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="c1"># type conversion</span>
            <span class="n">new_value</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">duck_array_ops</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">var_k</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># check consistency of dimension sizes and dimension coordinates</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="n">align</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">value</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;exact&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_value</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove a variable from this dataset.&quot;&quot;&quot;</span>
        <span class="n">assert_no_index_corrupted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">,</span> <span class="p">{</span><span class="n">key</span><span class="p">})</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="n">calculate_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span>

    <span class="c1"># mutable objects should not be hashable</span>
    <span class="c1"># https://github.com/python/mypy/issues/4266</span>
    <span class="fm">__hash__</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore[assignment]</span>

    <span class="k">def</span> <span class="nf">_all_compat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">,</span> <span class="n">compat_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper function for equals and identical&quot;&quot;&quot;</span>

        <span class="c1"># some stores (e.g., scipy) do not seem to preserve order, so don&#39;t</span>
        <span class="c1"># require matching order for equality</span>
        <span class="k">def</span> <span class="nf">compat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">Variable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">compat_str</span><span class="p">)(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_coord_names</span> <span class="ow">and</span> <span class="n">utils</span><span class="o">.</span><span class="n">dict_equiv</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">compat</span><span class="o">=</span><span class="n">compat</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">broadcast_equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Two Datasets are broadcast equal if they are equal after</span>
<span class="sd">        broadcasting all variables against each other.</span>

<span class="sd">        For example, variables that are scalar in one dataset but non-scalar in</span>
<span class="sd">        the other dataset can still be broadcast equal if the the non-scalar</span>
<span class="sd">        variable is a constant.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        # 2D array with shape (1, 3)</span>

<span class="sd">        &gt;&gt;&gt; data = np.array([[1, 2, 3]])</span>
<span class="sd">        &gt;&gt;&gt; a = xr.Dataset(</span>
<span class="sd">        ...     {&quot;variable_name&quot;: ((&quot;space&quot;, &quot;time&quot;), data)},</span>
<span class="sd">        ...     coords={&quot;space&quot;: [0], &quot;time&quot;: [0, 1, 2]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 56B</span>
<span class="sd">        Dimensions:        (space: 1, time: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * space          (space) int64 8B 0</span>
<span class="sd">          * time           (time) int64 24B 0 1 2</span>
<span class="sd">        Data variables:</span>
<span class="sd">            variable_name  (space, time) int64 24B 1 2 3</span>

<span class="sd">        # 2D array with shape (3, 1)</span>

<span class="sd">        &gt;&gt;&gt; data = np.array([[1], [2], [3]])</span>
<span class="sd">        &gt;&gt;&gt; b = xr.Dataset(</span>
<span class="sd">        ...     {&quot;variable_name&quot;: ((&quot;time&quot;, &quot;space&quot;), data)},</span>
<span class="sd">        ...     coords={&quot;time&quot;: [0, 1, 2], &quot;space&quot;: [0]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; b</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 56B</span>
<span class="sd">        Dimensions:        (time: 3, space: 1)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time           (time) int64 24B 0 1 2</span>
<span class="sd">          * space          (space) int64 8B 0</span>
<span class="sd">        Data variables:</span>
<span class="sd">            variable_name  (time, space) int64 24B 1 2 3</span>

<span class="sd">        .equals returns True if two Datasets have the same values, dimensions, and coordinates. .broadcast_equals returns True if the</span>
<span class="sd">        results of broadcasting two Datasets against each other have the same values, dimensions, and coordinates.</span>

<span class="sd">        &gt;&gt;&gt; a.equals(b)</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; a.broadcast_equals(b)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; a2, b2 = xr.broadcast(a, b)</span>
<span class="sd">        &gt;&gt;&gt; a2.equals(b2)</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.equals</span>
<span class="sd">        Dataset.identical</span>
<span class="sd">        Dataset.broadcast</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_compat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;broadcast_equals&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Two Datasets are equal if they have matching variables and</span>
<span class="sd">        coordinates, all of which are equal.</span>

<span class="sd">        Datasets can still be equal (like pandas objects) if they have NaN</span>
<span class="sd">        values in the same locations.</span>

<span class="sd">        This method is necessary because `v1 == v2` for ``Dataset``</span>
<span class="sd">        does element-wise comparisons (like numpy.ndarrays).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        # 2D array with shape (1, 3)</span>

<span class="sd">        &gt;&gt;&gt; data = np.array([[1, 2, 3]])</span>
<span class="sd">        &gt;&gt;&gt; dataset1 = xr.Dataset(</span>
<span class="sd">        ...     {&quot;variable_name&quot;: ((&quot;space&quot;, &quot;time&quot;), data)},</span>
<span class="sd">        ...     coords={&quot;space&quot;: [0], &quot;time&quot;: [0, 1, 2]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; dataset1</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 56B</span>
<span class="sd">        Dimensions:        (space: 1, time: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * space          (space) int64 8B 0</span>
<span class="sd">          * time           (time) int64 24B 0 1 2</span>
<span class="sd">        Data variables:</span>
<span class="sd">            variable_name  (space, time) int64 24B 1 2 3</span>

<span class="sd">        # 2D array with shape (3, 1)</span>

<span class="sd">        &gt;&gt;&gt; data = np.array([[1], [2], [3]])</span>
<span class="sd">        &gt;&gt;&gt; dataset2 = xr.Dataset(</span>
<span class="sd">        ...     {&quot;variable_name&quot;: ((&quot;time&quot;, &quot;space&quot;), data)},</span>
<span class="sd">        ...     coords={&quot;time&quot;: [0, 1, 2], &quot;space&quot;: [0]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; dataset2</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 56B</span>
<span class="sd">        Dimensions:        (time: 3, space: 1)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time           (time) int64 24B 0 1 2</span>
<span class="sd">          * space          (space) int64 8B 0</span>
<span class="sd">        Data variables:</span>
<span class="sd">            variable_name  (time, space) int64 24B 1 2 3</span>
<span class="sd">        &gt;&gt;&gt; dataset1.equals(dataset2)</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; dataset1.broadcast_equals(dataset2)</span>
<span class="sd">        True</span>

<span class="sd">        .equals returns True if two Datasets have the same values, dimensions, and coordinates. .broadcast_equals returns True if the</span>
<span class="sd">        results of broadcasting two Datasets against each other have the same values, dimensions, and coordinates.</span>

<span class="sd">        Similar for missing values too:</span>

<span class="sd">        &gt;&gt;&gt; ds1 = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;temperature&quot;: ([&quot;x&quot;, &quot;y&quot;], [[1, np.nan], [3, 4]]),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;x&quot;: [0, 1], &quot;y&quot;: [0, 1]},</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; ds2 = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;temperature&quot;: ([&quot;x&quot;, &quot;y&quot;], [[1, np.nan], [3, 4]]),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;x&quot;: [0, 1], &quot;y&quot;: [0, 1]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds1.equals(ds2)</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.broadcast_equals</span>
<span class="sd">        Dataset.identical</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_compat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;equals&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">identical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Like equals, but also checks all dataset attributes and the</span>
<span class="sd">        attributes on all variables and coordinates.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        &gt;&gt;&gt; a = xr.Dataset(</span>
<span class="sd">        ...     {&quot;Width&quot;: (&quot;X&quot;, [1, 2, 3])},</span>
<span class="sd">        ...     coords={&quot;X&quot;: [1, 2, 3]},</span>
<span class="sd">        ...     attrs={&quot;units&quot;: &quot;m&quot;},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; b = xr.Dataset(</span>
<span class="sd">        ...     {&quot;Width&quot;: (&quot;X&quot;, [1, 2, 3])},</span>
<span class="sd">        ...     coords={&quot;X&quot;: [1, 2, 3]},</span>
<span class="sd">        ...     attrs={&quot;units&quot;: &quot;m&quot;},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; c = xr.Dataset(</span>
<span class="sd">        ...     {&quot;Width&quot;: (&quot;X&quot;, [1, 2, 3])},</span>
<span class="sd">        ...     coords={&quot;X&quot;: [1, 2, 3]},</span>
<span class="sd">        ...     attrs={&quot;units&quot;: &quot;ft&quot;},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 48B</span>
<span class="sd">        Dimensions:  (X: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * X        (X) int64 24B 1 2 3</span>
<span class="sd">        Data variables:</span>
<span class="sd">            Width    (X) int64 24B 1 2 3</span>
<span class="sd">        Attributes:</span>
<span class="sd">            units:    m</span>

<span class="sd">        &gt;&gt;&gt; b</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 48B</span>
<span class="sd">        Dimensions:  (X: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * X        (X) int64 24B 1 2 3</span>
<span class="sd">        Data variables:</span>
<span class="sd">            Width    (X) int64 24B 1 2 3</span>
<span class="sd">        Attributes:</span>
<span class="sd">            units:    m</span>

<span class="sd">        &gt;&gt;&gt; c</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 48B</span>
<span class="sd">        Dimensions:  (X: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * X        (X) int64 24B 1 2 3</span>
<span class="sd">        Data variables:</span>
<span class="sd">            Width    (X) int64 24B 1 2 3</span>
<span class="sd">        Attributes:</span>
<span class="sd">            units:    ft</span>

<span class="sd">        &gt;&gt;&gt; a.equals(b)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; a.identical(b)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; a.equals(c)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; a.identical(c)</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.broadcast_equals</span>
<span class="sd">        Dataset.equals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">dict_equiv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_compat</span><span class="p">(</span>
                <span class="n">other</span><span class="p">,</span> <span class="s2">&quot;identical&quot;</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Indexes</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mapping of pandas.Index objects used for label based indexing.</span>

<span class="sd">        Raises an error if this Dataset has indexes that cannot be coerced</span>
<span class="sd">        to pandas.Index objects.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.xindexes</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">to_pandas_indexes</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xindexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Indexes</span><span class="p">[</span><span class="n">Index</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mapping of :py:class:`~xarray.indexes.Index` objects</span>
<span class="sd">        used for label based indexing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Indexes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">,</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">})</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatasetCoordinates</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mapping of :py:class:`~xarray.DataArray` objects corresponding to</span>
<span class="sd">        coordinate variables.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DatasetCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataVariables</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary of DataArray objects corresponding to data variables&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given names of one or more variables, set them as coordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : hashable or iterable of hashable</span>
<span class="sd">            Name(s) of variables in this dataset to convert into coordinates.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; dataset = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;pressure&quot;: (&quot;time&quot;, [1.013, 1.2, 3.5]),</span>
<span class="sd">        ...         &quot;time&quot;: pd.date_range(&quot;2023-01-01&quot;, periods=3),</span>
<span class="sd">        ...     }</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; dataset</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 48B</span>
<span class="sd">        Dimensions:   (time: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time      (time) datetime64[ns] 24B 2023-01-01 2023-01-02 2023-01-03</span>
<span class="sd">        Data variables:</span>
<span class="sd">            pressure  (time) float64 24B 1.013 1.2 3.5</span>

<span class="sd">        &gt;&gt;&gt; dataset.set_coords(&quot;pressure&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 48B</span>
<span class="sd">        Dimensions:   (time: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            pressure  (time) float64 24B 1.013 1.2 3.5</span>
<span class="sd">          * time      (time) datetime64[ns] 24B 2023-01-01 2023-01-02 2023-01-03</span>
<span class="sd">        Data variables:</span>
<span class="sd">            *empty*</span>

<span class="sd">        On calling ``set_coords`` , these data variables are converted to coordinates, as shown in the final dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.swap_dims</span>
<span class="sd">        Dataset.assign_coords</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: allow inserting new coordinates with this method, like</span>
        <span class="c1"># DataFrame.set_index?</span>
        <span class="c1"># nb. check in self._variables, not self.data_vars to insure that the</span>
        <span class="c1"># operation is idempotent</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_all_in_dataset</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">reset_coords</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given names of coordinates, reset them to become variables</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : str, Iterable of Hashable or None, optional</span>
<span class="sd">            Name(s) of non-index coordinates in this dataset to reset into</span>
<span class="sd">            variables. By default, all non-index coordinates are reset.</span>
<span class="sd">        drop : bool, default: False</span>
<span class="sd">            If True, remove coordinates instead of converting them into</span>
<span class="sd">            variables.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; dataset = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;temperature&quot;: (</span>
<span class="sd">        ...             [&quot;time&quot;, &quot;lat&quot;, &quot;lon&quot;],</span>
<span class="sd">        ...             [[[25, 26], [27, 28]], [[29, 30], [31, 32]]],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...         &quot;precipitation&quot;: (</span>
<span class="sd">        ...             [&quot;time&quot;, &quot;lat&quot;, &quot;lon&quot;],</span>
<span class="sd">        ...             [[[0.5, 0.8], [0.2, 0.4]], [[0.3, 0.6], [0.7, 0.9]]],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={</span>
<span class="sd">        ...         &quot;time&quot;: pd.date_range(start=&quot;2023-01-01&quot;, periods=2),</span>
<span class="sd">        ...         &quot;lat&quot;: [40, 41],</span>
<span class="sd">        ...         &quot;lon&quot;: [-80, -79],</span>
<span class="sd">        ...         &quot;altitude&quot;: 1000,</span>
<span class="sd">        ...     },</span>
<span class="sd">        ... )</span>

<span class="sd">        # Dataset before resetting coordinates</span>

<span class="sd">        &gt;&gt;&gt; dataset</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 184B</span>
<span class="sd">        Dimensions:        (time: 2, lat: 2, lon: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time           (time) datetime64[ns] 16B 2023-01-01 2023-01-02</span>
<span class="sd">          * lat            (lat) int64 16B 40 41</span>
<span class="sd">          * lon            (lon) int64 16B -80 -79</span>
<span class="sd">            altitude       int64 8B 1000</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature    (time, lat, lon) int64 64B 25 26 27 28 29 30 31 32</span>
<span class="sd">            precipitation  (time, lat, lon) float64 64B 0.5 0.8 0.2 0.4 0.3 0.6 0.7 0.9</span>

<span class="sd">        # Reset the &#39;altitude&#39; coordinate</span>

<span class="sd">        &gt;&gt;&gt; dataset_reset = dataset.reset_coords(&quot;altitude&quot;)</span>

<span class="sd">        # Dataset after resetting coordinates</span>

<span class="sd">        &gt;&gt;&gt; dataset_reset</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 184B</span>
<span class="sd">        Dimensions:        (time: 2, lat: 2, lon: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time           (time) datetime64[ns] 16B 2023-01-01 2023-01-02</span>
<span class="sd">          * lat            (lat) int64 16B 40 41</span>
<span class="sd">          * lon            (lon) int64 16B -80 -79</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature    (time, lat, lon) int64 64B 25 26 27 28 29 30 31 32</span>
<span class="sd">            precipitation  (time, lat, lon) float64 64B 0.5 0.8 0.2 0.4 0.3 0.6 0.7 0.9</span>
<span class="sd">            altitude       int64 8B 1000</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.set_coords</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assert_all_in_dataset</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="n">bad_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bad_coords</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;cannot remove index coordinates with reset_coords: </span><span class="si">{</span><span class="n">bad_coords</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drop</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">obj</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">dump_to_store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="p">:</span> <span class="n">AbstractDataStore</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Store dataset contents to a backends.*DataStore object.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.backends.api</span> <span class="kn">import</span> <span class="n">dump_to_store</span>

        <span class="c1"># TODO: rename and/or cleanup this method to make it more consistent</span>
        <span class="c1"># with to_netcdf()</span>
        <span class="n">dump_to_store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># path=None writes to bytes</span>
    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_netcdf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">NetcdfWriteModes</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="nb">format</span><span class="p">:</span> <span class="n">T_NetcdfTypes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">engine</span><span class="p">:</span> <span class="n">T_NetcdfEngine</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unlimited_dims</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">compute</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">invalid_netcdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span> <span class="o">...</span>

    <span class="c1"># compute=False returns dask.Delayed</span>
    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_netcdf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">PathLike</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">NetcdfWriteModes</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="nb">format</span><span class="p">:</span> <span class="n">T_NetcdfTypes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">engine</span><span class="p">:</span> <span class="n">T_NetcdfEngine</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unlimited_dims</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">compute</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">],</span>
        <span class="n">invalid_netcdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Delayed</span><span class="p">:</span> <span class="o">...</span>

    <span class="c1"># default return None</span>
    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_netcdf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">PathLike</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">NetcdfWriteModes</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="nb">format</span><span class="p">:</span> <span class="n">T_NetcdfTypes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">engine</span><span class="p">:</span> <span class="n">T_NetcdfEngine</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unlimited_dims</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">compute</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">invalid_netcdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

    <span class="c1"># if compute cannot be evaluated at type check time</span>
    <span class="c1"># we may get back either Delayed or None</span>
    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_netcdf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">PathLike</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">NetcdfWriteModes</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="nb">format</span><span class="p">:</span> <span class="n">T_NetcdfTypes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">engine</span><span class="p">:</span> <span class="n">T_NetcdfEngine</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unlimited_dims</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">compute</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">invalid_netcdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Delayed</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

    <span class="k">def</span> <span class="nf">to_netcdf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">PathLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">NetcdfWriteModes</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="nb">format</span><span class="p">:</span> <span class="n">T_NetcdfTypes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">engine</span><span class="p">:</span> <span class="n">T_NetcdfEngine</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unlimited_dims</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">compute</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">invalid_netcdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="n">Delayed</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write dataset contents to a netCDF file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str, path-like or file-like, optional</span>
<span class="sd">            Path to which to save this dataset. File-like objects are only</span>
<span class="sd">            supported by the scipy engine. If no path is provided, this</span>
<span class="sd">            function returns the resulting netCDF file as bytes; in this case,</span>
<span class="sd">            we need to use scipy, which does not support netCDF version 4 (the</span>
<span class="sd">            default format becomes NETCDF3_64BIT).</span>
<span class="sd">        mode : {&quot;w&quot;, &quot;a&quot;}, default: &quot;w&quot;</span>
<span class="sd">            Write (&#39;w&#39;) or append (&#39;a&#39;) mode. If mode=&#39;w&#39;, any existing file at</span>
<span class="sd">            this location will be overwritten. If mode=&#39;a&#39;, existing variables</span>
<span class="sd">            will be overwritten.</span>
<span class="sd">        format : {&quot;NETCDF4&quot;, &quot;NETCDF4_CLASSIC&quot;, &quot;NETCDF3_64BIT&quot;, \</span>
<span class="sd">                  &quot;NETCDF3_CLASSIC&quot;}, optional</span>
<span class="sd">            File format for the resulting netCDF file:</span>

<span class="sd">            * NETCDF4: Data is stored in an HDF5 file, using netCDF4 API</span>
<span class="sd">              features.</span>
<span class="sd">            * NETCDF4_CLASSIC: Data is stored in an HDF5 file, using only</span>
<span class="sd">              netCDF 3 compatible API features.</span>
<span class="sd">            * NETCDF3_64BIT: 64-bit offset version of the netCDF 3 file format,</span>
<span class="sd">              which fully supports 2+ GB files, but is only compatible with</span>
<span class="sd">              clients linked against netCDF version 3.6.0 or later.</span>
<span class="sd">            * NETCDF3_CLASSIC: The classic netCDF 3 file format. It does not</span>
<span class="sd">              handle 2+ GB files very well.</span>

<span class="sd">            All formats are supported by the netCDF4-python library.</span>
<span class="sd">            scipy.io.netcdf only supports the last two formats.</span>

<span class="sd">            The default format is NETCDF4 if you are saving a file to disk and</span>
<span class="sd">            have the netCDF4-python library available. Otherwise, xarray falls</span>
<span class="sd">            back to using scipy to write netCDF files and defaults to the</span>
<span class="sd">            NETCDF3_64BIT format (scipy does not support netCDF4).</span>
<span class="sd">        group : str, optional</span>
<span class="sd">            Path to the netCDF4 group in the given file to open (only works for</span>
<span class="sd">            format=&#39;NETCDF4&#39;). The group(s) will be created if necessary.</span>
<span class="sd">        engine : {&quot;netcdf4&quot;, &quot;scipy&quot;, &quot;h5netcdf&quot;}, optional</span>
<span class="sd">            Engine to use when writing netCDF files. If not provided, the</span>
<span class="sd">            default engine is chosen based on available dependencies, with a</span>
<span class="sd">            preference for &#39;netcdf4&#39; if writing to a file on disk.</span>
<span class="sd">        encoding : dict, optional</span>
<span class="sd">            Nested dictionary with variable names as keys and dictionaries of</span>
<span class="sd">            variable specific encodings as values, e.g.,</span>
<span class="sd">            ``{&quot;my_variable&quot;: {&quot;dtype&quot;: &quot;int16&quot;, &quot;scale_factor&quot;: 0.1,</span>
<span class="sd">            &quot;zlib&quot;: True}, ...}``.</span>
<span class="sd">            If ``encoding`` is specified the original encoding of the variables of</span>
<span class="sd">            the dataset is ignored.</span>

<span class="sd">            The `h5netcdf` engine supports both the NetCDF4-style compression</span>
<span class="sd">            encoding parameters ``{&quot;zlib&quot;: True, &quot;complevel&quot;: 9}`` and the h5py</span>
<span class="sd">            ones ``{&quot;compression&quot;: &quot;gzip&quot;, &quot;compression_opts&quot;: 9}``.</span>
<span class="sd">            This allows using any compression plugin installed in the HDF5</span>
<span class="sd">            library, e.g. LZF.</span>

<span class="sd">        unlimited_dims : iterable of hashable, optional</span>
<span class="sd">            Dimension(s) that should be serialized as unlimited dimensions.</span>
<span class="sd">            By default, no dimensions are treated as unlimited dimensions.</span>
<span class="sd">            Note that unlimited_dims may also be set via</span>
<span class="sd">            ``dataset.encoding[&quot;unlimited_dims&quot;]``.</span>
<span class="sd">        compute: bool, default: True</span>
<span class="sd">            If true compute immediately, otherwise return a</span>
<span class="sd">            ``dask.delayed.Delayed`` object that can be computed later.</span>
<span class="sd">        invalid_netcdf: bool, default: False</span>
<span class="sd">            Only valid along with ``engine=&quot;h5netcdf&quot;``. If True, allow writing</span>
<span class="sd">            hdf5 files which are invalid netcdf as described in</span>
<span class="sd">            https://github.com/h5netcdf/h5netcdf.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            * ``bytes`` if path is None</span>
<span class="sd">            * ``dask.delayed.Delayed`` if compute is False</span>
<span class="sd">            * None otherwise</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.to_netcdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="kn">from</span> <span class="nn">xarray.backends.api</span> <span class="kn">import</span> <span class="n">to_netcdf</span>

        <span class="k">return</span> <span class="n">to_netcdf</span><span class="p">(</span>  <span class="c1"># type: ignore[return-value]  # mypy cannot resolve the overloads:(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">path</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span>
            <span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">,</span>
            <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">unlimited_dims</span><span class="o">=</span><span class="n">unlimited_dims</span><span class="p">,</span>
            <span class="n">compute</span><span class="o">=</span><span class="n">compute</span><span class="p">,</span>
            <span class="n">multifile</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">invalid_netcdf</span><span class="o">=</span><span class="n">invalid_netcdf</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># compute=True (default) returns ZarrStore</span>
    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_zarr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">store</span><span class="p">:</span> <span class="n">MutableMapping</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">PathLike</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunk_store</span><span class="p">:</span> <span class="n">MutableMapping</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">PathLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">ZarrWriteModes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">synchronizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="n">Mapping</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">compute</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">consolidated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">append_dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">region</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">slice</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">]]</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">safe_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">zarr_version</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">write_empty_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunkmanager_store_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ZarrStore</span><span class="p">:</span> <span class="o">...</span>

    <span class="c1"># compute=False returns dask.Delayed</span>
    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_zarr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">store</span><span class="p">:</span> <span class="n">MutableMapping</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">PathLike</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunk_store</span><span class="p">:</span> <span class="n">MutableMapping</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">PathLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">ZarrWriteModes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">synchronizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="n">Mapping</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">compute</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">],</span>
        <span class="n">consolidated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">append_dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">region</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">slice</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">]]</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">safe_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">zarr_version</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">write_empty_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunkmanager_store_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Delayed</span><span class="p">:</span> <span class="o">...</span>

    <span class="k">def</span> <span class="nf">to_zarr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">store</span><span class="p">:</span> <span class="n">MutableMapping</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">PathLike</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunk_store</span><span class="p">:</span> <span class="n">MutableMapping</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">PathLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">ZarrWriteModes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">synchronizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="n">Mapping</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">compute</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">consolidated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">append_dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">region</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">slice</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">]]</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">safe_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">zarr_version</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">write_empty_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunkmanager_store_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ZarrStore</span> <span class="o">|</span> <span class="n">Delayed</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write dataset contents to a zarr group.</span>

<span class="sd">        Zarr chunks are determined in the following way:</span>

<span class="sd">        - From the ``chunks`` attribute in each variable&#39;s ``encoding``</span>
<span class="sd">          (can be set via `Dataset.chunk`).</span>
<span class="sd">        - If the variable is a Dask array, from the dask chunks</span>
<span class="sd">        - If neither Dask chunks nor encoding chunks are present, chunks will</span>
<span class="sd">          be determined automatically by Zarr</span>
<span class="sd">        - If both Dask chunks and encoding chunks are present, encoding chunks</span>
<span class="sd">          will be used, provided that there is a many-to-one relationship between</span>
<span class="sd">          encoding chunks and dask chunks (i.e. Dask chunks are bigger than and</span>
<span class="sd">          evenly divide encoding chunks); otherwise raise a ``ValueError``.</span>
<span class="sd">          This restriction ensures that no synchronization / locks are required</span>
<span class="sd">          when writing. To disable this restriction, use ``safe_chunks=False``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        store : MutableMapping, str or path-like, optional</span>
<span class="sd">            Store or path to directory in local or remote file system.</span>
<span class="sd">        chunk_store : MutableMapping, str or path-like, optional</span>
<span class="sd">            Store or path to directory in local or remote file system only for Zarr</span>
<span class="sd">            array chunks. Requires zarr-python v2.4.0 or later.</span>
<span class="sd">        mode : {&quot;w&quot;, &quot;w-&quot;, &quot;a&quot;, &quot;a-&quot;, r+&quot;, None}, optional</span>
<span class="sd">            Persistence mode: &quot;w&quot; means create (overwrite if exists);</span>
<span class="sd">            &quot;w-&quot; means create (fail if exists);</span>
<span class="sd">            &quot;a&quot; means override all existing variables including dimension coordinates (create if does not exist);</span>
<span class="sd">            &quot;a-&quot; means only append those variables that have ``append_dim``.</span>
<span class="sd">            &quot;r+&quot; means modify existing array *values* only (raise an error if</span>
<span class="sd">            any metadata or shapes would change).</span>
<span class="sd">            The default mode is &quot;a&quot; if ``append_dim`` is set. Otherwise, it is</span>
<span class="sd">            &quot;r+&quot; if ``region`` is set and ``w-`` otherwise.</span>
<span class="sd">        synchronizer : object, optional</span>
<span class="sd">            Zarr array synchronizer.</span>
<span class="sd">        group : str, optional</span>
<span class="sd">            Group path. (a.k.a. `path` in zarr terminology.)</span>
<span class="sd">        encoding : dict, optional</span>
<span class="sd">            Nested dictionary with variable names as keys and dictionaries of</span>
<span class="sd">            variable specific encodings as values, e.g.,</span>
<span class="sd">            ``{&quot;my_variable&quot;: {&quot;dtype&quot;: &quot;int16&quot;, &quot;scale_factor&quot;: 0.1,}, ...}``</span>
<span class="sd">        compute : bool, default: True</span>
<span class="sd">            If True write array data immediately, otherwise return a</span>
<span class="sd">            ``dask.delayed.Delayed`` object that can be computed to write</span>
<span class="sd">            array data later. Metadata is always updated eagerly.</span>
<span class="sd">        consolidated : bool, optional</span>
<span class="sd">            If True, apply :func:`zarr.convenience.consolidate_metadata`</span>
<span class="sd">            after writing metadata and read existing stores with consolidated</span>
<span class="sd">            metadata; if False, do not. The default (`consolidated=None`) means</span>
<span class="sd">            write consolidated metadata and attempt to read consolidated</span>
<span class="sd">            metadata for existing stores (falling back to non-consolidated).</span>

<span class="sd">            When the experimental ``zarr_version=3``, ``consolidated`` must be</span>
<span class="sd">            either be ``None`` or ``False``.</span>
<span class="sd">        append_dim : hashable, optional</span>
<span class="sd">            If set, the dimension along which the data will be appended. All</span>
<span class="sd">            other dimensions on overridden variables must remain the same size.</span>
<span class="sd">        region : dict or &quot;auto&quot;, optional</span>
<span class="sd">            Optional mapping from dimension names to either a) ``&quot;auto&quot;``, or b) integer</span>
<span class="sd">            slices, indicating the region of existing zarr array(s) in which to write</span>
<span class="sd">            this dataset&#39;s data.</span>

<span class="sd">            If ``&quot;auto&quot;`` is provided the existing store will be opened and the region</span>
<span class="sd">            inferred by matching indexes. ``&quot;auto&quot;`` can be used as a single string,</span>
<span class="sd">            which will automatically infer the region for all dimensions, or as</span>
<span class="sd">            dictionary values for specific dimensions mixed together with explicit</span>
<span class="sd">            slices for other dimensions.</span>

<span class="sd">            Alternatively integer slices can be provided; for example, ``{&#39;x&#39;: slice(0,</span>
<span class="sd">            1000), &#39;y&#39;: slice(10000, 11000)}`` would indicate that values should be</span>
<span class="sd">            written to the region ``0:1000`` along ``x`` and ``10000:11000`` along</span>
<span class="sd">            ``y``.</span>

<span class="sd">            Two restrictions apply to the use of ``region``:</span>

<span class="sd">            - If ``region`` is set, _all_ variables in a dataset must have at</span>
<span class="sd">              least one dimension in common with the region. Other variables</span>
<span class="sd">              should be written in a separate single call to ``to_zarr()``.</span>
<span class="sd">            - Dimensions cannot be included in both ``region`` and</span>
<span class="sd">              ``append_dim`` at the same time. To create empty arrays to fill</span>
<span class="sd">              in with ``region``, use a separate call to ``to_zarr()`` with</span>
<span class="sd">              ``compute=False``. See &quot;Appending to existing Zarr stores&quot; in</span>
<span class="sd">              the reference documentation for full details.</span>

<span class="sd">            Users are expected to ensure that the specified region aligns with</span>
<span class="sd">            Zarr chunk boundaries, and that dask chunks are also aligned.</span>
<span class="sd">            Xarray makes limited checks that these multiple chunk boundaries line up.</span>
<span class="sd">            It is possible to write incomplete chunks and corrupt the data with this</span>
<span class="sd">            option if you are not careful.</span>
<span class="sd">        safe_chunks : bool, default: True</span>
<span class="sd">            If True, only allow writes to when there is a many-to-one relationship</span>
<span class="sd">            between Zarr chunks (specified in encoding) and Dask chunks.</span>
<span class="sd">            Set False to override this restriction; however, data may become corrupted</span>
<span class="sd">            if Zarr arrays are written in parallel. This option may be useful in combination</span>
<span class="sd">            with ``compute=False`` to initialize a Zarr from an existing</span>
<span class="sd">            Dataset with arbitrary chunk structure.</span>
<span class="sd">        storage_options : dict, optional</span>
<span class="sd">            Any additional parameters for the storage backend (ignored for local</span>
<span class="sd">            paths).</span>
<span class="sd">        zarr_version : int or None, optional</span>
<span class="sd">            The desired zarr spec version to target (currently 2 or 3). The</span>
<span class="sd">            default of None will attempt to determine the zarr version from</span>
<span class="sd">            ``store`` when possible, otherwise defaulting to 2.</span>
<span class="sd">        write_empty_chunks : bool or None, optional</span>
<span class="sd">            If True, all chunks will be stored regardless of their</span>
<span class="sd">            contents. If False, each chunk is compared to the array&#39;s fill value</span>
<span class="sd">            prior to storing. If a chunk is uniformly equal to the fill value, then</span>
<span class="sd">            that chunk is not be stored, and the store entry for that chunk&#39;s key</span>
<span class="sd">            is deleted. This setting enables sparser storage, as only chunks with</span>
<span class="sd">            non-fill-value data are stored, at the expense of overhead associated</span>
<span class="sd">            with checking the data of each chunk. If None (default) fall back to</span>
<span class="sd">            specification(s) in ``encoding`` or Zarr defaults. A ``ValueError``</span>
<span class="sd">            will be raised if the value of this (if not None) differs with</span>
<span class="sd">            ``encoding``.</span>
<span class="sd">        chunkmanager_store_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed on to the `ChunkManager.store` method used to store</span>
<span class="sd">            chunked arrays. For example for a dask array additional kwargs will be passed eventually to</span>
<span class="sd">            :py:func:`dask.array.store()`. Experimental API that should not be relied upon.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            * ``dask.delayed.Delayed`` if compute is False</span>
<span class="sd">            * ZarrStore otherwise</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        https://zarr.readthedocs.io/</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Zarr chunking behavior:</span>
<span class="sd">            If chunks are found in the encoding argument or attribute</span>
<span class="sd">            corresponding to any DataArray, those chunks are used.</span>
<span class="sd">            If a DataArray is a dask array, it is written with those chunks.</span>
<span class="sd">            If not other chunks are found, Zarr uses its own heuristics to</span>
<span class="sd">            choose automatic chunk sizes.</span>

<span class="sd">        encoding:</span>
<span class="sd">            The encoding attribute (if exists) of the DataArray(s) will be</span>
<span class="sd">            used. Override any existing encodings by providing the ``encoding`` kwarg.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`io.zarr`</span>
<span class="sd">            The I/O user guide, with more details and examples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.backends.api</span> <span class="kn">import</span> <span class="n">to_zarr</span>

        <span class="k">return</span> <span class="n">to_zarr</span><span class="p">(</span>  <span class="c1"># type: ignore[call-overload,misc]</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">store</span><span class="o">=</span><span class="n">store</span><span class="p">,</span>
            <span class="n">chunk_store</span><span class="o">=</span><span class="n">chunk_store</span><span class="p">,</span>
            <span class="n">storage_options</span><span class="o">=</span><span class="n">storage_options</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">synchronizer</span><span class="o">=</span><span class="n">synchronizer</span><span class="p">,</span>
            <span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">compute</span><span class="o">=</span><span class="n">compute</span><span class="p">,</span>
            <span class="n">consolidated</span><span class="o">=</span><span class="n">consolidated</span><span class="p">,</span>
            <span class="n">append_dim</span><span class="o">=</span><span class="n">append_dim</span><span class="p">,</span>
            <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span>
            <span class="n">safe_chunks</span><span class="o">=</span><span class="n">safe_chunks</span><span class="p">,</span>
            <span class="n">zarr_version</span><span class="o">=</span><span class="n">zarr_version</span><span class="p">,</span>
            <span class="n">write_empty_chunks</span><span class="o">=</span><span class="n">write_empty_chunks</span><span class="p">,</span>
            <span class="n">chunkmanager_store_kwargs</span><span class="o">=</span><span class="n">chunkmanager_store_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">formatting</span><span class="o">.</span><span class="n">dataset_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">OPTIONS</span><span class="p">[</span><span class="s2">&quot;display_style&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;text&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;pre&gt;</span><span class="si">{</span><span class="n">escape</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="si">}</span><span class="s2">&lt;/pre&gt;&quot;</span>
        <span class="k">return</span> <span class="n">formatting_html</span><span class="o">.</span><span class="n">dataset_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="n">IO</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concise summary of a Dataset variables and attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        buf : file-like, default: sys.stdout</span>
<span class="sd">            writable buffer</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.DataFrame.assign</span>
<span class="sd">        ncdump : netCDF&#39;s ncdump</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">buf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;xarray.Dataset {&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;dimensions:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2"> ;&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">variables:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{</span><span class="n">da</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">dims</span><span class="si">}</span><span class="s2">) ;&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> ;&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">// global attributes:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">:</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> ;&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;}&quot;</span><span class="p">)</span>

        <span class="n">buf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mapping from dimension names to block lengths for this dataset&#39;s data, or None if</span>
<span class="sd">        the underlying data is not a dask array.</span>
<span class="sd">        Cannot be modified directly, but can be modified by calling .chunk().</span>

<span class="sd">        Same as Dataset.chunksizes, but maintained for backwards compatibility.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.chunk</span>
<span class="sd">        Dataset.chunksizes</span>
<span class="sd">        xarray.unify_chunks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_chunksizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chunksizes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mapping from dimension names to block lengths for this dataset&#39;s data, or None if</span>
<span class="sd">        the underlying data is not a dask array.</span>
<span class="sd">        Cannot be modified directly, but can be modified by calling .chunk().</span>

<span class="sd">        Same as Dataset.chunks.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.chunk</span>
<span class="sd">        Dataset.chunks</span>
<span class="sd">        xarray.unify_chunks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_chunksizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">chunk</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chunks</span><span class="p">:</span> <span class="n">T_ChunksFreq</span> <span class="o">=</span> <span class="p">{},</span>  <span class="c1"># {} even though it&#39;s technically unsafe, is being used intentionally here (#4667)</span>
        <span class="n">name_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xarray-&quot;</span><span class="p">,</span>
        <span class="n">token</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lock</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">inline_array</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">chunked_array_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">ChunkManagerEntrypoint</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">from_array_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">chunks_kwargs</span><span class="p">:</span> <span class="n">T_ChunkDimFreq</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Coerce all arrays in this dataset into dask arrays with the given</span>
<span class="sd">        chunks.</span>

<span class="sd">        Non-dask arrays in this dataset will be converted to dask arrays. Dask</span>
<span class="sd">        arrays will be rechunked to the given chunk sizes.</span>

<span class="sd">        If neither chunks is not provided for one or more dimensions, chunk</span>
<span class="sd">        sizes along that dimension will not be updated; non-dask arrays will be</span>
<span class="sd">        converted into dask arrays with a single block.</span>

<span class="sd">        Along datetime-like dimensions, a :py:class:`groupers.TimeResampler` object is also accepted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chunks : int, tuple of int, &quot;auto&quot; or mapping of hashable to int or a TimeResampler, optional</span>
<span class="sd">            Chunk sizes along each dimension, e.g., ``5``, ``&quot;auto&quot;``, or</span>
<span class="sd">            ``{&quot;x&quot;: 5, &quot;y&quot;: 5}`` or ``{&quot;x&quot;: 5, &quot;time&quot;: TimeResampler(freq=&quot;YE&quot;)}``.</span>
<span class="sd">        name_prefix : str, default: &quot;xarray-&quot;</span>
<span class="sd">            Prefix for the name of any new dask arrays.</span>
<span class="sd">        token : str, optional</span>
<span class="sd">            Token uniquely identifying this dataset.</span>
<span class="sd">        lock : bool, default: False</span>
<span class="sd">            Passed on to :py:func:`dask.array.from_array`, if the array is not</span>
<span class="sd">            already as dask array.</span>
<span class="sd">        inline_array: bool, default: False</span>
<span class="sd">            Passed on to :py:func:`dask.array.from_array`, if the array is not</span>
<span class="sd">            already as dask array.</span>
<span class="sd">        chunked_array_type: str, optional</span>
<span class="sd">            Which chunked array type to coerce this datasets&#39; arrays to.</span>
<span class="sd">            Defaults to &#39;dask&#39; if installed, else whatever is registered via the `ChunkManagerEntryPoint` system.</span>
<span class="sd">            Experimental API that should not be relied upon.</span>
<span class="sd">        from_array_kwargs: dict, optional</span>
<span class="sd">            Additional keyword arguments passed on to the `ChunkManagerEntrypoint.from_array` method used to create</span>
<span class="sd">            chunked arrays, via whichever chunk manager is specified through the `chunked_array_type` kwarg.</span>
<span class="sd">            For example, with dask as the default chunked array type, this method would pass additional kwargs</span>
<span class="sd">            to :py:func:`dask.array.from_array`. Experimental API that should not be relied upon.</span>
<span class="sd">        **chunks_kwargs : {dim: chunks, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``chunks``.</span>
<span class="sd">            One of chunks or chunks_kwargs must be provided</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        chunked : xarray.Dataset</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.chunks</span>
<span class="sd">        Dataset.chunksizes</span>
<span class="sd">        xarray.unify_chunks</span>
<span class="sd">        dask.array.from_array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>
        <span class="kn">from</span> <span class="nn">xarray.groupers</span> <span class="kn">import</span> <span class="n">TimeResampler</span>

        <span class="k">if</span> <span class="n">chunks</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">chunks_kwargs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;None value for &#39;chunks&#39; is deprecated. &quot;</span>
                <span class="s2">&quot;It will raise an error in the future. Use instead &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">chunks_mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">)</span> <span class="ow">and</span> <span class="n">chunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">utils</span><span class="o">.</span><span class="n">emit_user_level_warning</span><span class="p">(</span>
                    <span class="s2">&quot;Supplying chunks as dimension-order tuples is deprecated. &quot;</span>
                    <span class="s2">&quot;It will raise an error in the future. Instead use a dict with dimensions as keys.&quot;</span><span class="p">,</span>
                    <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">chunks_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chunks_mapping</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">chunks_kwargs</span><span class="p">,</span> <span class="s2">&quot;chunk&quot;</span><span class="p">)</span>

        <span class="n">bad_dims</span> <span class="o">=</span> <span class="n">chunks_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">bad_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;chunks keys </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">bad_dims</span><span class="p">)</span><span class="si">}</span><span class="s2"> not found in data dimensions </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">_resolve_frequency</span><span class="p">(</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">resampler</span><span class="p">:</span> <span class="n">TimeResampler</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot chunk by resampler </span><span class="si">{</span><span class="n">resampler</span><span class="si">!r}</span><span class="s2"> for virtual variables.&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">_contains_datetime_like_objects</span><span class="p">(</span><span class="n">variable</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;chunks=</span><span class="si">{</span><span class="n">resampler</span><span class="si">!r}</span><span class="s2"> only supported for datetime variables. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Received variable </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> with dtype </span><span class="si">{</span><span class="n">variable</span><span class="o">.</span><span class="n">dtype</span><span class="si">!r}</span><span class="s2"> instead.&quot;</span>
                <span class="p">)</span>

            <span class="k">assert</span> <span class="n">variable</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">DataArray</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
                    <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">name</span><span class="p">,),</span>
                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">variable</span><span class="p">},</span>
                <span class="p">)</span>
                <span class="o">.</span><span class="n">resample</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">resampler</span><span class="p">})</span>
                <span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="c1"># When bins (binning) or time periods are missing (resampling)</span>
            <span class="c1"># we can end up with NaNs. Drop them.</span>
            <span class="k">if</span> <span class="n">chunks</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span>
                <span class="n">chunks</span> <span class="o">=</span> <span class="n">chunks</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">chunks_tuple</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chunks</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">chunks_tuple</span>

        <span class="n">chunks_mapping_ints</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">T_ChunkDim</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">_resolve_frequency</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">TimeResampler</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">chunks</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">chunks</span> <span class="ow">in</span> <span class="n">chunks_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="n">chunkmanager</span> <span class="o">=</span> <span class="n">guess_chunkmanager</span><span class="p">(</span><span class="n">chunked_array_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">from_array_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">from_array_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">_maybe_chunk</span><span class="p">(</span>
                <span class="n">k</span><span class="p">,</span>
                <span class="n">v</span><span class="p">,</span>
                <span class="n">chunks_mapping_ints</span><span class="p">,</span>
                <span class="n">token</span><span class="p">,</span>
                <span class="n">lock</span><span class="p">,</span>
                <span class="n">name_prefix</span><span class="p">,</span>
                <span class="n">inline_array</span><span class="o">=</span><span class="n">inline_array</span><span class="p">,</span>
                <span class="n">chunked_array_type</span><span class="o">=</span><span class="n">chunkmanager</span><span class="p">,</span>
                <span class="n">from_array_kwargs</span><span class="o">=</span><span class="n">from_array_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_indexers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">missing_dims</span><span class="p">:</span> <span class="n">ErrorOptionsWithWarn</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">slice</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Variable</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Here we make sure</span>
<span class="sd">        + indexer has a valid keys</span>
<span class="sd">        + indexer is in a valid data type</span>
<span class="sd">        + string indexers are cast to the appropriate date type if the</span>
<span class="sd">          associated index is a DatetimeIndex or CFTimeIndex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.coding.cftimeindex</span> <span class="kn">import</span> <span class="n">CFTimeIndex</span>
        <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="n">indexers</span> <span class="o">=</span> <span class="n">drop_dims_from_indexers</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">missing_dims</span><span class="p">)</span>

        <span class="c1"># all indexers should be int, slice, np.ndarrays, or Variable</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">slice</span> <span class="o">|</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">variable</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">as_variable</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot use a Dataset as an indexer&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_duck_array</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;US&quot;</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">to_pandas_index</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">duck_array_ops</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">CFTimeIndex</span><span class="p">):</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">_parse_array_of_cftime_strings</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">date_type</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                        <span class="s2">&quot;Unlabeled multi-dimensional array cannot be &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;used for indexing: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">_validate_interp_indexers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Variant of _validate_indexers to be used for interpolation&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexers</span><span class="p">(</span><span class="n">indexers</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">to_index_variable</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">Variable</span><span class="p">((),</span> <span class="n">v</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">Variable</span><span class="p">((),</span> <span class="n">v</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">IndexVariable</span><span class="p">((</span><span class="n">k</span><span class="p">,),</span> <span class="n">v</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>  <span class="c1"># Already tested by _validate_indexers</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_indexers_coords_and_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexers</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract coordinates and indexes from indexers.</span>

<span class="sd">        Only coordinate with a name different from any of self.variables will</span>
<span class="sd">        be attached.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="n">coords_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># we only support 1-d boolean array</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">ndim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">d-boolean array is used for indexing along &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;dimension </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, but only 1d boolean arrays are &quot;</span>
                            <span class="s2">&quot;supported.&quot;</span>
                        <span class="p">)</span>
                    <span class="c1"># Make sure in case of boolean DataArray, its</span>
                    <span class="c1"># coordinate also should be indexed.</span>
                    <span class="n">v_coords</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">coords</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v_coords</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">coords</span>
                <span class="n">coords_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_coords</span><span class="p">)</span>

        <span class="c1"># we don&#39;t need to call align() explicitly or check indexes for</span>
        <span class="c1"># alignment, because merge_variables already checks for exact alignment</span>
        <span class="c1"># between dimension coordinates</span>
        <span class="n">coords</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="n">merge_coordinates_without_align</span><span class="p">(</span><span class="n">coords_list</span><span class="p">)</span>
        <span class="n">assert_coordinate_consistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>

        <span class="c1"># silently drop the conflicted variables.</span>
        <span class="n">attached_coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">}</span>
        <span class="n">attached_indexes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">attached_coords</span><span class="p">,</span> <span class="n">attached_indexes</span>

    <span class="k">def</span> <span class="nf">isel</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">missing_dims</span><span class="p">:</span> <span class="n">ErrorOptionsWithWarn</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new dataset with each array indexed along the specified</span>
<span class="sd">        dimension(s).</span>

<span class="sd">        This method selects values from each array using its `__getitem__`</span>
<span class="sd">        method, except this method does not require knowing the order of</span>
<span class="sd">        each array&#39;s dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexers : dict, optional</span>
<span class="sd">            A dict with keys matching dimensions and values given</span>
<span class="sd">            by integers, slice objects or arrays.</span>
<span class="sd">            indexer can be a integer, slice, array-like or DataArray.</span>
<span class="sd">            If DataArrays are passed as indexers, xarray-style indexing will be</span>
<span class="sd">            carried out. See :ref:`indexing` for the details.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>
<span class="sd">        drop : bool, default: False</span>
<span class="sd">            If ``drop=True``, drop coordinates variables indexed by integers</span>
<span class="sd">            instead of making them scalar.</span>
<span class="sd">        missing_dims : {&quot;raise&quot;, &quot;warn&quot;, &quot;ignore&quot;}, default: &quot;raise&quot;</span>
<span class="sd">            What to do if dimensions that should be selected from are not present in the</span>
<span class="sd">            Dataset:</span>
<span class="sd">            - &quot;raise&quot;: raise an exception</span>
<span class="sd">            - &quot;warn&quot;: raise a warning, and ignore the missing dimensions</span>
<span class="sd">            - &quot;ignore&quot;: ignore the missing dimensions</span>

<span class="sd">        **indexers_kwargs : {dim: indexer, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``indexers``.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>
<span class="sd">            A new Dataset with the same contents as this dataset, except each</span>
<span class="sd">            array and dimension is indexed by the appropriate indexers.</span>
<span class="sd">            If indexer DataArrays have coordinates that do not conflict with</span>
<span class="sd">            this object, then these coordinates will be attached.</span>
<span class="sd">            In general, each array&#39;s data will be a view of the array&#39;s data</span>
<span class="sd">            in this dataset, unless vectorized indexing was triggered by using</span>
<span class="sd">            an array indexer, in which case the data will be a copy.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; dataset = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;math_scores&quot;: (</span>
<span class="sd">        ...             [&quot;student&quot;, &quot;test&quot;],</span>
<span class="sd">        ...             [[90, 85, 92], [78, 80, 85], [95, 92, 98]],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...         &quot;english_scores&quot;: (</span>
<span class="sd">        ...             [&quot;student&quot;, &quot;test&quot;],</span>
<span class="sd">        ...             [[88, 90, 92], [75, 82, 79], [93, 96, 91]],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={</span>
<span class="sd">        ...         &quot;student&quot;: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;],</span>
<span class="sd">        ...         &quot;test&quot;: [&quot;Test 1&quot;, &quot;Test 2&quot;, &quot;Test 3&quot;],</span>
<span class="sd">        ...     },</span>
<span class="sd">        ... )</span>

<span class="sd">        # A specific element from the dataset is selected</span>

<span class="sd">        &gt;&gt;&gt; dataset.isel(student=1, test=0)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 68B</span>
<span class="sd">        Dimensions:         ()</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            student         &lt;U7 28B &#39;Bob&#39;</span>
<span class="sd">            test            &lt;U6 24B &#39;Test 1&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            math_scores     int64 8B 78</span>
<span class="sd">            english_scores  int64 8B 75</span>

<span class="sd">        # Indexing with a slice using isel</span>

<span class="sd">        &gt;&gt;&gt; slice_of_data = dataset.isel(student=slice(0, 2), test=slice(0, 2))</span>
<span class="sd">        &gt;&gt;&gt; slice_of_data</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 168B</span>
<span class="sd">        Dimensions:         (student: 2, test: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * student         (student) &lt;U7 56B &#39;Alice&#39; &#39;Bob&#39;</span>
<span class="sd">          * test            (test) &lt;U6 48B &#39;Test 1&#39; &#39;Test 2&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            math_scores     (student, test) int64 32B 90 85 78 80</span>
<span class="sd">            english_scores  (student, test) int64 32B 88 90 75 82</span>

<span class="sd">        &gt;&gt;&gt; index_array = xr.DataArray([0, 2], dims=&quot;student&quot;)</span>
<span class="sd">        &gt;&gt;&gt; indexed_data = dataset.isel(student=index_array)</span>
<span class="sd">        &gt;&gt;&gt; indexed_data</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 224B</span>
<span class="sd">        Dimensions:         (student: 2, test: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * student         (student) &lt;U7 56B &#39;Alice&#39; &#39;Charlie&#39;</span>
<span class="sd">          * test            (test) &lt;U6 72B &#39;Test 1&#39; &#39;Test 2&#39; &#39;Test 3&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            math_scores     (student, test) int64 48B 90 85 92 95 92 98</span>
<span class="sd">            english_scores  (student, test) int64 48B 88 90 92 93 96 91</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.sel</span>
<span class="sd">        DataArray.isel</span>

<span class="sd">        :doc:`xarray-tutorial:intermediate/indexing/indexing`</span>
<span class="sd">            Tutorial material on indexing with Xarray objects</span>

<span class="sd">        :doc:`xarray-tutorial:fundamentals/02.1_indexing_Basic`</span>
<span class="sd">            Tutorial material on basics of indexing</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;isel&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_fancy_indexer</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isel_fancy</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="n">drop</span><span class="p">,</span> <span class="n">missing_dims</span><span class="o">=</span><span class="n">missing_dims</span><span class="p">)</span>

        <span class="c1"># Much faster algorithm for when all indexers are ints, slices, one-dimensional</span>
        <span class="c1"># lists, or zero or one-dimensional np.ndarray&#39;s</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">drop_dims_from_indexers</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">missing_dims</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">indexes</span><span class="p">,</span> <span class="n">index_variables</span> <span class="o">=</span> <span class="n">isel_indexes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">,</span> <span class="n">indexers</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># preserve variable order</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">index_variables</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">index_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var_indexers</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
                <span class="k">if</span> <span class="n">var_indexers</span><span class="p">:</span>
                    <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">var_indexers</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">drop</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">coord_names</span><span class="p">:</span>
                        <span class="n">coord_names</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                        <span class="k">continue</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
            <span class="n">dims</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_direct</span><span class="p">(</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">,</span>
            <span class="n">close</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_close</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_isel_fancy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">missing_dims</span><span class="p">:</span> <span class="n">ErrorOptionsWithWarn</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="n">valid_indexers</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexers</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">missing_dims</span><span class="p">))</span>

        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">indexes</span><span class="p">,</span> <span class="n">index_variables</span> <span class="o">=</span> <span class="n">isel_indexes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">,</span> <span class="n">valid_indexers</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">index_variables</span><span class="p">:</span>
                <span class="n">new_var</span> <span class="o">=</span> <span class="n">index_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var_indexers</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">valid_indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="n">var_indexers</span><span class="p">:</span>
                    <span class="n">new_var</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indexers</span><span class="o">=</span><span class="n">var_indexers</span><span class="p">)</span>
                    <span class="c1"># drop scalar coordinates</span>
                    <span class="c1"># https://github.com/pydata/xarray/issues/6554</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="ow">and</span> <span class="n">drop</span> <span class="ow">and</span> <span class="n">new_var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_var</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                    <span class="n">new_var</span> <span class="o">=</span> <span class="n">new_var</span><span class="o">.</span><span class="n">to_base_variable</span><span class="p">()</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_var</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">&amp;</span> <span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span>

        <span class="c1"># Extract coordinates from indexers</span>
        <span class="n">coord_vars</span><span class="p">,</span> <span class="n">new_indexes</span> <span class="o">=</span> <span class="n">selected</span><span class="o">.</span><span class="n">_get_indexers_coords_and_indexes</span><span class="p">(</span><span class="n">indexers</span><span class="p">)</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">coord_vars</span><span class="p">)</span>
        <span class="n">indexes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_indexes</span><span class="p">)</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">&amp;</span> <span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">|</span> <span class="n">coord_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sel</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new dataset with each array indexed by tick labels</span>
<span class="sd">        along the specified dimension(s).</span>

<span class="sd">        In contrast to `Dataset.isel`, indexers for this method should use</span>
<span class="sd">        labels instead of integers.</span>

<span class="sd">        Under the hood, this method is powered by using pandas&#39;s powerful Index</span>
<span class="sd">        objects. This makes label based indexing essentially just as fast as</span>
<span class="sd">        using integer indexing.</span>

<span class="sd">        It also means this method uses pandas&#39;s (well documented) logic for</span>
<span class="sd">        indexing. This means you can use string shortcuts for datetime indexes</span>
<span class="sd">        (e.g., &#39;2000-01&#39; to select all values in January 2000). It also means</span>
<span class="sd">        that slices are treated as inclusive of both the start and stop values,</span>
<span class="sd">        unlike normal Python indexing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexers : dict, optional</span>
<span class="sd">            A dict with keys matching dimensions and values given</span>
<span class="sd">            by scalars, slices or arrays of tick labels. For dimensions with</span>
<span class="sd">            multi-index, the indexer may also be a dict-like object with keys</span>
<span class="sd">            matching index level names.</span>
<span class="sd">            If DataArrays are passed as indexers, xarray-style indexing will be</span>
<span class="sd">            carried out. See :ref:`indexing` for the details.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>
<span class="sd">        method : {None, &quot;nearest&quot;, &quot;pad&quot;, &quot;ffill&quot;, &quot;backfill&quot;, &quot;bfill&quot;}, optional</span>
<span class="sd">            Method to use for inexact matches:</span>

<span class="sd">            * None (default): only exact matches</span>
<span class="sd">            * pad / ffill: propagate last valid index value forward</span>
<span class="sd">            * backfill / bfill: propagate next valid index value backward</span>
<span class="sd">            * nearest: use nearest valid index value</span>
<span class="sd">        tolerance : optional</span>
<span class="sd">            Maximum distance between original and new labels for inexact</span>
<span class="sd">            matches. The values of the index at the matching locations must</span>
<span class="sd">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>
<span class="sd">        drop : bool, optional</span>
<span class="sd">            If ``drop=True``, drop coordinates variables in `indexers` instead</span>
<span class="sd">            of making them scalar.</span>
<span class="sd">        **indexers_kwargs : {dim: indexer, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``indexers``.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>
<span class="sd">            A new Dataset with the same contents as this dataset, except each</span>
<span class="sd">            variable and dimension is indexed by the appropriate indexers.</span>
<span class="sd">            If indexer DataArrays have coordinates that do not conflict with</span>
<span class="sd">            this object, then these coordinates will be attached.</span>
<span class="sd">            In general, each array&#39;s data will be a view of the array&#39;s data</span>
<span class="sd">            in this dataset, unless vectorized indexing was triggered by using</span>
<span class="sd">            an array indexer, in which case the data will be a copy.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.isel</span>
<span class="sd">        DataArray.sel</span>

<span class="sd">        :doc:`xarray-tutorial:intermediate/indexing/indexing`</span>
<span class="sd">            Tutorial material on indexing with Xarray objects</span>

<span class="sd">        :doc:`xarray-tutorial:fundamentals/02.1_indexing_Basic`</span>
<span class="sd">            Tutorial material on basics of indexing</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;sel&quot;</span><span class="p">)</span>
        <span class="n">query_results</span> <span class="o">=</span> <span class="n">map_index_queries</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">indexers</span><span class="o">=</span><span class="n">indexers</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">drop</span><span class="p">:</span>
            <span class="n">no_scalar_variables</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">query_results</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">no_scalar_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">:</span>
                        <span class="n">query_results</span><span class="o">.</span><span class="n">drop_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">query_results</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">no_scalar_variables</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indexers</span><span class="o">=</span><span class="n">query_results</span><span class="o">.</span><span class="n">dim_indexers</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="n">drop</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">_overwrite_indexes</span><span class="p">(</span><span class="o">*</span><span class="n">query_results</span><span class="o">.</span><span class="n">as_tuple</span><span class="p">()[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">head</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new dataset with the first `n` values of each array</span>
<span class="sd">        for the specified dimension(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexers : dict or int, default: 5</span>
<span class="sd">            A dict with keys matching dimensions and integer values `n`</span>
<span class="sd">            or a single integer `n` applied over all dimensions.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>
<span class="sd">        **indexers_kwargs : {dim: n, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``indexers``.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; dates = pd.date_range(start=&quot;2023-01-01&quot;, periods=5)</span>
<span class="sd">        &gt;&gt;&gt; pageviews = [1200, 1500, 900, 1800, 2000]</span>
<span class="sd">        &gt;&gt;&gt; visitors = [800, 1000, 600, 1200, 1500]</span>
<span class="sd">        &gt;&gt;&gt; dataset = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;pageviews&quot;: ((&quot;date&quot;), pageviews),</span>
<span class="sd">        ...         &quot;visitors&quot;: ((&quot;date&quot;), visitors),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;date&quot;: dates},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; busiest_days = dataset.sortby(&quot;pageviews&quot;, ascending=False)</span>
<span class="sd">        &gt;&gt;&gt; busiest_days.head()</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 120B</span>
<span class="sd">        Dimensions:    (date: 5)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * date       (date) datetime64[ns] 40B 2023-01-05 2023-01-04 ... 2023-01-03</span>
<span class="sd">        Data variables:</span>
<span class="sd">            pageviews  (date) int64 40B 2000 1800 1500 1200 900</span>
<span class="sd">            visitors   (date) int64 40B 1500 1200 1000 800 600</span>

<span class="sd">        # Retrieve the 3 most busiest days in terms of pageviews</span>

<span class="sd">        &gt;&gt;&gt; busiest_days.head(3)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 72B</span>
<span class="sd">        Dimensions:    (date: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * date       (date) datetime64[ns] 24B 2023-01-05 2023-01-04 2023-01-02</span>
<span class="sd">        Data variables:</span>
<span class="sd">            pageviews  (date) int64 24B 2000 1800 1500</span>
<span class="sd">            visitors   (date) int64 24B 1500 1200 1000</span>

<span class="sd">        # Using a dictionary to specify the number of elements for specific dimensions</span>

<span class="sd">        &gt;&gt;&gt; busiest_days.head({&quot;date&quot;: 3})</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 72B</span>
<span class="sd">        Dimensions:    (date: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * date       (date) datetime64[ns] 24B 2023-01-05 2023-01-04 2023-01-02</span>
<span class="sd">        Data variables:</span>
<span class="sd">            pageviews  (date) int64 24B 2000 1800 1500</span>
<span class="sd">            visitors   (date) int64 24B 1500 1200 1000</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.tail</span>
<span class="sd">        Dataset.thin</span>
<span class="sd">        DataArray.head</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">indexers_kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">indexers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indexers</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">indexers</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;indexers must be either dict-like or a single integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">indexers</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="n">indexers</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;head&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;expected integer type indexer for &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dimension </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, found </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;expected positive integer as indexer &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for dimension </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, found </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="n">indexers_slices</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indexers_slices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tail</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new dataset with the last `n` values of each array</span>
<span class="sd">        for the specified dimension(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexers : dict or int, default: 5</span>
<span class="sd">            A dict with keys matching dimensions and integer values `n`</span>
<span class="sd">            or a single integer `n` applied over all dimensions.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>
<span class="sd">        **indexers_kwargs : {dim: n, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``indexers``.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; activity_names = [&quot;Walking&quot;, &quot;Running&quot;, &quot;Cycling&quot;, &quot;Swimming&quot;, &quot;Yoga&quot;]</span>
<span class="sd">        &gt;&gt;&gt; durations = [30, 45, 60, 45, 60]  # in minutes</span>
<span class="sd">        &gt;&gt;&gt; energies = [150, 300, 250, 400, 100]  # in calories</span>
<span class="sd">        &gt;&gt;&gt; dataset = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;duration&quot;: ([&quot;activity&quot;], durations),</span>
<span class="sd">        ...         &quot;energy_expenditure&quot;: ([&quot;activity&quot;], energies),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;activity&quot;: activity_names},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; sorted_dataset = dataset.sortby(&quot;energy_expenditure&quot;, ascending=False)</span>
<span class="sd">        &gt;&gt;&gt; sorted_dataset</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 240B</span>
<span class="sd">        Dimensions:             (activity: 5)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * activity            (activity) &lt;U8 160B &#39;Swimming&#39; &#39;Running&#39; ... &#39;Yoga&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            duration            (activity) int64 40B 45 45 60 30 60</span>
<span class="sd">            energy_expenditure  (activity) int64 40B 400 300 250 150 100</span>

<span class="sd">        # Activities with the least energy expenditures using tail()</span>

<span class="sd">        &gt;&gt;&gt; sorted_dataset.tail(3)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 144B</span>
<span class="sd">        Dimensions:             (activity: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * activity            (activity) &lt;U8 96B &#39;Cycling&#39; &#39;Walking&#39; &#39;Yoga&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            duration            (activity) int64 24B 60 30 60</span>
<span class="sd">            energy_expenditure  (activity) int64 24B 250 150 100</span>

<span class="sd">        &gt;&gt;&gt; sorted_dataset.tail({&quot;activity&quot;: 3})</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 144B</span>
<span class="sd">        Dimensions:             (activity: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * activity            (activity) &lt;U8 96B &#39;Cycling&#39; &#39;Walking&#39; &#39;Yoga&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            duration            (activity) int64 24B 60 30 60</span>
<span class="sd">            energy_expenditure  (activity) int64 24B 250 150 100</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.head</span>
<span class="sd">        Dataset.thin</span>
<span class="sd">        DataArray.tail</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">indexers_kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">indexers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indexers</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">indexers</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;indexers must be either dict-like or a single integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">indexers</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="n">indexers</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;tail&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;expected integer type indexer for &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dimension </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, found </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;expected positive integer as indexer &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for dimension </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, found </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="n">indexers_slices</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="n">val</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indexers_slices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">thin</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new dataset with each array indexed along every `n`-th</span>
<span class="sd">        value for the specified dimension(s)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexers : dict or int</span>
<span class="sd">            A dict with keys matching dimensions and integer values `n`</span>
<span class="sd">            or a single integer `n` applied over all dimensions.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>
<span class="sd">        **indexers_kwargs : {dim: n, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``indexers``.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x_arr = np.arange(0, 26)</span>
<span class="sd">        &gt;&gt;&gt; x_arr</span>
<span class="sd">        array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,</span>
<span class="sd">               17, 18, 19, 20, 21, 22, 23, 24, 25])</span>
<span class="sd">        &gt;&gt;&gt; x = xr.DataArray(</span>
<span class="sd">        ...     np.reshape(x_arr, (2, 13)),</span>
<span class="sd">        ...     dims=(&quot;x&quot;, &quot;y&quot;),</span>
<span class="sd">        ...     coords={&quot;x&quot;: [0, 1], &quot;y&quot;: np.arange(0, 13)},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; x_ds = xr.Dataset({&quot;foo&quot;: x})</span>
<span class="sd">        &gt;&gt;&gt; x_ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 328B</span>
<span class="sd">        Dimensions:  (x: 2, y: 13)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 16B 0 1</span>
<span class="sd">          * y        (y) int64 104B 0 1 2 3 4 5 6 7 8 9 10 11 12</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (x, y) int64 208B 0 1 2 3 4 5 6 7 8 ... 17 18 19 20 21 22 23 24 25</span>

<span class="sd">        &gt;&gt;&gt; x_ds.thin(3)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 88B</span>
<span class="sd">        Dimensions:  (x: 1, y: 5)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 8B 0</span>
<span class="sd">          * y        (y) int64 40B 0 3 6 9 12</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (x, y) int64 40B 0 3 6 9 12</span>
<span class="sd">        &gt;&gt;&gt; x.thin({&quot;x&quot;: 2, &quot;y&quot;: 5})</span>
<span class="sd">        &lt;xarray.DataArray (x: 1, y: 3)&gt; Size: 24B</span>
<span class="sd">        array([[ 0,  5, 10]])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 8B 0</span>
<span class="sd">          * y        (y) int64 24B 0 5 10</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.head</span>
<span class="sd">        Dataset.tail</span>
<span class="sd">        DataArray.thin</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">indexers_kwargs</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">indexers</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;indexers must be either dict-like or a single integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">indexers</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="n">indexers</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;thin&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;expected integer type indexer for &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dimension </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, found </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;expected positive integer as indexer &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for dimension </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, found </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;step cannot be zero&quot;</span><span class="p">)</span>
        <span class="n">indexers_slices</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indexers_slices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">broadcast_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">T_DataArrayOrSet</span><span class="p">,</span>
        <span class="n">exclude</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Broadcast this DataArray against another Dataset or DataArray.</span>
<span class="sd">        This is equivalent to xr.broadcast(other, self)[1]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Dataset or DataArray</span>
<span class="sd">            Object against which to broadcast this array.</span>
<span class="sd">        exclude : iterable of hashable, optional</span>
<span class="sd">            Dimensions that must not be broadcasted</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">)</span>

        <span class="n">dims_map</span><span class="p">,</span> <span class="n">common_coords</span> <span class="o">=</span> <span class="n">_get_broadcast_dims_map_common_coords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_broadcast_helper</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">exclude</span><span class="p">,</span> <span class="n">dims_map</span><span class="p">,</span> <span class="n">common_coords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_callback</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">aligner</span><span class="p">:</span> <span class="n">alignment</span><span class="o">.</span><span class="n">Aligner</span><span class="p">,</span>
        <span class="n">dim_pos_indexers</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">],</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">exclude_dims</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="n">exclude_vars</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Callback called from ``Aligner`` to create a new reindexed Dataset.&quot;&quot;&quot;</span>

        <span class="n">new_variables</span> <span class="o">=</span> <span class="n">variables</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_indexes</span> <span class="o">=</span> <span class="n">indexes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># re-assign variable metadata</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_var</span> <span class="ow">in</span> <span class="n">new_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_var</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">attrs</span>
                <span class="n">new_var</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">encoding</span>

        <span class="c1"># pass through indexes from excluded dimensions</span>
        <span class="c1"># no extra check needed for multi-coordinate indexes, potential conflicts</span>
        <span class="c1"># should already have been detected when aligning the indexes</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">exclude_dims</span><span class="p">:</span>
                <span class="n">new_indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
                <span class="n">new_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dim_pos_indexers</span><span class="p">:</span>
            <span class="c1"># fast path for no reindexing necessary</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_indexes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">):</span>
                <span class="c1"># this only adds new indexes and their coordinate variables</span>
                <span class="n">reindexed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_overwrite_indexes</span><span class="p">(</span><span class="n">new_indexes</span><span class="p">,</span> <span class="n">new_variables</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reindexed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">aligner</span><span class="o">.</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_reindex</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variables</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_vars</span>
            <span class="p">}</span>
            <span class="n">reindexed_vars</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">reindex_variables</span><span class="p">(</span>
                <span class="n">to_reindex</span><span class="p">,</span>
                <span class="n">dim_pos_indexers</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">aligner</span><span class="o">.</span><span class="n">copy</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">sparse</span><span class="o">=</span><span class="n">aligner</span><span class="o">.</span><span class="n">sparse</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">new_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">reindexed_vars</span><span class="p">)</span>
            <span class="n">new_coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_indexes</span><span class="p">)</span>
            <span class="n">reindexed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
                <span class="n">new_variables</span><span class="p">,</span> <span class="n">new_coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">new_indexes</span>
            <span class="p">)</span>

        <span class="n">reindexed</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span>

        <span class="k">return</span> <span class="n">reindexed</span>

    <span class="k">def</span> <span class="nf">reindex_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">T_Xarray</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">ReindexMethodOptions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">xrdtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conform this object onto the indexes of another object, for indexes which the</span>
<span class="sd">        objects share. Missing values are filled with ``fill_value``. The default fill</span>
<span class="sd">        value is NaN.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Dataset or DataArray</span>
<span class="sd">            Object with an &#39;indexes&#39; attribute giving a mapping from dimension</span>
<span class="sd">            names to pandas.Index objects, which provides coordinates upon</span>
<span class="sd">            which to index the variables in this dataset. The indexes on this</span>
<span class="sd">            other object need not be the same as the indexes on this</span>
<span class="sd">            dataset. Any mis-matched index values will be filled in with</span>
<span class="sd">            NaN, and any mis-matched dimension names will simply be ignored.</span>
<span class="sd">        method : {None, &quot;nearest&quot;, &quot;pad&quot;, &quot;ffill&quot;, &quot;backfill&quot;, &quot;bfill&quot;, None}, optional</span>
<span class="sd">            Method to use for filling index values from other not found in this</span>
<span class="sd">            dataset:</span>

<span class="sd">            - None (default): don&#39;t fill gaps</span>
<span class="sd">            - &quot;pad&quot; / &quot;ffill&quot;: propagate last valid index value forward</span>
<span class="sd">            - &quot;backfill&quot; / &quot;bfill&quot;: propagate next valid index value backward</span>
<span class="sd">            - &quot;nearest&quot;: use nearest valid index value</span>

<span class="sd">        tolerance : float | Iterable[float] | str | None, default: None</span>
<span class="sd">            Maximum distance between original and new labels for inexact</span>
<span class="sd">            matches. The values of the index at the matching locations must</span>
<span class="sd">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>
<span class="sd">            Tolerance may be a scalar value, which applies the same tolerance</span>
<span class="sd">            to all values, or list-like, which applies variable tolerance per</span>
<span class="sd">            element. List-like must be the same size as the index and its dtype</span>
<span class="sd">            must exactly match the index’s type.</span>
<span class="sd">        copy : bool, default: True</span>
<span class="sd">            If ``copy=True``, data in the return value is always copied. If</span>
<span class="sd">            ``copy=False`` and reindexing is unnecessary, or can be performed</span>
<span class="sd">            with only slice operations, then the output may share memory with</span>
<span class="sd">            the input. In either case, a new xarray object is always returned.</span>
<span class="sd">        fill_value : scalar or dict-like, optional</span>
<span class="sd">            Value to use for newly missing values. If a dict-like maps</span>
<span class="sd">            variable names to fill values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reindexed : Dataset</span>
<span class="sd">            Another dataset, with this dataset&#39;s data but coordinates from the</span>
<span class="sd">            other object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.reindex</span>
<span class="sd">        DataArray.reindex_like</span>
<span class="sd">        align</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">alignment</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">ReindexMethodOptions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">xrdtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Conform this object onto a new set of indexes, filling in</span>
<span class="sd">        missing values with ``fill_value``. The default fill value is NaN.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexers : dict, optional</span>
<span class="sd">            Dictionary with keys given by dimension names and values given by</span>
<span class="sd">            arrays of coordinates tick labels. Any mis-matched coordinate</span>
<span class="sd">            values will be filled in with NaN, and any mis-matched dimension</span>
<span class="sd">            names will simply be ignored.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>
<span class="sd">        method : {None, &quot;nearest&quot;, &quot;pad&quot;, &quot;ffill&quot;, &quot;backfill&quot;, &quot;bfill&quot;, None}, optional</span>
<span class="sd">            Method to use for filling index values in ``indexers`` not found in</span>
<span class="sd">            this dataset:</span>

<span class="sd">            - None (default): don&#39;t fill gaps</span>
<span class="sd">            - &quot;pad&quot; / &quot;ffill&quot;: propagate last valid index value forward</span>
<span class="sd">            - &quot;backfill&quot; / &quot;bfill&quot;: propagate next valid index value backward</span>
<span class="sd">            - &quot;nearest&quot;: use nearest valid index value</span>

<span class="sd">        tolerance : float | Iterable[float] | str | None, default: None</span>
<span class="sd">            Maximum distance between original and new labels for inexact</span>
<span class="sd">            matches. The values of the index at the matching locations must</span>
<span class="sd">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>
<span class="sd">            Tolerance may be a scalar value, which applies the same tolerance</span>
<span class="sd">            to all values, or list-like, which applies variable tolerance per</span>
<span class="sd">            element. List-like must be the same size as the index and its dtype</span>
<span class="sd">            must exactly match the index’s type.</span>
<span class="sd">        copy : bool, default: True</span>
<span class="sd">            If ``copy=True``, data in the return value is always copied. If</span>
<span class="sd">            ``copy=False`` and reindexing is unnecessary, or can be performed</span>
<span class="sd">            with only slice operations, then the output may share memory with</span>
<span class="sd">            the input. In either case, a new xarray object is always returned.</span>
<span class="sd">        fill_value : scalar or dict-like, optional</span>
<span class="sd">            Value to use for newly missing values. If a dict-like,</span>
<span class="sd">            maps variable names (including coordinates) to fill values.</span>
<span class="sd">        sparse : bool, default: False</span>
<span class="sd">            use sparse-array.</span>
<span class="sd">        **indexers_kwargs : {dim: indexer, ...}, optional</span>
<span class="sd">            Keyword arguments in the same form as ``indexers``.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reindexed : Dataset</span>
<span class="sd">            Another dataset, with this dataset&#39;s data but replaced coordinates.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.reindex_like</span>
<span class="sd">        align</span>
<span class="sd">        pandas.Index.get_indexer</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a dataset with some fictional data.</span>

<span class="sd">        &gt;&gt;&gt; x = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;temperature&quot;: (&quot;station&quot;, 20 * np.random.rand(4)),</span>
<span class="sd">        ...         &quot;pressure&quot;: (&quot;station&quot;, 500 * np.random.rand(4)),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;station&quot;: [&quot;boston&quot;, &quot;nyc&quot;, &quot;seattle&quot;, &quot;denver&quot;]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 176B</span>
<span class="sd">        Dimensions:      (station: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * station      (station) &lt;U7 112B &#39;boston&#39; &#39;nyc&#39; &#39;seattle&#39; &#39;denver&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (station) float64 32B 10.98 14.3 12.06 10.9</span>
<span class="sd">            pressure     (station) float64 32B 211.8 322.9 218.8 445.9</span>
<span class="sd">        &gt;&gt;&gt; x.indexes</span>
<span class="sd">        Indexes:</span>
<span class="sd">            station  Index([&#39;boston&#39;, &#39;nyc&#39;, &#39;seattle&#39;, &#39;denver&#39;], dtype=&#39;object&#39;, name=&#39;station&#39;)</span>

<span class="sd">        Create a new index and reindex the dataset. By default values in the new index that</span>
<span class="sd">        do not have corresponding records in the dataset are assigned `NaN`.</span>

<span class="sd">        &gt;&gt;&gt; new_index = [&quot;boston&quot;, &quot;austin&quot;, &quot;seattle&quot;, &quot;lincoln&quot;]</span>
<span class="sd">        &gt;&gt;&gt; x.reindex({&quot;station&quot;: new_index})</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 176B</span>
<span class="sd">        Dimensions:      (station: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * station      (station) &lt;U7 112B &#39;boston&#39; &#39;austin&#39; &#39;seattle&#39; &#39;lincoln&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (station) float64 32B 10.98 nan 12.06 nan</span>
<span class="sd">            pressure     (station) float64 32B 211.8 nan 218.8 nan</span>

<span class="sd">        We can fill in the missing values by passing a value to the keyword `fill_value`.</span>

<span class="sd">        &gt;&gt;&gt; x.reindex({&quot;station&quot;: new_index}, fill_value=0)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 176B</span>
<span class="sd">        Dimensions:      (station: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * station      (station) &lt;U7 112B &#39;boston&#39; &#39;austin&#39; &#39;seattle&#39; &#39;lincoln&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (station) float64 32B 10.98 0.0 12.06 0.0</span>
<span class="sd">            pressure     (station) float64 32B 211.8 0.0 218.8 0.0</span>

<span class="sd">        We can also use different fill values for each variable.</span>

<span class="sd">        &gt;&gt;&gt; x.reindex(</span>
<span class="sd">        ...     {&quot;station&quot;: new_index}, fill_value={&quot;temperature&quot;: 0, &quot;pressure&quot;: 100}</span>
<span class="sd">        ... )</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 176B</span>
<span class="sd">        Dimensions:      (station: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * station      (station) &lt;U7 112B &#39;boston&#39; &#39;austin&#39; &#39;seattle&#39; &#39;lincoln&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (station) float64 32B 10.98 0.0 12.06 0.0</span>
<span class="sd">            pressure     (station) float64 32B 211.8 100.0 218.8 100.0</span>

<span class="sd">        Because the index is not monotonically increasing or decreasing, we cannot use arguments</span>
<span class="sd">        to the keyword method to fill the `NaN` values.</span>

<span class="sd">        &gt;&gt;&gt; x.reindex({&quot;station&quot;: new_index}, method=&quot;nearest&quot;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">            raise ValueError(&#39;index must be monotonic increasing or decreasing&#39;)</span>
<span class="sd">        ValueError: index must be monotonic increasing or decreasing</span>

<span class="sd">        To further illustrate the filling functionality in reindex, we will create a</span>
<span class="sd">        dataset with a monotonically increasing index (for example, a sequence of dates).</span>

<span class="sd">        &gt;&gt;&gt; x2 = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;temperature&quot;: (</span>
<span class="sd">        ...             &quot;time&quot;,</span>
<span class="sd">        ...             [15.57, 12.77, np.nan, 0.3081, 16.59, 15.12],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...         &quot;pressure&quot;: (&quot;time&quot;, 500 * np.random.rand(6)),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;time&quot;: pd.date_range(&quot;01/01/2019&quot;, periods=6, freq=&quot;D&quot;)},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; x2</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 144B</span>
<span class="sd">        Dimensions:      (time: 6)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) datetime64[ns] 48B 2019-01-01 2019-01-02 ... 2019-01-06</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time) float64 48B 15.57 12.77 nan 0.3081 16.59 15.12</span>
<span class="sd">            pressure     (time) float64 48B 481.8 191.7 395.9 264.4 284.0 462.8</span>

<span class="sd">        Suppose we decide to expand the dataset to cover a wider date range.</span>

<span class="sd">        &gt;&gt;&gt; time_index2 = pd.date_range(&quot;12/29/2018&quot;, periods=10, freq=&quot;D&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x2.reindex({&quot;time&quot;: time_index2})</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 240B</span>
<span class="sd">        Dimensions:      (time: 10)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) datetime64[ns] 80B 2018-12-29 2018-12-30 ... 2019-01-07</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time) float64 80B nan nan nan 15.57 ... 0.3081 16.59 15.12 nan</span>
<span class="sd">            pressure     (time) float64 80B nan nan nan 481.8 ... 264.4 284.0 462.8 nan</span>

<span class="sd">        The index entries that did not have a value in the original data frame (for example, `2018-12-29`)</span>
<span class="sd">        are by default filled with NaN. If desired, we can fill in the missing values using one of several options.</span>

<span class="sd">        For example, to back-propagate the last valid value to fill the `NaN` values,</span>
<span class="sd">        pass `bfill` as an argument to the `method` keyword.</span>

<span class="sd">        &gt;&gt;&gt; x3 = x2.reindex({&quot;time&quot;: time_index2}, method=&quot;bfill&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x3</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 240B</span>
<span class="sd">        Dimensions:      (time: 10)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) datetime64[ns] 80B 2018-12-29 2018-12-30 ... 2019-01-07</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time) float64 80B 15.57 15.57 15.57 15.57 ... 16.59 15.12 nan</span>
<span class="sd">            pressure     (time) float64 80B 481.8 481.8 481.8 481.8 ... 284.0 462.8 nan</span>

<span class="sd">        Please note that the `NaN` value present in the original dataset (at index value `2019-01-03`)</span>
<span class="sd">        will not be filled by any of the value propagation schemes.</span>

<span class="sd">        &gt;&gt;&gt; x2.where(x2.temperature.isnull(), drop=True)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 24B</span>
<span class="sd">        Dimensions:      (time: 1)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) datetime64[ns] 8B 2019-01-03</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time) float64 8B nan</span>
<span class="sd">            pressure     (time) float64 8B 395.9</span>
<span class="sd">        &gt;&gt;&gt; x3.where(x3.temperature.isnull(), drop=True)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 48B</span>
<span class="sd">        Dimensions:      (time: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) datetime64[ns] 16B 2019-01-03 2019-01-07</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time) float64 16B nan nan</span>
<span class="sd">            pressure     (time) float64 16B 395.9 nan</span>

<span class="sd">        This is because filling while reindexing does not look at dataset values, but only compares</span>
<span class="sd">        the original and desired indexes. If you do want to fill in the `NaN` values present in the</span>
<span class="sd">        original dataset, use the :py:meth:`~Dataset.fillna()` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;reindex&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">alignment</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">indexers</span><span class="o">=</span><span class="n">indexers</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">xrdtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as reindex but supports sparse option.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;reindex&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">alignment</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">indexers</span><span class="o">=</span><span class="n">indexers</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">interp</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coords</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">InterpOptions</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">assume_sorted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method_non_numeric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">coords_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate a Dataset onto new coordinates</span>

<span class="sd">        Performs univariate or multivariate interpolation of a Dataset onto</span>
<span class="sd">        new coordinates using scipy&#39;s interpolation routines. If interpolating</span>
<span class="sd">        along an existing dimension, :py:class:`scipy.interpolate.interp1d` is</span>
<span class="sd">        called.  When interpolating along multiple existing dimensions, an</span>
<span class="sd">        attempt is made to decompose the interpolation into multiple</span>
<span class="sd">        1-dimensional interpolations. If this is possible,</span>
<span class="sd">        :py:class:`scipy.interpolate.interp1d` is called. Otherwise,</span>
<span class="sd">        :py:func:`scipy.interpolate.interpn` is called.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : dict, optional</span>
<span class="sd">            Mapping from dimension names to the new coordinates.</span>
<span class="sd">            New coordinate can be a scalar, array-like or DataArray.</span>
<span class="sd">            If DataArrays are passed as new coordinates, their dimensions are</span>
<span class="sd">            used for the broadcasting. Missing values are skipped.</span>
<span class="sd">        method : {&quot;linear&quot;, &quot;nearest&quot;, &quot;zero&quot;, &quot;slinear&quot;, &quot;quadratic&quot;, &quot;cubic&quot;, &quot;polynomial&quot;, \</span>
<span class="sd">            &quot;barycentric&quot;, &quot;krogh&quot;, &quot;pchip&quot;, &quot;spline&quot;, &quot;akima&quot;}, default: &quot;linear&quot;</span>
<span class="sd">            String indicating which method to use for interpolation:</span>

<span class="sd">            - &#39;linear&#39;: linear interpolation. Additional keyword</span>
<span class="sd">              arguments are passed to :py:func:`numpy.interp`</span>
<span class="sd">            - &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;polynomial&#39;:</span>
<span class="sd">              are passed to :py:func:`scipy.interpolate.interp1d`. If</span>
<span class="sd">              ``method=&#39;polynomial&#39;``, the ``order`` keyword argument must also be</span>
<span class="sd">              provided.</span>
<span class="sd">            - &#39;barycentric&#39;, &#39;krogh&#39;, &#39;pchip&#39;, &#39;spline&#39;, &#39;akima&#39;: use their</span>
<span class="sd">              respective :py:class:`scipy.interpolate` classes.</span>

<span class="sd">        assume_sorted : bool, default: False</span>
<span class="sd">            If False, values of coordinates that are interpolated over can be</span>
<span class="sd">            in any order and they are sorted first. If True, interpolated</span>
<span class="sd">            coordinates are assumed to be an array of monotonically increasing</span>
<span class="sd">            values.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to scipy&#39;s interpolator. Valid</span>
<span class="sd">            options and their behavior depend whether ``interp1d`` or</span>
<span class="sd">            ``interpn`` is used.</span>
<span class="sd">        method_non_numeric : {&quot;nearest&quot;, &quot;pad&quot;, &quot;ffill&quot;, &quot;backfill&quot;, &quot;bfill&quot;}, optional</span>
<span class="sd">            Method for non-numeric types. Passed on to :py:meth:`Dataset.reindex`.</span>
<span class="sd">            ``&quot;nearest&quot;`` is used by default.</span>
<span class="sd">        **coords_kwargs : {dim: coordinate, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``coords``.</span>
<span class="sd">            One of coords or coords_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        interpolated : Dataset</span>
<span class="sd">            New dataset on the new coordinates.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        scipy is required.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        scipy.interpolate.interp1d</span>
<span class="sd">        scipy.interpolate.interpn</span>

<span class="sd">        :doc:`xarray-tutorial:fundamentals/02.2_manipulating_dimensions`</span>
<span class="sd">            Tutorial material on manipulating data resolution using :py:func:`~xarray.Dataset.interp`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     data_vars={</span>
<span class="sd">        ...         &quot;a&quot;: (&quot;x&quot;, [5, 7, 4]),</span>
<span class="sd">        ...         &quot;b&quot;: (</span>
<span class="sd">        ...             (&quot;x&quot;, &quot;y&quot;),</span>
<span class="sd">        ...             [[1, 4, 2, 9], [2, 7, 6, np.nan], [6, np.nan, 5, 8]],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;x&quot;: [0, 1, 2], &quot;y&quot;: [10, 12, 14, 16]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 176B</span>
<span class="sd">        Dimensions:  (x: 3, y: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 24B 0 1 2</span>
<span class="sd">          * y        (y) int64 32B 10 12 14 16</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) int64 24B 5 7 4</span>
<span class="sd">            b        (x, y) float64 96B 1.0 4.0 2.0 9.0 2.0 7.0 6.0 nan 6.0 nan 5.0 8.0</span>

<span class="sd">        1D interpolation with the default method (linear):</span>

<span class="sd">        &gt;&gt;&gt; ds.interp(x=[0, 0.75, 1.25, 1.75])</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 224B</span>
<span class="sd">        Dimensions:  (x: 4, y: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 32B 10 12 14 16</span>
<span class="sd">          * x        (x) float64 32B 0.0 0.75 1.25 1.75</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) float64 32B 5.0 6.5 6.25 4.75</span>
<span class="sd">            b        (x, y) float64 128B 1.0 4.0 2.0 nan 1.75 ... nan 5.0 nan 5.25 nan</span>

<span class="sd">        1D interpolation with a different method:</span>

<span class="sd">        &gt;&gt;&gt; ds.interp(x=[0, 0.75, 1.25, 1.75], method=&quot;nearest&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 224B</span>
<span class="sd">        Dimensions:  (x: 4, y: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 32B 10 12 14 16</span>
<span class="sd">          * x        (x) float64 32B 0.0 0.75 1.25 1.75</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) float64 32B 5.0 7.0 7.0 4.0</span>
<span class="sd">            b        (x, y) float64 128B 1.0 4.0 2.0 9.0 2.0 7.0 ... nan 6.0 nan 5.0 8.0</span>

<span class="sd">        1D extrapolation:</span>

<span class="sd">        &gt;&gt;&gt; ds.interp(</span>
<span class="sd">        ...     x=[1, 1.5, 2.5, 3.5],</span>
<span class="sd">        ...     method=&quot;linear&quot;,</span>
<span class="sd">        ...     kwargs={&quot;fill_value&quot;: &quot;extrapolate&quot;},</span>
<span class="sd">        ... )</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 224B</span>
<span class="sd">        Dimensions:  (x: 4, y: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 32B 10 12 14 16</span>
<span class="sd">          * x        (x) float64 32B 1.0 1.5 2.5 3.5</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) float64 32B 7.0 5.5 2.5 -0.5</span>
<span class="sd">            b        (x, y) float64 128B 2.0 7.0 6.0 nan 4.0 ... nan 12.0 nan 3.5 nan</span>

<span class="sd">        2D interpolation:</span>

<span class="sd">        &gt;&gt;&gt; ds.interp(x=[0, 0.75, 1.25, 1.75], y=[11, 13, 15], method=&quot;linear&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 184B</span>
<span class="sd">        Dimensions:  (x: 4, y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) float64 32B 0.0 0.75 1.25 1.75</span>
<span class="sd">          * y        (y) int64 24B 11 13 15</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) float64 32B 5.0 6.5 6.25 4.75</span>
<span class="sd">            b        (x, y) float64 96B 2.5 3.0 nan 4.0 5.625 ... nan nan nan nan nan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core</span> <span class="kn">import</span> <span class="n">missing</span>

        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">coords_kwargs</span><span class="p">,</span> <span class="s2">&quot;interp&quot;</span><span class="p">)</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_validate_interp_indexers</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">coords</span><span class="p">:</span>
            <span class="c1"># This avoids broadcasting over coordinates that are both in</span>
            <span class="c1"># the original array AND in the indexing array. It essentially</span>
            <span class="c1"># forces interpolation along the shared coordinates.</span>
            <span class="n">sdims</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
                <span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="k">for</span> <span class="n">nx</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
                <span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="p">)</span>
            <span class="n">indexers</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">d</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sdims</span><span class="p">})</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">assume_sorted</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">sortby</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">maybe_variable</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="c1"># workaround to get variable for dimension without coordinate.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">as_variable</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">k</span><span class="p">])))</span>

        <span class="k">def</span> <span class="nf">_validate_interp_indexer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">new_x</span><span class="p">):</span>
            <span class="c1"># In the case of datetimes, the restrictions placed on indexers</span>
            <span class="c1"># used with interp are stronger than those which are placed on</span>
            <span class="c1"># isel, so we need an additional check after _validate_indexers.</span>
            <span class="k">if</span> <span class="n">_contains_datetime_like_objects</span><span class="p">(</span>
                <span class="n">x</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_contains_datetime_like_objects</span><span class="p">(</span><span class="n">new_x</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;When interpolating over a datetime-like &quot;</span>
                    <span class="s2">&quot;coordinate, the coordinates to &quot;</span>
                    <span class="s2">&quot;interpolate to must be either datetime &quot;</span>
                    <span class="s2">&quot;strings or datetimes. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Instead got</span><span class="se">\n</span><span class="si">{</span><span class="n">new_x</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">new_x</span>

        <span class="n">validated_indexers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">_validate_interp_indexer</span><span class="p">(</span><span class="n">maybe_variable</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># optimization: subset to coordinate range of the target index</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">validated_indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">obj</span><span class="p">,</span> <span class="n">newidx</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">_localize</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">})</span>
                <span class="n">validated_indexers</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">newidx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1"># optimization: create dask coordinate arrays once per Dataset</span>
        <span class="c1"># rather than once per Variable when dask.array.unify_chunks is called later</span>
        <span class="c1"># GH4739</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">():</span>
            <span class="n">dask_indexers</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">to_base_variable</span><span class="p">()</span><span class="o">.</span><span class="n">chunk</span><span class="p">(),</span> <span class="n">dest</span><span class="o">.</span><span class="n">to_base_variable</span><span class="p">()</span><span class="o">.</span><span class="n">chunk</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span> <span class="ow">in</span> <span class="n">validated_indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">reindex</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">indexers</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">is_duck_dask_array</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
                <span class="n">use_indexers</span> <span class="o">=</span> <span class="n">dask_indexers</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">use_indexers</span> <span class="o">=</span> <span class="n">validated_indexers</span>

            <span class="n">dtype_kind</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span>
            <span class="k">if</span> <span class="n">dtype_kind</span> <span class="ow">in</span> <span class="s2">&quot;uifc&quot;</span><span class="p">:</span>
                <span class="c1"># For normal number types do the interpolation:</span>
                <span class="n">var_indexers</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">use_indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">var_indexers</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dtype_kind</span> <span class="ow">in</span> <span class="s2">&quot;ObU&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">use_indexers</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
                <span class="c1"># For types that we do not understand do stepwise</span>
                <span class="c1"># interpolation to avoid modifying the elements.</span>
                <span class="c1"># reindex the variable instead because it supports</span>
                <span class="c1"># booleans and objects and retains the dtype but inside</span>
                <span class="c1"># this loop there might be some duplicate code that slows it</span>
                <span class="c1"># down, therefore collect these signals and run it later:</span>
                <span class="n">reindex</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indexers</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
                <span class="c1"># For anything else we can only keep variables if they</span>
                <span class="c1"># are not dependent on any coords that are being</span>
                <span class="c1"># interpolated along:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="k">if</span> <span class="n">reindex</span><span class="p">:</span>
            <span class="n">reindex_indexers</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">validated_indexers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span> <span class="o">==</span> <span class="p">(</span><span class="n">k</span><span class="p">,)</span>
            <span class="p">}</span>
            <span class="n">reindexed</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                <span class="n">obj</span><span class="p">,</span>
                <span class="n">indexers</span><span class="o">=</span><span class="n">reindex_indexers</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method_non_numeric</span><span class="p">,</span>
                <span class="n">exclude_vars</span><span class="o">=</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">reindexed</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">reindexed</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get the indexes that are not being interpolated along</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indexers</span><span class="p">}</span>

        <span class="c1"># Get the coords that also exist in the variables:</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">&amp;</span> <span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

        <span class="c1"># Attach indexer as coordinate</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span> <span class="o">==</span> <span class="p">(</span><span class="n">k</span><span class="p">,):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">PandasIndex</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">coord_dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">index_vars</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">create_variables</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">})</span>
                <span class="n">indexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">index_vars</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="c1"># Extract coordinates from indexers</span>
        <span class="n">coord_vars</span><span class="p">,</span> <span class="n">new_indexes</span> <span class="o">=</span> <span class="n">selected</span><span class="o">.</span><span class="n">_get_indexers_coords_and_indexes</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">coord_vars</span><span class="p">)</span>
        <span class="n">indexes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_indexes</span><span class="p">)</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">&amp;</span> <span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">|</span> <span class="n">coord_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interp_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">T_Xarray</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">InterpOptions</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">assume_sorted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method_non_numeric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate this object onto the coordinates of another object,</span>
<span class="sd">        filling the out of range values with NaN.</span>

<span class="sd">        If interpolating along a single existing dimension,</span>
<span class="sd">        :py:class:`scipy.interpolate.interp1d` is called. When interpolating</span>
<span class="sd">        along multiple existing dimensions, an attempt is made to decompose the</span>
<span class="sd">        interpolation into multiple 1-dimensional interpolations. If this is</span>
<span class="sd">        possible, :py:class:`scipy.interpolate.interp1d` is called. Otherwise,</span>
<span class="sd">        :py:func:`scipy.interpolate.interpn` is called.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Dataset or DataArray</span>
<span class="sd">            Object with an &#39;indexes&#39; attribute giving a mapping from dimension</span>
<span class="sd">            names to an 1d array-like, which provides coordinates upon</span>
<span class="sd">            which to index the variables in this dataset. Missing values are skipped.</span>
<span class="sd">        method : {&quot;linear&quot;, &quot;nearest&quot;, &quot;zero&quot;, &quot;slinear&quot;, &quot;quadratic&quot;, &quot;cubic&quot;, &quot;polynomial&quot;, \</span>
<span class="sd">            &quot;barycentric&quot;, &quot;krogh&quot;, &quot;pchip&quot;, &quot;spline&quot;, &quot;akima&quot;}, default: &quot;linear&quot;</span>
<span class="sd">            String indicating which method to use for interpolation:</span>

<span class="sd">            - &#39;linear&#39;: linear interpolation. Additional keyword</span>
<span class="sd">              arguments are passed to :py:func:`numpy.interp`</span>
<span class="sd">            - &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;polynomial&#39;:</span>
<span class="sd">              are passed to :py:func:`scipy.interpolate.interp1d`. If</span>
<span class="sd">              ``method=&#39;polynomial&#39;``, the ``order`` keyword argument must also be</span>
<span class="sd">              provided.</span>
<span class="sd">            - &#39;barycentric&#39;, &#39;krogh&#39;, &#39;pchip&#39;, &#39;spline&#39;, &#39;akima&#39;: use their</span>
<span class="sd">              respective :py:class:`scipy.interpolate` classes.</span>

<span class="sd">        assume_sorted : bool, default: False</span>
<span class="sd">            If False, values of coordinates that are interpolated over can be</span>
<span class="sd">            in any order and they are sorted first. If True, interpolated</span>
<span class="sd">            coordinates are assumed to be an array of monotonically increasing</span>
<span class="sd">            values.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Additional keyword passed to scipy&#39;s interpolator.</span>
<span class="sd">        method_non_numeric : {&quot;nearest&quot;, &quot;pad&quot;, &quot;ffill&quot;, &quot;backfill&quot;, &quot;bfill&quot;}, optional</span>
<span class="sd">            Method for non-numeric types. Passed on to :py:meth:`Dataset.reindex`.</span>
<span class="sd">            ``&quot;nearest&quot;`` is used by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        interpolated : Dataset</span>
<span class="sd">            Another dataset by interpolating this dataset&#39;s data along the</span>
<span class="sd">            coordinates of the other object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        scipy is required.</span>
<span class="sd">        If the dataset has object-type coordinates, reindex is used for these</span>
<span class="sd">        coordinates instead of the interpolation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.interp</span>
<span class="sd">        Dataset.reindex_like</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># pick only dimension coordinates with a single index</span>
        <span class="n">coords</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">other_indexes</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">xindexes</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">other_dim_coords</span> <span class="o">=</span> <span class="n">other_indexes</span><span class="o">.</span><span class="n">get_all_coords</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_dim_coords</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">other_dim_coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="n">numeric_coords</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">object_coords</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;uifcMm&quot;</span><span class="p">:</span>
                <span class="n">numeric_coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">object_coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">object_coords</span><span class="p">:</span>
            <span class="c1"># We do not support interpolation along object coordinate.</span>
            <span class="c1"># reindex instead.</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">object_coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ds</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">numeric_coords</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">assume_sorted</span><span class="o">=</span><span class="n">assume_sorted</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="n">method_non_numeric</span><span class="o">=</span><span class="n">method_non_numeric</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Helper methods for rename()</span>
    <span class="k">def</span> <span class="nf">_rename_vars</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name_dict</span><span class="p">,</span> <span class="n">dims_dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]:</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;the new name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> conflicts&quot;</span><span class="p">)</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">:</span>
                <span class="n">coord_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span>

    <span class="k">def</span> <span class="nf">_rename_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">name_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">def</span> <span class="nf">_rename_indexes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">],</span> <span class="n">dims_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{},</span> <span class="p">{}</span>

        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">coord_names</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">group_by_index</span><span class="p">():</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name_dict</span><span class="p">,</span> <span class="n">dims_dict</span><span class="p">)</span>
            <span class="n">new_coord_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coord_names</span><span class="p">]</span>
            <span class="n">indexes</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">new_index</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_coord_names</span><span class="p">})</span>
            <span class="n">new_index_vars</span> <span class="o">=</span> <span class="n">new_index</span><span class="o">.</span><span class="n">create_variables</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="n">new</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">old</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">new_coord_names</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_index_vars</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">variables</span>

    <span class="k">def</span> <span class="nf">_rename_all</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">],</span> <span class="n">dims_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span>
        <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">],</span>
    <span class="p">]:</span>
        <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_vars</span><span class="p">(</span><span class="n">name_dict</span><span class="p">,</span> <span class="n">dims_dict</span><span class="p">)</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_dims</span><span class="p">(</span><span class="n">dims_dict</span><span class="p">)</span>

        <span class="n">indexes</span><span class="p">,</span> <span class="n">index_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_indexes</span><span class="p">(</span><span class="n">name_dict</span><span class="p">,</span> <span class="n">dims_dict</span><span class="p">)</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">index_vars</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">return</span> <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">indexes</span>

    <span class="k">def</span> <span class="nf">_rename</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">names</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Also used internally by DataArray so that the warning (if any)</span>
<span class="sd">        is raised at the right stack level.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name_dict</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">name_dict</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="s2">&quot;rename&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">name_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;cannot rename </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> because it is not a &quot;</span>
                    <span class="s2">&quot;variable or dimension in this dataset&quot;</span>
                <span class="p">)</span>

            <span class="n">create_dim_coord</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">new_k</span> <span class="o">=</span> <span class="n">name_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">new_k</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># Same name, nothing to do</span>

            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="ow">and</span> <span class="n">new_k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">:</span>
                <span class="n">coord_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">name_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span><span class="o">.</span><span class="n">dims</span>
                <span class="k">if</span> <span class="n">coord_dims</span> <span class="o">==</span> <span class="p">(</span><span class="n">k</span><span class="p">,):</span>
                    <span class="n">create_dim_coord</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="ow">and</span> <span class="n">new_k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="n">coord_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span>
                <span class="k">if</span> <span class="n">coord_dims</span> <span class="o">==</span> <span class="p">(</span><span class="n">new_k</span><span class="p">,):</span>
                    <span class="n">create_dim_coord</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">create_dim_coord</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;rename </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> to </span><span class="si">{</span><span class="n">name_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="si">!r}</span><span class="s2"> does not create an index &quot;</span>
                    <span class="s2">&quot;anymore. Try using swap_dims instead or use set_index &quot;</span>
                    <span class="s2">&quot;after rename to create an indexed coordinate.&quot;</span><span class="p">,</span>
                    <span class="ne">UserWarning</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_all</span><span class="p">(</span>
            <span class="n">name_dict</span><span class="o">=</span><span class="n">name_dict</span><span class="p">,</span> <span class="n">dims_dict</span><span class="o">=</span><span class="n">name_dict</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">names</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new object with renamed variables, coordinates and dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name_dict : dict-like, optional</span>
<span class="sd">            Dictionary whose keys are current variable, coordinate or dimension names and</span>
<span class="sd">            whose values are the desired names.</span>
<span class="sd">        **names : optional</span>
<span class="sd">            Keyword form of ``name_dict``.</span>
<span class="sd">            One of name_dict or names must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : Dataset</span>
<span class="sd">            Dataset with renamed variables, coordinates and dimensions.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.swap_dims</span>
<span class="sd">        Dataset.rename_vars</span>
<span class="sd">        Dataset.rename_dims</span>
<span class="sd">        DataArray.rename</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename</span><span class="p">(</span><span class="n">name_dict</span><span class="o">=</span><span class="n">name_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dims_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">dims</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new object with renamed dimensions only.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dims_dict : dict-like, optional</span>
<span class="sd">            Dictionary whose keys are current dimension names and</span>
<span class="sd">            whose values are the desired names. The desired names must</span>
<span class="sd">            not be the name of an existing dimension or Variable in the Dataset.</span>
<span class="sd">        **dims : optional</span>
<span class="sd">            Keyword form of ``dims_dict``.</span>
<span class="sd">            One of dims_dict or dims must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : Dataset</span>
<span class="sd">            Dataset with renamed dimensions.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.swap_dims</span>
<span class="sd">        Dataset.rename</span>
<span class="sd">        Dataset.rename_vars</span>
<span class="sd">        DataArray.rename</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dims_dict</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">dims_dict</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="s2">&quot;rename_dims&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dims_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;cannot rename </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> because it is not found &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;in the dimensions of this dataset </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="ow">or</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot rename </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> because </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> already exists. &quot;</span>
                    <span class="s2">&quot;Try using swap_dims instead.&quot;</span>
                <span class="p">)</span>

        <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_all</span><span class="p">(</span>
            <span class="n">name_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">dims_dict</span><span class="o">=</span><span class="n">dims_dict</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">sizes</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename_vars</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">names</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new object with renamed variables including coordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name_dict : dict-like, optional</span>
<span class="sd">            Dictionary whose keys are current variable or coordinate names and</span>
<span class="sd">            whose values are the desired names.</span>
<span class="sd">        **names : optional</span>
<span class="sd">            Keyword form of ``name_dict``.</span>
<span class="sd">            One of name_dict or names must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : Dataset</span>
<span class="sd">            Dataset with renamed variables including coordinates</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.swap_dims</span>
<span class="sd">        Dataset.rename</span>
<span class="sd">        Dataset.rename_dims</span>
<span class="sd">        DataArray.rename</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name_dict</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">name_dict</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="s2">&quot;rename_vars&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">name_dict</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;cannot rename </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> because it is not a &quot;</span>
                    <span class="s2">&quot;variable or coordinate in this dataset&quot;</span>
                <span class="p">)</span>
        <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_all</span><span class="p">(</span>
            <span class="n">name_dict</span><span class="o">=</span><span class="n">name_dict</span><span class="p">,</span> <span class="n">dims_dict</span><span class="o">=</span><span class="p">{}</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">swap_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dims_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">dims_kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new object with swapped dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dims_dict : dict-like</span>
<span class="sd">            Dictionary whose keys are current dimension names and whose values</span>
<span class="sd">            are new names.</span>
<span class="sd">        **dims_kwargs : {existing_dim: new_dim, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``dims_dict``.</span>
<span class="sd">            One of dims_dict or dims_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        swapped : Dataset</span>
<span class="sd">            Dataset with swapped dimensions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     data_vars={&quot;a&quot;: (&quot;x&quot;, [5, 7]), &quot;b&quot;: (&quot;x&quot;, [0.1, 2.4])},</span>
<span class="sd">        ...     coords={&quot;x&quot;: [&quot;a&quot;, &quot;b&quot;], &quot;y&quot;: (&quot;x&quot;, [0, 1])},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 56B</span>
<span class="sd">        Dimensions:  (x: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U1 8B &#39;a&#39; &#39;b&#39;</span>
<span class="sd">            y        (x) int64 16B 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) int64 16B 5 7</span>
<span class="sd">            b        (x) float64 16B 0.1 2.4</span>

<span class="sd">        &gt;&gt;&gt; ds.swap_dims({&quot;x&quot;: &quot;y&quot;})</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 56B</span>
<span class="sd">        Dimensions:  (y: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            x        (y) &lt;U1 8B &#39;a&#39; &#39;b&#39;</span>
<span class="sd">          * y        (y) int64 16B 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (y) int64 16B 5 7</span>
<span class="sd">            b        (y) float64 16B 0.1 2.4</span>

<span class="sd">        &gt;&gt;&gt; ds.swap_dims({&quot;x&quot;: &quot;z&quot;})</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 56B</span>
<span class="sd">        Dimensions:  (z: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            x        (z) &lt;U1 8B &#39;a&#39; &#39;b&#39;</span>
<span class="sd">            y        (z) int64 16B 0 1</span>
<span class="sd">        Dimensions without coordinates: z</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (z) int64 16B 5 7</span>
<span class="sd">            b        (z) float64 16B 0.1 2.4</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.rename</span>
<span class="sd">        DataArray.swap_dims</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: deprecate this method in favor of a (less confusing)</span>
        <span class="c1"># rename_dims() method that only renames dimensions.</span>

        <span class="n">dims_dict</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">dims_dict</span><span class="p">,</span> <span class="n">dims_kwargs</span><span class="p">,</span> <span class="s2">&quot;swap_dims&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">current_name</span><span class="p">,</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="n">dims_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">current_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;cannot swap from dimension </span><span class="si">{</span><span class="n">current_name</span><span class="si">!r}</span><span class="s2"> because it is &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;not one of the dimensions of this dataset </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span> <span class="o">!=</span> <span class="p">(</span>
                <span class="n">current_name</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;replacement dimension </span><span class="si">{</span><span class="n">new_name</span><span class="si">!r}</span><span class="s2"> is not a 1D &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;variable along the old dimension </span><span class="si">{</span><span class="n">current_name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">result_dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">dims_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">coord_names</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">})</span>

        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">current_name</span><span class="p">,</span> <span class="n">current_variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">current_variable</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">var</span><span class="p">:</span> <span class="n">Variable</span>
            <span class="k">if</span> <span class="n">current_name</span> <span class="ow">in</span> <span class="n">result_dims</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">current_variable</span><span class="o">.</span><span class="n">to_index_variable</span><span class="p">()</span>
                <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="n">dims</span>
                <span class="k">if</span> <span class="n">current_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">:</span>
                    <span class="n">indexes</span><span class="p">[</span><span class="n">current_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">[</span><span class="n">current_name</span><span class="p">]</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">current_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span><span class="p">,</span> <span class="n">index_vars</span> <span class="o">=</span> <span class="n">create_default_index_implicit</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                    <span class="n">indexes</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">index</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">index_vars</span><span class="p">})</span>
                    <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">index_vars</span><span class="p">)</span>
                    <span class="n">coord_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">index_vars</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">current_variable</span><span class="o">.</span><span class="n">to_base_variable</span><span class="p">()</span>
                <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="n">dims</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">current_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">create_index_for_new_dim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">dim_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new object with an additional axis (or axes) inserted at</span>
<span class="sd">        the corresponding position in the array shape.  The new object is a</span>
<span class="sd">        view into the underlying array, not a copy.</span>

<span class="sd">        If dim is already a scalar coordinate, it will be promoted to a 1D</span>
<span class="sd">        coordinate consisting of a single value.</span>

<span class="sd">        The automatic creation of indexes to back new 1D coordinate variables</span>
<span class="sd">        controlled by the create_index_for_new_dim kwarg.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : hashable, sequence of hashable, mapping, or None</span>
<span class="sd">            Dimensions to include on the new variable. If provided as hashable</span>
<span class="sd">            or sequence of hashable, then dimensions are inserted with length</span>
<span class="sd">            1. If provided as a mapping, then the keys are the new dimensions</span>
<span class="sd">            and the values are either integers (giving the length of the new</span>
<span class="sd">            dimensions) or array-like (giving the coordinates of the new</span>
<span class="sd">            dimensions).</span>
<span class="sd">        axis : int, sequence of int, or None, default: None</span>
<span class="sd">            Axis position(s) where new axis is to be inserted (position(s) on</span>
<span class="sd">            the result array). If a sequence of integers is passed,</span>
<span class="sd">            multiple axes are inserted. In this case, dim arguments should be</span>
<span class="sd">            same length list. If axis=None is passed, all the axes will be</span>
<span class="sd">            inserted to the start of the result array.</span>
<span class="sd">        create_index_for_new_dim : bool, default: True</span>
<span class="sd">            Whether to create new ``PandasIndex`` objects when the object being expanded contains scalar variables with names in ``dim``.</span>
<span class="sd">        **dim_kwargs : int or sequence or ndarray</span>
<span class="sd">            The keywords are arbitrary dimensions being inserted and the values</span>
<span class="sd">            are either the lengths of the new dims (if int is given), or their</span>
<span class="sd">            coordinates. Note, this is an alternative to passing a dict to the</span>
<span class="sd">            dim kwarg and will only be used if dim is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        expanded : Dataset</span>
<span class="sd">            This object, but with additional dimension(s).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; dataset = xr.Dataset({&quot;temperature&quot;: ([], 25.0)})</span>
<span class="sd">        &gt;&gt;&gt; dataset</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 8B</span>
<span class="sd">        Dimensions:      ()</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  float64 8B 25.0</span>

<span class="sd">        # Expand the dataset with a new dimension called &quot;time&quot;</span>

<span class="sd">        &gt;&gt;&gt; dataset.expand_dims(dim=&quot;time&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 8B</span>
<span class="sd">        Dimensions:      (time: 1)</span>
<span class="sd">        Dimensions without coordinates: time</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time) float64 8B 25.0</span>

<span class="sd">        # 1D data</span>

<span class="sd">        &gt;&gt;&gt; temperature_1d = xr.DataArray([25.0, 26.5, 24.8], dims=&quot;x&quot;)</span>
<span class="sd">        &gt;&gt;&gt; dataset_1d = xr.Dataset({&quot;temperature&quot;: temperature_1d})</span>
<span class="sd">        &gt;&gt;&gt; dataset_1d</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 24B</span>
<span class="sd">        Dimensions:      (x: 3)</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (x) float64 24B 25.0 26.5 24.8</span>

<span class="sd">        # Expand the dataset with a new dimension called &quot;time&quot; using axis argument</span>

<span class="sd">        &gt;&gt;&gt; dataset_1d.expand_dims(dim=&quot;time&quot;, axis=0)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 24B</span>
<span class="sd">        Dimensions:      (time: 1, x: 3)</span>
<span class="sd">        Dimensions without coordinates: time, x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time, x) float64 24B 25.0 26.5 24.8</span>

<span class="sd">        # 2D data</span>

<span class="sd">        &gt;&gt;&gt; temperature_2d = xr.DataArray(np.random.rand(3, 4), dims=(&quot;y&quot;, &quot;x&quot;))</span>
<span class="sd">        &gt;&gt;&gt; dataset_2d = xr.Dataset({&quot;temperature&quot;: temperature_2d})</span>
<span class="sd">        &gt;&gt;&gt; dataset_2d</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 96B</span>
<span class="sd">        Dimensions:      (y: 3, x: 4)</span>
<span class="sd">        Dimensions without coordinates: y, x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (y, x) float64 96B 0.5488 0.7152 0.6028 ... 0.7917 0.5289</span>

<span class="sd">        # Expand the dataset with a new dimension called &quot;time&quot; using axis argument</span>

<span class="sd">        &gt;&gt;&gt; dataset_2d.expand_dims(dim=&quot;time&quot;, axis=2)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 96B</span>
<span class="sd">        Dimensions:      (y: 3, x: 4, time: 1)</span>
<span class="sd">        Dimensions without coordinates: y, x, time</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (y, x, time) float64 96B 0.5488 0.7152 0.6028 ... 0.7917 0.5289</span>

<span class="sd">        # Expand a scalar variable along a new dimension of the same name with and without creating a new index</span>

<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(coords={&quot;x&quot;: 0})</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 8B</span>
<span class="sd">        Dimensions:  ()</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            x        int64 8B 0</span>
<span class="sd">        Data variables:</span>
<span class="sd">            *empty*</span>

<span class="sd">        &gt;&gt;&gt; ds.expand_dims(&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 8B</span>
<span class="sd">        Dimensions:  (x: 1)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 8B 0</span>
<span class="sd">        Data variables:</span>
<span class="sd">            *empty*</span>

<span class="sd">        &gt;&gt;&gt; ds.expand_dims(&quot;x&quot;).indexes</span>
<span class="sd">        Indexes:</span>
<span class="sd">            x        Index([0], dtype=&#39;int64&#39;, name=&#39;x&#39;)</span>

<span class="sd">        &gt;&gt;&gt; ds.expand_dims(&quot;x&quot;, create_index_for_new_dim=False).indexes</span>
<span class="sd">        Indexes:</span>
<span class="sd">            *empty*</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.expand_dims</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="c1"># We&#39;re later going to modify dim in place; don&#39;t tamper with</span>
            <span class="c1"># the input</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;dim should be hashable or sequence of hashables or mapping&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dim</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dims should not contain duplicate values.&quot;</span><span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dim</span><span class="p">}</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim_kwargs</span><span class="p">,</span> <span class="s2">&quot;expand_dims&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">MutableMapping</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lengths of dim and axis should be identical.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dimension </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2"> already exists.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">d</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2"> already exists as coordinate or&quot;</span> <span class="s2">&quot; variable name.&quot;</span>
                <span class="p">)</span>

        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># If dim is a dict, then ensure that the values are either integers</span>
        <span class="c1"># or iterables.</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dim</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
                <span class="c1"># If the value for the new dimension is an iterable, then</span>
                <span class="c1"># save the coordinates to the variables dict, and set the</span>
                <span class="c1"># value within the dim dict to the length of the iterable</span>
                <span class="c1"># for later use.</span>

                <span class="k">if</span> <span class="n">create_index_for_new_dim</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">PandasIndex</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                    <span class="n">indexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
                    <span class="n">name_and_new_1d_var</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">create_variables</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">name_and_new_1d_var</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">Variable</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">k</span><span class="p">)}</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">name_and_new_1d_var</span><span class="p">)</span>
                <span class="n">coord_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">dim</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">pass</span>  <span class="c1"># Do nothing if the dimensions value is just an int</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The value of new dimension </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> must be &quot;</span> <span class="s2">&quot;an iterable or an int&quot;</span>
                <span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dim</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coord_names</span><span class="p">:</span>  <span class="c1"># Do not change coordinates</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">result_ndim</span> <span class="ow">or</span> <span class="n">result_ndim</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Axis </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2"> of variable </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> is out of bounds of the &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;expanded dimension size </span><span class="si">{</span><span class="n">result_ndim</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>

                    <span class="n">axis_pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">result_ndim</span> <span class="o">+</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_pos</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axis_pos</span><span class="p">)):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axis should not contain duplicate values&quot;</span><span class="p">)</span>
                    <span class="c1"># We need to sort them to make sure `axis` equals to the</span>
                    <span class="c1"># axis positions of the result array.</span>
                    <span class="n">zip_axis_dim</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">axis_pos</span><span class="p">,</span> <span class="n">dim</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

                    <span class="n">all_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">zip_axis_dim</span><span class="p">:</span>
                        <span class="n">all_dims</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">all_dims</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coord_names</span> <span class="ow">and</span> <span class="n">create_index_for_new_dim</span><span class="p">:</span>
                        <span class="c1"># If dims includes a label of a non-dimension coordinate,</span>
                        <span class="c1"># it will be promoted to a 1D coordinate with a single value.</span>
                        <span class="n">index</span><span class="p">,</span> <span class="n">index_vars</span> <span class="o">=</span> <span class="n">create_default_index_implicit</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                        <span class="n">indexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
                        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">index_vars</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">create_index_for_new_dim</span><span class="p">:</span>
                            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;No index created for dimension </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> because variable </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> is not a coordinate. &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;To create an index for </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">, please first call `.set_coords(&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&#39;)` on this object.&quot;</span><span class="p">,</span>
                                <span class="ne">UserWarning</span><span class="p">,</span>
                            <span class="p">)</span>

                        <span class="c1"># create 1D variable without creating a new index</span>
                        <span class="n">new_1d_var</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">new_1d_var</span><span class="p">})</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">append</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexes_kwargs</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set Dataset (multi-)indexes using one or more existing coordinates</span>
<span class="sd">        or variables.</span>

<span class="sd">        This legacy method is limited to pandas (multi-)indexes and</span>
<span class="sd">        1-dimensional &quot;dimension&quot; coordinates. See</span>
<span class="sd">        :py:meth:`~Dataset.set_xindex` for setting a pandas or a custom</span>
<span class="sd">        Xarray-compatible index from one or more arbitrary coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexes : {dim: index, ...}</span>
<span class="sd">            Mapping from names matching dimensions and values given</span>
<span class="sd">            by (lists of) the names of existing coordinates or variables to set</span>
<span class="sd">            as new (multi-)index.</span>
<span class="sd">        append : bool, default: False</span>
<span class="sd">            If True, append the supplied index(es) to the existing index(es).</span>
<span class="sd">            Otherwise replace the existing index(es) (default).</span>
<span class="sd">        **indexes_kwargs : optional</span>
<span class="sd">            The keyword arguments form of ``indexes``.</span>
<span class="sd">            One of indexes or indexes_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>
<span class="sd">            Another dataset, with this dataset&#39;s data but replaced coordinates.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; arr = xr.DataArray(</span>
<span class="sd">        ...     data=np.ones((2, 3)),</span>
<span class="sd">        ...     dims=[&quot;x&quot;, &quot;y&quot;],</span>
<span class="sd">        ...     coords={&quot;x&quot;: range(2), &quot;y&quot;: range(3), &quot;a&quot;: (&quot;x&quot;, [3, 4])},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;v&quot;: arr})</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 104B</span>
<span class="sd">        Dimensions:  (x: 2, y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 16B 0 1</span>
<span class="sd">          * y        (y) int64 24B 0 1 2</span>
<span class="sd">            a        (x) int64 16B 3 4</span>
<span class="sd">        Data variables:</span>
<span class="sd">            v        (x, y) float64 48B 1.0 1.0 1.0 1.0 1.0 1.0</span>
<span class="sd">        &gt;&gt;&gt; ds.set_index(x=&quot;a&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 88B</span>
<span class="sd">        Dimensions:  (x: 2, y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 16B 3 4</span>
<span class="sd">          * y        (y) int64 24B 0 1 2</span>
<span class="sd">        Data variables:</span>
<span class="sd">            v        (x, y) float64 48B 1.0 1.0 1.0 1.0 1.0 1.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.reset_index</span>
<span class="sd">        Dataset.set_xindex</span>
<span class="sd">        Dataset.swap_dims</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim_coords</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">indexes_kwargs</span><span class="p">,</span> <span class="s2">&quot;set_index&quot;</span><span class="p">)</span>

        <span class="n">new_indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">new_variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">drop_indexes</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">drop_variables</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">replace_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">all_var_names</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">_var_names</span> <span class="ow">in</span> <span class="n">dim_coords</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_var_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_var_names</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="n">var_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">_var_names</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_var_names</span><span class="p">)</span>

            <span class="n">invalid_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">var_names</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">invalid_vars</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">invalid_vars</span><span class="p">])</span>
                    <span class="o">+</span> <span class="s2">&quot; variable(s) do not exist&quot;</span>
                <span class="p">)</span>

            <span class="n">all_var_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">var_names</span><span class="p">)</span>
            <span class="n">drop_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">var_names</span><span class="p">)</span>

            <span class="c1"># drop any pre-existing index involved and its corresponding coordinates</span>
            <span class="n">index_coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">get_all_coords</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">all_index_coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">index_coord_names</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var_names</span><span class="p">:</span>
                <span class="n">all_index_coord_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">get_all_coords</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="n">drop_indexes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">all_index_coord_names</span><span class="p">)</span>
            <span class="n">drop_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">all_index_coord_names</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">append</span> <span class="ow">or</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">):</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="n">var_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span>
                <span class="c1"># an error with a better message will be raised for scalar variables</span>
                <span class="c1"># when creating the PandasIndex</span>
                <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="o">!=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;dimension mismatch: try setting an index for dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">!r}</span><span class="s2"> with &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;variable </span><span class="si">{</span><span class="n">var_name</span><span class="si">!r}</span><span class="s2"> that has dimensions </span><span class="si">{</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">PandasIndex</span><span class="o">.</span><span class="n">from_variables</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">var</span><span class="p">},</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
                <span class="n">idx_vars</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">create_variables</span><span class="p">({</span><span class="n">var_name</span><span class="p">:</span> <span class="n">var</span><span class="p">})</span>

                <span class="c1"># trick to preserve coordinate order in this case</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">:</span>
                    <span class="n">drop_variables</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
                    <span class="n">current_variables</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">index_coord_names</span>
                    <span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">current_variables</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">idx</span><span class="p">,</span> <span class="n">idx_vars</span> <span class="o">=</span> <span class="n">PandasMultiIndex</span><span class="o">.</span><span class="n">from_variables_maybe_expand</span><span class="p">(</span>
                    <span class="n">dim</span><span class="p">,</span>
                    <span class="n">current_variables</span><span class="p">,</span>
                    <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var_names</span><span class="p">},</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">idx</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="n">replace_dims</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span>

            <span class="n">new_indexes</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">idx_vars</span><span class="p">})</span>
            <span class="n">new_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx_vars</span><span class="p">)</span>

        <span class="c1"># re-add deindexed coordinates (convert to base variables)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">drop_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_variables</span>
                <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_var_names</span>
                <span class="ow">and</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span>
            <span class="p">):</span>
                <span class="n">new_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">to_base_variable</span><span class="p">()</span>

        <span class="n">indexes_</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drop_indexes</span>
        <span class="p">}</span>
        <span class="n">indexes_</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_indexes</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drop_variables</span>
        <span class="p">}</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_variables</span><span class="p">)</span>

        <span class="c1"># update dimensions if necessary, GH: 3512</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">d</span> <span class="ow">in</span> <span class="n">replace_dims</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
                <span class="n">new_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">replace_dims</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="n">new_dims</span><span class="p">)</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">-</span> <span class="n">drop_variables</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_variables</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes_</span>
        <span class="p">)</span>

    <span class="nd">@_deprecate_positional_args</span><span class="p">(</span><span class="s2">&quot;v2023.10.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reset_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dims_or_levels</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset the specified index(es) or multi-index level(s).</span>

<span class="sd">        This legacy method is specific to pandas (multi-)indexes and</span>
<span class="sd">        1-dimensional &quot;dimension&quot; coordinates. See the more generic</span>
<span class="sd">        :py:meth:`~Dataset.drop_indexes` and :py:meth:`~Dataset.set_xindex`</span>
<span class="sd">        method to respectively drop and set pandas or custom indexes for</span>
<span class="sd">        arbitrary coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dims_or_levels : Hashable or Sequence of Hashable</span>
<span class="sd">            Name(s) of the dimension(s) and/or multi-index level(s) that will</span>
<span class="sd">            be reset.</span>
<span class="sd">        drop : bool, default: False</span>
<span class="sd">            If True, remove the specified indexes and/or multi-index levels</span>
<span class="sd">            instead of extracting them as new coordinates (default: False).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>
<span class="sd">            Another dataset, with this dataset&#39;s data but replaced coordinates.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.set_index</span>
<span class="sd">        Dataset.set_xindex</span>
<span class="sd">        Dataset.drop_indexes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dims_or_levels</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dims_or_levels</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">dims_or_levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">dims_or_levels</span><span class="p">]</span>

        <span class="n">invalid_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims_or_levels</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">invalid_coords</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">invalid_coords</span><span class="p">)</span><span class="si">}</span><span class="s2"> are not coordinates with an index&quot;</span>
            <span class="p">)</span>

        <span class="n">drop_indexes</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">drop_variables</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">seen</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">new_indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">new_variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">drop_or_convert</span><span class="p">(</span><span class="n">var_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">drop</span><span class="p">:</span>
                <span class="n">drop_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">var_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">base_vars</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">to_base_variable</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var_names</span>
                <span class="p">}</span>
                <span class="n">new_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">base_vars</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dims_or_levels</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

            <span class="n">idx_var_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">get_all_coords</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
            <span class="n">drop_indexes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx_var_names</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">PandasMultiIndex</span><span class="p">):</span>
                <span class="c1"># special case for pd.MultiIndex</span>
                <span class="n">level_names</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span>
                <span class="n">keep_level_vars</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">level_names</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims_or_levels</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims_or_levels</span> <span class="ow">and</span> <span class="n">keep_level_vars</span><span class="p">:</span>
                    <span class="c1"># do not drop the multi-index completely</span>
                    <span class="c1"># instead replace it by a new (multi-)index with dropped level(s)</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">keep_levels</span><span class="p">(</span><span class="n">keep_level_vars</span><span class="p">)</span>
                    <span class="n">idx_vars</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">create_variables</span><span class="p">(</span><span class="n">keep_level_vars</span><span class="p">)</span>
                    <span class="n">new_indexes</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">idx_vars</span><span class="p">})</span>
                    <span class="n">new_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx_vars</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">PandasMultiIndex</span><span class="p">):</span>
                        <span class="c1"># multi-index reduced to single index</span>
                        <span class="c1"># backward compatibility: unique level coordinate renamed to dimension</span>
                        <span class="n">drop_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">keep_level_vars</span><span class="p">)</span>
                    <span class="n">drop_or_convert</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">level_names</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep_level_vars</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># always drop the multi-index dimension variable</span>
                    <span class="n">drop_variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
                    <span class="n">drop_or_convert</span><span class="p">(</span><span class="n">level_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">drop_or_convert</span><span class="p">(</span><span class="n">idx_var_names</span><span class="p">)</span>

        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drop_indexes</span><span class="p">}</span>
        <span class="n">indexes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_indexes</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drop_variables</span>
        <span class="p">}</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_variables</span><span class="p">)</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">-</span> <span class="n">drop_variables</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_xindex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coord_names</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="n">index_cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">Index</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">options</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a new, Xarray-compatible index from one or more existing</span>
<span class="sd">        coordinate(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord_names : str or list</span>
<span class="sd">            Name(s) of the coordinate(s) used to build the index.</span>
<span class="sd">            If several names are given, their order matters.</span>
<span class="sd">        index_cls : subclass of :class:`~xarray.indexes.Index`, optional</span>
<span class="sd">            The type of index to create. By default, try setting</span>
<span class="sd">            a ``PandasIndex`` if ``len(coord_names) == 1``,</span>
<span class="sd">            otherwise a ``PandasMultiIndex``.</span>
<span class="sd">        **options</span>
<span class="sd">            Options passed to the index constructor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>
<span class="sd">            Another dataset, with this dataset&#39;s data and with a new index.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the Sequence check is required for mypy</span>
        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">coord_names</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">coord_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord_names</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">index_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">index_cls</span> <span class="o">=</span> <span class="n">PandasIndex</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index_cls</span> <span class="o">=</span> <span class="n">PandasMultiIndex</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">index_cls</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">index_cls</span><span class="si">}</span><span class="s2"> is not a subclass of xarray.Index&quot;</span><span class="p">)</span>

        <span class="n">invalid_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">coord_names</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span>

        <span class="k">if</span> <span class="n">invalid_coords</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;invalid coordinate(s)&quot;</span><span class="p">]</span>
            <span class="n">no_vars</span> <span class="o">=</span> <span class="n">invalid_coords</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span>
            <span class="n">data_vars</span> <span class="o">=</span> <span class="n">invalid_coords</span> <span class="o">-</span> <span class="n">no_vars</span>
            <span class="k">if</span> <span class="n">no_vars</span><span class="p">:</span>
                <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;those variables don&#39;t exist: </span><span class="si">{</span><span class="n">no_vars</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data_vars</span><span class="p">:</span>
                <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;those variables are data variables: </span><span class="si">{</span><span class="n">data_vars</span><span class="si">}</span><span class="s2">, use `set_coords` first&quot;</span>
                <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

        <span class="c1"># we could be more clever here (e.g., drop-in index replacement if index</span>
        <span class="c1"># coordinates do not conflict), but let&#39;s not allow this for now</span>
        <span class="n">indexed_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">coord_names</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">indexed_coords</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;those coordinates already have an index: </span><span class="si">{</span><span class="n">indexed_coords</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">coord_vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">coord_names</span><span class="p">}</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">index_cls</span><span class="o">.</span><span class="n">from_variables</span><span class="p">(</span><span class="n">coord_vars</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>

        <span class="n">new_coord_vars</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">create_variables</span><span class="p">(</span><span class="n">coord_vars</span><span class="p">)</span>

        <span class="c1"># special case for setting a pandas multi-index from level coordinates</span>
        <span class="c1"># TODO: remove it once we depreciate pandas multi-index dimension (tuple</span>
        <span class="c1"># elements) coordinate</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">PandasMultiIndex</span><span class="p">):</span>
            <span class="n">coord_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span><span class="o">.</span><span class="n">dim</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">coord_names</span><span class="p">)</span>

        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coord_names</span><span class="p">)</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">new_coord_vars</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_coord_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># reorder variables and indexes so that coordinates having the same</span>
            <span class="c1"># index are next to each other</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coord_names</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

            <span class="n">indexes</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coord_names</span><span class="p">:</span>
                    <span class="n">indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">coord_names</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_coord_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="n">indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">coord_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">coord_names</span><span class="p">),</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">reorder_levels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim_order</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="n">Hashable</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">dim_order_kwargs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="n">Hashable</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rearrange index levels using input order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim_order : dict-like of Hashable to Sequence of int or Hashable, optional</span>
<span class="sd">            Mapping from names matching dimensions and values given</span>
<span class="sd">            by lists representing new level orders. Every given dimension</span>
<span class="sd">            must have a multi-index.</span>
<span class="sd">        **dim_order_kwargs : Sequence of int or Hashable, optional</span>
<span class="sd">            The keyword arguments form of ``dim_order``.</span>
<span class="sd">            One of dim_order or dim_order_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>
<span class="sd">            Another dataset, with this dataset&#39;s data but replaced</span>
<span class="sd">            coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim_order</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">dim_order</span><span class="p">,</span> <span class="n">dim_order_kwargs</span><span class="p">,</span> <span class="s2">&quot;reorder_levels&quot;</span><span class="p">)</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>
        <span class="n">new_indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">new_variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">IndexVariable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">dim_order</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">PandasMultiIndex</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;coordinate </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> has no MultiIndex&quot;</span><span class="p">)</span>

            <span class="n">level_vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">order</span><span class="p">}</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">(</span><span class="n">level_vars</span><span class="p">)</span>
            <span class="n">idx_vars</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">create_variables</span><span class="p">(</span><span class="n">level_vars</span><span class="p">)</span>
            <span class="n">new_indexes</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">idx_vars</span><span class="p">})</span>
            <span class="n">new_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx_vars</span><span class="p">)</span>

        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_indexes</span><span class="p">}</span>
        <span class="n">indexes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_indexes</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_variables</span><span class="p">}</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_variables</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_stack_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">,</span>
        <span class="n">multi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">create_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Used by stack and unstack to get one pandas (multi-)index among</span>
<span class="sd">        the indexed coordinates along dimension `dim`.</span>

<span class="sd">        If exactly one index is found, return it with its corresponding</span>
<span class="sd">        coordinate variables(s), otherwise return None and an empty dict.</span>

<span class="sd">        If `create_index=True`, create a new index if none is found or raise</span>
<span class="sd">        an error if multiple indexes are found.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stack_index</span><span class="p">:</span> <span class="n">Index</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">stack_coords</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">dim</span>
                <span class="ow">and</span> <span class="p">(</span>
                    <span class="c1"># stack: must be a single coordinate index</span>
                    <span class="ow">not</span> <span class="n">multi</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">is_multi</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="c1"># unstack: must be an index that implements .unstack</span>
                    <span class="ow">or</span> <span class="n">multi</span>
                    <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">unstack</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Index</span><span class="o">.</span><span class="n">unstack</span>
                <span class="p">)</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">stack_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">stack_index</span><span class="p">:</span>
                    <span class="c1"># more than one index found, stop</span>
                    <span class="k">if</span> <span class="n">create_index</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;cannot stack dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">!r}</span><span class="s2"> with `create_index=True` &quot;</span>
                            <span class="s2">&quot;and with more than one index found along that dimension&quot;</span>
                        <span class="p">)</span>
                    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="p">{}</span>
                <span class="n">stack_index</span> <span class="o">=</span> <span class="n">index</span>
                <span class="n">stack_coords</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="k">if</span> <span class="n">create_index</span> <span class="ow">and</span> <span class="n">stack_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">_get_virtual_variable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">)</span>
            <span class="c1"># dummy index (only `stack_coords` will be used to construct the multi-index)</span>
            <span class="n">stack_index</span> <span class="o">=</span> <span class="n">PandasIndex</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim</span><span class="p">)</span>
            <span class="n">stack_coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="n">var</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">stack_index</span><span class="p">,</span> <span class="n">stack_coords</span>

    <span class="k">def</span> <span class="nf">_stack_once</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span> <span class="o">|</span> <span class="n">EllipsisType</span><span class="p">],</span>
        <span class="n">new_dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="n">index_cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">Index</span><span class="p">],</span>
        <span class="n">create_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="o">==</span> <span class="o">...</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please use [...] for dims, rather than just ...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="o">...</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">infix_dims</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span>

        <span class="n">new_variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">stacked_var_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">drop_indexes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">d</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">):</span>
                <span class="n">add_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
                <span class="n">vdims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">+</span> <span class="n">add_dims</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">vdims</span><span class="p">]</span>
                <span class="n">exp_var</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="n">vdims</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
                <span class="n">stacked_var</span> <span class="o">=</span> <span class="n">exp_var</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">new_dim</span><span class="p">:</span> <span class="n">dims</span><span class="p">})</span>
                <span class="n">new_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">stacked_var</span>
                <span class="n">stacked_var_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># drop indexes of stacked coordinates (if any)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">stacked_var_names</span><span class="p">:</span>
            <span class="n">drop_indexes</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">get_all_coords</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">))</span>

        <span class="n">new_indexes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">new_coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">create_index</span> <span class="ow">or</span> <span class="n">create_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">product_vars</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
                <span class="n">idx</span><span class="p">,</span> <span class="n">idx_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_stack_index</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">create_index</span><span class="o">=</span><span class="n">create_index</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">product_vars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx_vars</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">product_vars</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">index_cls</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">product_vars</span><span class="p">,</span> <span class="n">new_dim</span><span class="p">)</span>
                <span class="n">new_indexes</span><span class="p">[</span><span class="n">new_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
                <span class="n">new_indexes</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">product_vars</span><span class="p">})</span>
                <span class="n">idx_vars</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">create_variables</span><span class="p">(</span><span class="n">product_vars</span><span class="p">)</span>
                <span class="c1"># keep consistent multi-index coordinate order</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">idx_vars</span><span class="p">:</span>
                    <span class="n">new_variables</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">new_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx_vars</span><span class="p">)</span>
                <span class="n">new_coord_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx_vars</span><span class="p">)</span>

        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drop_indexes</span><span class="p">}</span>
        <span class="n">indexes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_indexes</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">new_variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">new_coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

    <span class="nd">@partial</span><span class="p">(</span><span class="n">deprecate_dims</span><span class="p">,</span> <span class="n">old_name</span><span class="o">=</span><span class="s2">&quot;dimensions&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">stack</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span> <span class="o">|</span> <span class="n">EllipsisType</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">create_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">index_cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="n">PandasMultiIndex</span><span class="p">,</span>
        <span class="o">**</span><span class="n">dim_kwargs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span> <span class="o">|</span> <span class="n">EllipsisType</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stack any number of existing dimensions into a single new dimension.</span>

<span class="sd">        New dimensions will be added at the end, and by default the corresponding</span>
<span class="sd">        coordinate variables will be combined into a MultiIndex.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : mapping of hashable to sequence of hashable</span>
<span class="sd">            Mapping of the form `new_name=(dim1, dim2, ...)`. Names of new</span>
<span class="sd">            dimensions, and the existing dimensions that they replace. An</span>
<span class="sd">            ellipsis (`...`) will be replaced by all unlisted dimensions.</span>
<span class="sd">            Passing a list containing an ellipsis (`stacked_dim=[...]`) will stack over</span>
<span class="sd">            all dimensions.</span>
<span class="sd">        create_index : bool or None, default: True</span>

<span class="sd">            - True: create a multi-index for each of the stacked dimensions.</span>
<span class="sd">            - False: don&#39;t create any index.</span>
<span class="sd">            - None. create a multi-index only if exactly one single (1-d) coordinate</span>
<span class="sd">              index is found for every dimension to stack.</span>

<span class="sd">        index_cls: Index-class, default: PandasMultiIndex</span>
<span class="sd">            Can be used to pass a custom multi-index type (must be an Xarray index that</span>
<span class="sd">            implements `.stack()`). By default, a pandas multi-index wrapper is used.</span>
<span class="sd">        **dim_kwargs</span>
<span class="sd">            The keyword arguments form of ``dim``.</span>
<span class="sd">            One of dim or dim_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stacked : Dataset</span>
<span class="sd">            Dataset with stacked data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.unstack</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim_kwargs</span><span class="p">,</span> <span class="s2">&quot;stack&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">new_dim</span><span class="p">,</span> <span class="n">dims</span> <span class="ow">in</span> <span class="n">dim</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_stack_once</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">new_dim</span><span class="p">,</span> <span class="n">index_cls</span><span class="p">,</span> <span class="n">create_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">to_stacked_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="n">sample_dims</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="n">variable_dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Combine variables of differing dimensionality into a DataArray</span>
<span class="sd">        without broadcasting.</span>

<span class="sd">        This method is similar to Dataset.to_dataarray but does not broadcast the</span>
<span class="sd">        variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_dim : hashable</span>
<span class="sd">            Name of the new stacked coordinate</span>
<span class="sd">        sample_dims : Collection of hashables</span>
<span class="sd">            List of dimensions that **will not** be stacked. Each array in the</span>
<span class="sd">            dataset must share these dimensions. For machine learning</span>
<span class="sd">            applications, these define the dimensions over which samples are</span>
<span class="sd">            drawn.</span>
<span class="sd">        variable_dim : hashable, default: &quot;variable&quot;</span>
<span class="sd">            Name of the level in the stacked coordinate which corresponds to</span>
<span class="sd">            the variables.</span>
<span class="sd">        name : hashable, optional</span>
<span class="sd">            Name of the new data array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stacked : DataArray</span>
<span class="sd">            DataArray with the specified dimensions and data variables</span>
<span class="sd">            stacked together. The stacked coordinate is named ``new_dim``</span>
<span class="sd">            and represented by a MultiIndex object with a level containing the</span>
<span class="sd">            data variable names. The name of this level is controlled using</span>
<span class="sd">            the ``variable_dim`` argument.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.to_dataarray</span>
<span class="sd">        Dataset.stack</span>
<span class="sd">        DataArray.to_unstacked_dataset</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; data = xr.Dataset(</span>
<span class="sd">        ...     data_vars={</span>
<span class="sd">        ...         &quot;a&quot;: ((&quot;x&quot;, &quot;y&quot;), [[0, 1, 2], [3, 4, 5]]),</span>
<span class="sd">        ...         &quot;b&quot;: (&quot;x&quot;, [6, 7]),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;y&quot;: [&quot;u&quot;, &quot;v&quot;, &quot;w&quot;]},</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; data</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 76B</span>
<span class="sd">        Dimensions:  (x: 2, y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) &lt;U1 12B &#39;u&#39; &#39;v&#39; &#39;w&#39;</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x, y) int64 48B 0 1 2 3 4 5</span>
<span class="sd">            b        (x) int64 16B 6 7</span>

<span class="sd">        &gt;&gt;&gt; data.to_stacked_array(&quot;z&quot;, sample_dims=[&quot;x&quot;])</span>
<span class="sd">        &lt;xarray.DataArray &#39;a&#39; (x: 2, z: 4)&gt; Size: 64B</span>
<span class="sd">        array([[0, 1, 2, 6],</span>
<span class="sd">               [3, 4, 5, 7]])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * z         (z) object 32B MultiIndex</span>
<span class="sd">          * variable  (z) &lt;U1 16B &#39;a&#39; &#39;a&#39; &#39;a&#39; &#39;b&#39;</span>
<span class="sd">          * y         (z) object 32B &#39;u&#39; &#39;v&#39; &#39;w&#39; nan</span>
<span class="sd">        Dimensions without coordinates: x</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.concat</span> <span class="kn">import</span> <span class="n">concat</span>

        <span class="n">stacking_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sample_dims</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">missing_sample_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sample_dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">missing_sample_dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Variables in the dataset must contain all ``sample_dims`` &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">sample_dims</span><span class="si">!r}</span><span class="s2">) but &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; misses </span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="w"> </span><span class="n">missing_sample_dims</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">def</span> <span class="nf">stack_dataarray</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
            <span class="c1"># add missing dims/ coords and the name of the variable</span>

            <span class="n">missing_stack_coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">variable_dim</span><span class="p">:</span> <span class="n">da</span><span class="o">.</span><span class="n">name</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">stacking_dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
                <span class="n">missing_stack_coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">missing_stack_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">missing_stack_coords</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span>
                <span class="n">da</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="o">**</span><span class="n">missing_stack_coords</span><span class="p">)</span>
                <span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">missing_stack_dims</span><span class="p">)</span>
                <span class="o">.</span><span class="n">stack</span><span class="p">({</span><span class="n">new_dim</span><span class="p">:</span> <span class="p">(</span><span class="n">variable_dim</span><span class="p">,)</span> <span class="o">+</span> <span class="n">stacking_dims</span><span class="p">})</span>
            <span class="p">)</span>

        <span class="c1"># concatenate the arrays</span>
        <span class="n">stackable_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">stack_dataarray</span><span class="p">(</span><span class="n">da</span><span class="p">)</span> <span class="k">for</span> <span class="n">da</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">data_array</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span><span class="n">stackable_vars</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">new_dim</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_array</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">return</span> <span class="n">data_array</span>

    <span class="k">def</span> <span class="nf">_unstack_once</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="n">index_and_vars</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]],</span>
        <span class="n">fill_value</span><span class="p">,</span>
        <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">index_vars</span> <span class="o">=</span> <span class="n">index_and_vars</span>
        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">}</span>

        <span class="n">new_indexes</span><span class="p">,</span> <span class="n">clean_index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">unstack</span><span class="p">()</span>
        <span class="n">indexes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_indexes</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">new_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">create_variables</span><span class="p">(</span><span class="n">index_vars</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">index_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
                        <span class="n">fill_value_</span> <span class="o">=</span> <span class="n">fill_value</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fill_value_</span> <span class="o">=</span> <span class="n">fill_value</span>

                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">_unstack_once</span><span class="p">(</span>
                        <span class="n">index</span><span class="o">=</span><span class="n">clean_index</span><span class="p">,</span>
                        <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
                        <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value_</span><span class="p">,</span>
                        <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="n">dim</span><span class="p">}</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_indexes</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_unstack_full_reindex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="n">index_and_vars</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]],</span>
        <span class="n">fill_value</span><span class="p">,</span>
        <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">index_vars</span> <span class="o">=</span> <span class="n">index_and_vars</span>
        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">}</span>

        <span class="n">new_indexes</span><span class="p">,</span> <span class="n">clean_index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">unstack</span><span class="p">()</span>
        <span class="n">indexes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_indexes</span><span class="p">)</span>

        <span class="n">new_index_variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">new_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_index_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">create_variables</span><span class="p">(</span><span class="n">index_vars</span><span class="p">))</span>

        <span class="n">new_dim_sizes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_index_variables</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_index_variables</span><span class="p">)</span>

        <span class="c1"># take a shortcut in case the MultiIndex was not modified.</span>
        <span class="n">full_idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span>
            <span class="n">clean_index</span><span class="o">.</span><span class="n">levels</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">clean_index</span><span class="o">.</span><span class="n">names</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">clean_index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">full_idx</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: we may depreciate implicit re-indexing with a pandas.MultiIndex</span>
            <span class="n">xr_full_idx</span> <span class="o">=</span> <span class="n">PandasMultiIndex</span><span class="p">(</span><span class="n">full_idx</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
            <span class="n">indexers</span> <span class="o">=</span> <span class="n">Indexes</span><span class="p">(</span>
                <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">xr_full_idx</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">index_vars</span><span class="p">},</span>
                <span class="n">xr_full_idx</span><span class="o">.</span><span class="n">create_variables</span><span class="p">(</span><span class="n">index_vars</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex</span><span class="p">(</span>
                <span class="n">indexers</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">index_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">unstack</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">new_dim_sizes</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="n">dim</span><span class="p">}</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_dim_sizes</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

    <span class="nd">@_deprecate_positional_args</span><span class="p">(</span><span class="s2">&quot;v2023.10.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">unstack</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">xrdtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unstack existing dimensions corresponding to MultiIndexes into</span>
<span class="sd">        multiple new dimensions.</span>

<span class="sd">        New dimensions will be added at the end.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : str, Iterable of Hashable or None, optional</span>
<span class="sd">            Dimension(s) over which to unstack. By default unstacks all</span>
<span class="sd">            MultiIndexes.</span>
<span class="sd">        fill_value : scalar or dict-like, default: nan</span>
<span class="sd">            value to be filled. If a dict-like, maps variable names to</span>
<span class="sd">            fill values. If not provided or if the dict-like does not</span>
<span class="sd">            contain all variables, the dtype&#39;s NA value will be used.</span>
<span class="sd">        sparse : bool, default: False</span>
<span class="sd">            use sparse-array if True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unstacked : Dataset</span>
<span class="sd">            Dataset with unstacked data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.stack</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

            <span class="n">missing_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">missing_dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Dimensions </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missing_dims</span><span class="p">)</span><span class="si">}</span><span class="s2"> not found in data dimensions </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># each specified dimension must have exactly one multi-index</span>
        <span class="n">stacked_indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="n">idx</span><span class="p">,</span> <span class="n">idx_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_stack_index</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">multi</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">stacked_indexes</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">,</span> <span class="n">idx_vars</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">stacked_indexes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">non_multi_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">stacked_indexes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">non_multi_dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;cannot unstack dimensions that do not &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;have exactly one multi-index: </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">non_multi_dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># we want to avoid allocating an object-dtype ndarray for a MultiIndex,</span>
        <span class="c1"># so we can&#39;t just access self.variables[v].data for every variable.</span>
        <span class="c1"># We only check the non-index variables.</span>
        <span class="c1"># https://github.com/pydata/xarray/issues/5902</span>
        <span class="n">nonindexes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># Notes for each of these cases:</span>
        <span class="c1"># 1. Dask arrays don&#39;t support assignment by index, which the fast unstack</span>
        <span class="c1">#    function requires.</span>
        <span class="c1">#    https://github.com/pydata/xarray/pull/4746#issuecomment-753282125</span>
        <span class="c1"># 2. Sparse doesn&#39;t currently support (though we could special-case it)</span>
        <span class="c1">#    https://github.com/pydata/sparse/issues/422</span>
        <span class="c1"># 3. pint requires checking if it&#39;s a NumPy array until</span>
        <span class="c1">#    https://github.com/pydata/xarray/pull/4751 is resolved,</span>
        <span class="c1">#    Once that is resolved, explicitly exclude pint arrays.</span>
        <span class="c1">#    pint doesn&#39;t implement `np.full_like` in a way that&#39;s</span>
        <span class="c1">#    currently compatible.</span>
        <span class="n">sparse_array_type</span> <span class="o">=</span> <span class="n">array_type</span><span class="p">(</span><span class="s2">&quot;sparse&quot;</span><span class="p">)</span>
        <span class="n">needs_full_reindex</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
            <span class="n">is_duck_dask_array</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sparse_array_type</span><span class="p">)</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nonindexes</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">needs_full_reindex</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_unstack_full_reindex</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">,</span> <span class="n">stacked_indexes</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">sparse</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_unstack_once</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">stacked_indexes</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">sparse</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">CoercibleMapping</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update this dataset&#39;s variables with those from another dataset.</span>

<span class="sd">        Just like :py:meth:`dict.update` this is a in-place operation.</span>
<span class="sd">        For a non-inplace version, see :py:meth:`Dataset.merge`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Dataset or mapping</span>
<span class="sd">            Variables with which to update this dataset. One of:</span>

<span class="sd">            - Dataset</span>
<span class="sd">            - mapping {var name: DataArray}</span>
<span class="sd">            - mapping {var name: Variable}</span>
<span class="sd">            - mapping {var name: (dimension name, array-like)}</span>
<span class="sd">            - mapping {var name: (tuple of dimension names, array-like)}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        updated : Dataset</span>
<span class="sd">            Updated dataset. Note that since the update is in-place this is the input</span>
<span class="sd">            dataset.</span>

<span class="sd">            It is deprecated since version 0.17 and scheduled to be removed in 0.21.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any dimensions would have inconsistent sizes in the updated</span>
<span class="sd">            dataset.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.assign</span>
<span class="sd">        Dataset.merge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">merge_result</span> <span class="o">=</span> <span class="n">dataset_update_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">merge_result</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">CoercibleMapping</span> <span class="o">|</span> <span class="n">DataArray</span><span class="p">,</span>
        <span class="n">overwrite_vars</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(),</span>
        <span class="n">compat</span><span class="p">:</span> <span class="n">CompatOptions</span> <span class="o">=</span> <span class="s2">&quot;no_conflicts&quot;</span><span class="p">,</span>
        <span class="n">join</span><span class="p">:</span> <span class="n">JoinOptions</span> <span class="o">=</span> <span class="s2">&quot;outer&quot;</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">xrdtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="n">combine_attrs</span><span class="p">:</span> <span class="n">CombineAttrsOptions</span> <span class="o">=</span> <span class="s2">&quot;override&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge the arrays of two datasets into a single dataset.</span>

<span class="sd">        This method generally does not allow for overriding data, with the</span>
<span class="sd">        exception of attributes, which are ignored on the second dataset.</span>
<span class="sd">        Variables with the same name are checked for conflicts via the equals</span>
<span class="sd">        or identical methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Dataset or mapping</span>
<span class="sd">            Dataset or variables to merge with this dataset.</span>
<span class="sd">        overwrite_vars : hashable or iterable of hashable, optional</span>
<span class="sd">            If provided, update variables of these name(s) without checking for</span>
<span class="sd">            conflicts in this dataset.</span>
<span class="sd">        compat : {&quot;identical&quot;, &quot;equals&quot;, &quot;broadcast_equals&quot;, \</span>
<span class="sd">                  &quot;no_conflicts&quot;, &quot;override&quot;, &quot;minimal&quot;}, default: &quot;no_conflicts&quot;</span>
<span class="sd">            String indicating how to compare variables of the same name for</span>
<span class="sd">            potential conflicts:</span>

<span class="sd">            - &#39;identical&#39;: all values, dimensions and attributes must be the</span>
<span class="sd">              same.</span>
<span class="sd">            - &#39;equals&#39;: all values and dimensions must be the same.</span>
<span class="sd">            - &#39;broadcast_equals&#39;: all values must be equal when variables are</span>
<span class="sd">              broadcast against each other to ensure common dimensions.</span>
<span class="sd">            - &#39;no_conflicts&#39;: only values which are not null in both datasets</span>
<span class="sd">              must be equal. The returned dataset then contains the combination</span>
<span class="sd">              of all non-null values.</span>
<span class="sd">            - &#39;override&#39;: skip comparing and pick variable from first dataset</span>
<span class="sd">            - &#39;minimal&#39;: drop conflicting coordinates</span>

<span class="sd">        join : {&quot;outer&quot;, &quot;inner&quot;, &quot;left&quot;, &quot;right&quot;, &quot;exact&quot;, &quot;override&quot;}, \</span>
<span class="sd">               default: &quot;outer&quot;</span>
<span class="sd">            Method for joining ``self`` and ``other`` along shared dimensions:</span>

<span class="sd">            - &#39;outer&#39;: use the union of the indexes</span>
<span class="sd">            - &#39;inner&#39;: use the intersection of the indexes</span>
<span class="sd">            - &#39;left&#39;: use indexes from ``self``</span>
<span class="sd">            - &#39;right&#39;: use indexes from ``other``</span>
<span class="sd">            - &#39;exact&#39;: error instead of aligning non-equal indexes</span>
<span class="sd">            - &#39;override&#39;: use indexes from ``self`` that are the same size</span>
<span class="sd">              as those of ``other`` in that dimension</span>

<span class="sd">        fill_value : scalar or dict-like, optional</span>
<span class="sd">            Value to use for newly missing values. If a dict-like, maps</span>
<span class="sd">            variable names (including coordinates) to fill values.</span>
<span class="sd">        combine_attrs : {&quot;drop&quot;, &quot;identical&quot;, &quot;no_conflicts&quot;, &quot;drop_conflicts&quot;, \</span>
<span class="sd">                         &quot;override&quot;} or callable, default: &quot;override&quot;</span>
<span class="sd">            A callable or a string indicating how to combine attrs of the objects being</span>
<span class="sd">            merged:</span>

<span class="sd">            - &quot;drop&quot;: empty attrs on returned Dataset.</span>
<span class="sd">            - &quot;identical&quot;: all attrs must be the same on every object.</span>
<span class="sd">            - &quot;no_conflicts&quot;: attrs from all objects are combined, any that have</span>
<span class="sd">              the same name must also have the same value.</span>
<span class="sd">            - &quot;drop_conflicts&quot;: attrs from all objects are combined, any that have</span>
<span class="sd">              the same name but different values are dropped.</span>
<span class="sd">            - &quot;override&quot;: skip comparing and copy attrs from the first dataset to</span>
<span class="sd">              the result.</span>

<span class="sd">            If a callable, it must expect a sequence of ``attrs`` dicts and a context object</span>
<span class="sd">            as its only parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged : Dataset</span>
<span class="sd">            Merged dataset.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        MergeError</span>
<span class="sd">            If any variables conflict (see ``compat``).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.update</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">)</span> <span class="k">else</span> <span class="n">other</span>
        <span class="n">merge_result</span> <span class="o">=</span> <span class="n">dataset_merge_method</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">overwrite_vars</span><span class="o">=</span><span class="n">overwrite_vars</span><span class="p">,</span>
            <span class="n">compat</span><span class="o">=</span><span class="n">compat</span><span class="p">,</span>
            <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">combine_attrs</span><span class="o">=</span><span class="n">combine_attrs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="o">**</span><span class="n">merge_result</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_assert_all_in_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="n">virtual_okay</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bad_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">virtual_okay</span><span class="p">:</span>
            <span class="n">bad_names</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_variables</span>
        <span class="k">if</span> <span class="n">bad_names</span><span class="p">:</span>
            <span class="n">ordered_bad_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">bad_names</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;These variables cannot be found in this dataset: </span><span class="si">{</span><span class="n">ordered_bad_names</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop_vars</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Self</span><span class="p">],</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">ErrorOptions</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Drop variables from this dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : Hashable or iterable of Hashable or Callable</span>
<span class="sd">            Name(s) of variables to drop. If a Callable, this object is passed as its</span>
<span class="sd">            only argument and its result is used.</span>
<span class="sd">        errors : {&quot;raise&quot;, &quot;ignore&quot;}, default: &quot;raise&quot;</span>
<span class="sd">            If &#39;raise&#39;, raises a ValueError error if any of the variable</span>
<span class="sd">            passed are not in the dataset. If &#39;ignore&#39;, any given names that are in the</span>
<span class="sd">            dataset are dropped and no error is raised.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; dataset = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;temperature&quot;: (</span>
<span class="sd">        ...             [&quot;time&quot;, &quot;latitude&quot;, &quot;longitude&quot;],</span>
<span class="sd">        ...             [[[25.5, 26.3], [27.1, 28.0]]],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...         &quot;humidity&quot;: (</span>
<span class="sd">        ...             [&quot;time&quot;, &quot;latitude&quot;, &quot;longitude&quot;],</span>
<span class="sd">        ...             [[[65.0, 63.8], [58.2, 59.6]]],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...         &quot;wind_speed&quot;: (</span>
<span class="sd">        ...             [&quot;time&quot;, &quot;latitude&quot;, &quot;longitude&quot;],</span>
<span class="sd">        ...             [[[10.2, 8.5], [12.1, 9.8]]],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={</span>
<span class="sd">        ...         &quot;time&quot;: pd.date_range(&quot;2023-07-01&quot;, periods=1),</span>
<span class="sd">        ...         &quot;latitude&quot;: [40.0, 40.2],</span>
<span class="sd">        ...         &quot;longitude&quot;: [-75.0, -74.8],</span>
<span class="sd">        ...     },</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; dataset</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 136B</span>
<span class="sd">        Dimensions:      (time: 1, latitude: 2, longitude: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) datetime64[ns] 8B 2023-07-01</span>
<span class="sd">          * latitude     (latitude) float64 16B 40.0 40.2</span>
<span class="sd">          * longitude    (longitude) float64 16B -75.0 -74.8</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time, latitude, longitude) float64 32B 25.5 26.3 27.1 28.0</span>
<span class="sd">            humidity     (time, latitude, longitude) float64 32B 65.0 63.8 58.2 59.6</span>
<span class="sd">            wind_speed   (time, latitude, longitude) float64 32B 10.2 8.5 12.1 9.8</span>

<span class="sd">        Drop the &#39;humidity&#39; variable</span>

<span class="sd">        &gt;&gt;&gt; dataset.drop_vars([&quot;humidity&quot;])</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 104B</span>
<span class="sd">        Dimensions:      (time: 1, latitude: 2, longitude: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) datetime64[ns] 8B 2023-07-01</span>
<span class="sd">          * latitude     (latitude) float64 16B 40.0 40.2</span>
<span class="sd">          * longitude    (longitude) float64 16B -75.0 -74.8</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time, latitude, longitude) float64 32B 25.5 26.3 27.1 28.0</span>
<span class="sd">            wind_speed   (time, latitude, longitude) float64 32B 10.2 8.5 12.1 9.8</span>

<span class="sd">        Drop the &#39;humidity&#39;, &#39;temperature&#39; variables</span>

<span class="sd">        &gt;&gt;&gt; dataset.drop_vars([&quot;humidity&quot;, &quot;temperature&quot;])</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 72B</span>
<span class="sd">        Dimensions:     (time: 1, latitude: 2, longitude: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time        (time) datetime64[ns] 8B 2023-07-01</span>
<span class="sd">          * latitude    (latitude) float64 16B 40.0 40.2</span>
<span class="sd">          * longitude   (longitude) float64 16B -75.0 -74.8</span>
<span class="sd">        Data variables:</span>
<span class="sd">            wind_speed  (time, latitude, longitude) float64 32B 10.2 8.5 12.1 9.8</span>

<span class="sd">        Drop all indexes</span>

<span class="sd">        &gt;&gt;&gt; dataset.drop_vars(lambda x: x.indexes)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 96B</span>
<span class="sd">        Dimensions:      (time: 1, latitude: 2, longitude: 2)</span>
<span class="sd">        Dimensions without coordinates: time, latitude, longitude</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time, latitude, longitude) float64 32B 25.5 26.3 27.1 28.0</span>
<span class="sd">            humidity     (time, latitude, longitude) float64 32B 65.0 63.8 58.2 59.6</span>
<span class="sd">            wind_speed   (time, latitude, longitude) float64 32B 10.2 8.5 12.1 9.8</span>

<span class="sd">        Attempt to drop non-existent variable with errors=&quot;ignore&quot;</span>

<span class="sd">        &gt;&gt;&gt; dataset.drop_vars([&quot;pressure&quot;], errors=&quot;ignore&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 136B</span>
<span class="sd">        Dimensions:      (time: 1, latitude: 2, longitude: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) datetime64[ns] 8B 2023-07-01</span>
<span class="sd">          * latitude     (latitude) float64 16B 40.0 40.2</span>
<span class="sd">          * longitude    (longitude) float64 16B -75.0 -74.8</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time, latitude, longitude) float64 32B 25.5 26.3 27.1 28.0</span>
<span class="sd">            humidity     (time, latitude, longitude) float64 32B 65.0 63.8 58.2 59.6</span>
<span class="sd">            wind_speed   (time, latitude, longitude) float64 32B 10.2 8.5 12.1 9.8</span>

<span class="sd">        Attempt to drop non-existent variable with errors=&quot;raise&quot;</span>

<span class="sd">        &gt;&gt;&gt; dataset.drop_vars([&quot;pressure&quot;], errors=&quot;raise&quot;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ValueError: These variables cannot be found in this dataset: [&#39;pressure&#39;]</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">             Raised if you attempt to drop a variable which is not present, and the kwarg ``errors=&#39;raise&#39;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped : Dataset</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.drop_vars</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># the Iterable check is required for mypy</span>
        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">names_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">names</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">names_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assert_all_in_dataset</span><span class="p">(</span><span class="n">names_set</span><span class="p">)</span>

        <span class="c1"># GH6505</span>
        <span class="n">other_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">names_set</span><span class="p">:</span>
            <span class="n">maybe_midx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maybe_midx</span><span class="p">,</span> <span class="n">PandasMultiIndex</span><span class="p">):</span>
                <span class="n">idx_coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">maybe_midx</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">maybe_midx</span><span class="o">.</span><span class="n">dim</span><span class="p">])</span>
                <span class="n">idx_other_names</span> <span class="o">=</span> <span class="n">idx_coord_names</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">names_set</span><span class="p">)</span>
                <span class="n">other_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx_other_names</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">other_names</span><span class="p">:</span>
            <span class="n">names_set</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other_names</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Deleting a single level of a MultiIndex is deprecated. Previously, this deleted all levels of a MultiIndex. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Please also drop the following variables: </span><span class="si">{</span><span class="n">other_names</span><span class="si">!r}</span><span class="s2"> to avoid an error in the future.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">assert_no_index_corrupted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">,</span> <span class="n">names_set</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names_set</span><span class="p">}</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">}</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names_set</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop_indexes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coord_names</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">ErrorOptions</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Drop the indexes assigned to the given coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord_names : hashable or iterable of hashable</span>
<span class="sd">            Name(s) of the coordinate(s) for which to drop the index.</span>
<span class="sd">        errors : {&quot;raise&quot;, &quot;ignore&quot;}, default: &quot;raise&quot;</span>
<span class="sd">            If &#39;raise&#39;, raises a ValueError error if any of the coordinates</span>
<span class="sd">            passed have no index or are not in the dataset.</span>
<span class="sd">            If &#39;ignore&#39;, no error is raised.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped : Dataset</span>
<span class="sd">            A new dataset with dropped indexes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the Iterable check is required for mypy</span>
        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">coord_names</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">coord_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">coord_names</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">coord_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
            <span class="n">invalid_coords</span> <span class="o">=</span> <span class="n">coord_names</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span>
            <span class="k">if</span> <span class="n">invalid_coords</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The coordinates </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">invalid_coords</span><span class="p">)</span><span class="si">}</span><span class="s2"> are not found in the &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dataset coordinates </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">unindexed_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">coord_names</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unindexed_coords</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;those coordinates do not have an index: </span><span class="si">{</span><span class="n">unindexed_coords</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">assert_no_index_corrupted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;remove index(es)&quot;</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">coord_names</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">to_base_variable</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coord_names</span><span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">ErrorOptions</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">labels_kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Backward compatible method based on `drop_vars` and `drop_sel`</span>

<span class="sd">        Using either `drop_vars` or `drop_sel` is encouraged</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.drop_vars</span>
<span class="sd">        Dataset.drop_sel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">errors</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="s2">&quot;ignore&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;errors must be either &quot;raise&quot; or &quot;ignore&quot;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">emit_user_level_warning</span><span class="p">(</span>
                <span class="s2">&quot;dropping coordinates using `drop` is deprecated; use drop_vars.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">labels_kwargs</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot specify dim and dict-like arguments.&quot;</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">labels_kwargs</span><span class="p">,</span> <span class="s2">&quot;drop&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)):</span>
            <span class="n">emit_user_level_warning</span><span class="p">(</span>
                <span class="s2">&quot;dropping variables using `drop` is deprecated; use drop_vars.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># for mypy</span>
            <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;dropping labels using list-like labels is deprecated; using &quot;</span>
                <span class="s2">&quot;dict-like arguments with `drop_sel`, e.g. `ds.drop_sel(dim=[labels]).&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_sel</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">labels</span><span class="p">},</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span> <span class="o">**</span><span class="n">labels_kwargs</span><span class="p">)</span>

        <span class="n">emit_user_level_warning</span><span class="p">(</span>
            <span class="s2">&quot;dropping labels using `drop` is deprecated; use `drop_sel` instead.&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_sel</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop_sel</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">errors</span><span class="p">:</span> <span class="n">ErrorOptions</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">labels_kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Drop index labels from this dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : mapping of hashable to Any</span>
<span class="sd">            Index labels to drop</span>
<span class="sd">        errors : {&quot;raise&quot;, &quot;ignore&quot;}, default: &quot;raise&quot;</span>
<span class="sd">            If &#39;raise&#39;, raises a ValueError error if</span>
<span class="sd">            any of the index labels passed are not</span>
<span class="sd">            in the dataset. If &#39;ignore&#39;, any given labels that are in the</span>
<span class="sd">            dataset are dropped and no error is raised.</span>
<span class="sd">        **labels_kwargs : {dim: label, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``dim`` and ``labels``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped : Dataset</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; data = np.arange(6).reshape(2, 3)</span>
<span class="sd">        &gt;&gt;&gt; labels = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;A&quot;: ([&quot;x&quot;, &quot;y&quot;], data), &quot;y&quot;: labels})</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 60B</span>
<span class="sd">        Dimensions:  (x: 2, y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) &lt;U1 12B &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x, y) int64 48B 0 1 2 3 4 5</span>
<span class="sd">        &gt;&gt;&gt; ds.drop_sel(y=[&quot;a&quot;, &quot;c&quot;])</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 20B</span>
<span class="sd">        Dimensions:  (x: 2, y: 1)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) &lt;U1 4B &#39;b&#39;</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x, y) int64 16B 1 4</span>
<span class="sd">        &gt;&gt;&gt; ds.drop_sel(y=&quot;b&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 40B</span>
<span class="sd">        Dimensions:  (x: 2, y: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) &lt;U1 8B &#39;a&#39; &#39;c&#39;</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x, y) int64 32B 0 2 3 5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">errors</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="s2">&quot;ignore&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;errors must be either &quot;raise&quot; or &quot;ignore&quot;&#39;</span><span class="p">)</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">labels_kwargs</span><span class="p">,</span> <span class="s2">&quot;drop_sel&quot;</span><span class="p">)</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">labels_for_dim</span> <span class="ow">in</span> <span class="n">labels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Don&#39;t cast to set, as it would harm performance when labels</span>
            <span class="c1"># is a large numpy array</span>
            <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">labels_for_dim</span><span class="p">):</span>
                <span class="n">labels_for_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels_for_dim</span><span class="p">]</span>
            <span class="n">labels_for_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">labels_for_dim</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">!r}</span><span class="s2"> does not have coordinate labels&quot;</span><span class="p">)</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels_for_dim</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">loc</span><span class="p">[{</span><span class="n">dim</span><span class="p">:</span> <span class="n">new_index</span><span class="p">}]</span>
        <span class="k">return</span> <span class="n">ds</span>

    <span class="k">def</span> <span class="nf">drop_isel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Drop index positions from this Dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexers : mapping of hashable to Any</span>
<span class="sd">            Index locations to drop</span>
<span class="sd">        **indexers_kwargs : {dim: position, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``dim`` and ``positions``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped : Dataset</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        IndexError</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; data = np.arange(6).reshape(2, 3)</span>
<span class="sd">        &gt;&gt;&gt; labels = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;A&quot;: ([&quot;x&quot;, &quot;y&quot;], data), &quot;y&quot;: labels})</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 60B</span>
<span class="sd">        Dimensions:  (x: 2, y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) &lt;U1 12B &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x, y) int64 48B 0 1 2 3 4 5</span>
<span class="sd">        &gt;&gt;&gt; ds.drop_isel(y=[0, 2])</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 20B</span>
<span class="sd">        Dimensions:  (x: 2, y: 1)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) &lt;U1 4B &#39;b&#39;</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x, y) int64 16B 1 4</span>
<span class="sd">        &gt;&gt;&gt; ds.drop_isel(y=1)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 40B</span>
<span class="sd">        Dimensions:  (x: 2, y: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) &lt;U1 8B &#39;a&#39; &#39;c&#39;</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x, y) int64 32B 0 2 3 5</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">indexers</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;drop_isel&quot;</span><span class="p">)</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">dimension_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">pos_for_dim</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Don&#39;t cast to set, as it would harm performance when labels</span>
            <span class="c1"># is a large numpy array</span>
            <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">pos_for_dim</span><span class="p">):</span>
                <span class="n">pos_for_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos_for_dim</span><span class="p">]</span>
            <span class="n">pos_for_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pos_for_dim</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">pos_for_dim</span><span class="p">)</span>
            <span class="n">dimension_index</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_index</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dimension_index</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ds</span>

    <span class="k">def</span> <span class="nf">drop_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">drop_dims</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">ErrorOptions</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Drop dimensions and associated variables from this dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        drop_dims : str or Iterable of Hashable</span>
<span class="sd">            Dimension or dimensions to drop.</span>
<span class="sd">        errors : {&quot;raise&quot;, &quot;ignore&quot;}, default: &quot;raise&quot;</span>
<span class="sd">            If &#39;raise&#39;, raises a ValueError error if any of the</span>
<span class="sd">            dimensions passed are not in the dataset. If &#39;ignore&#39;, any given</span>
<span class="sd">            dimensions that are in the dataset are dropped and no error is raised.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>
<span class="sd">            The dataset without the given dimensions (or any variables</span>
<span class="sd">            containing those dimensions).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">errors</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="s2">&quot;ignore&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;errors must be either &quot;raise&quot; or &quot;ignore&quot;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">drop_dims</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">drop_dims</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">drop_dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">drop_dims</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">drop_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">drop_dims</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
            <span class="n">missing_dims</span> <span class="o">=</span> <span class="n">drop_dims</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">missing_dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Dimensions </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missing_dims</span><span class="p">)</span><span class="si">}</span><span class="s2"> not found in data dimensions </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">drop_vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">drop_dims</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">drop_vars</span><span class="p">)</span>

    <span class="nd">@deprecate_dims</span>
    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="n">missing_dims</span><span class="p">:</span> <span class="n">ErrorOptionsWithWarn</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new Dataset object with all array dimensions transposed.</span>

<span class="sd">        Although the order of dimensions on each array will change, the dataset</span>
<span class="sd">        dimensions themselves will remain in fixed (sorted) order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *dim : hashable, optional</span>
<span class="sd">            By default, reverse the dimensions on each array. Otherwise,</span>
<span class="sd">            reorder the dimensions to this order.</span>
<span class="sd">        missing_dims : {&quot;raise&quot;, &quot;warn&quot;, &quot;ignore&quot;}, default: &quot;raise&quot;</span>
<span class="sd">            What to do if dimensions that should be selected from are not present in the</span>
<span class="sd">            Dataset:</span>
<span class="sd">            - &quot;raise&quot;: raise an exception</span>
<span class="sd">            - &quot;warn&quot;: raise a warning, and ignore the missing dimensions</span>
<span class="sd">            - &quot;ignore&quot;: ignore the missing dimensions</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        transposed : Dataset</span>
<span class="sd">            Each array in the dataset (including) coordinates will be</span>
<span class="sd">            transposed to the given order.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This operation returns a view of each array&#39;s data. It is</span>
<span class="sd">        lazy for dask-backed DataArrays but not for numpy-backed DataArrays</span>
<span class="sd">        -- the data will be fully loaded into memory.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.transpose</span>
<span class="sd">        DataArray.transpose</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Raise error if list is passed as dim</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">list_fix</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;transpose requires dim to be passed as multiple arguments. Expected `</span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">list_fix</span><span class="p">)</span><span class="si">}</span><span class="s1">`. Received `</span><span class="si">{</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">` instead&#39;</span>
            <span class="p">)</span>

        <span class="c1"># Use infix_dims to check once for missing dimensions</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">infix_dims</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">missing_dims</span><span class="p">))</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">var_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dim</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="o">+</span> <span class="p">(</span><span class="o">...</span><span class="p">,)))</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">var_dims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ds</span>

    <span class="nd">@_deprecate_positional_args</span><span class="p">(</span><span class="s2">&quot;v2023.10.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;any&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;any&quot;</span><span class="p">,</span>
        <span class="n">thresh</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new dataset with dropped labels for missing values along</span>
<span class="sd">        the provided dimension.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : hashable</span>
<span class="sd">            Dimension along which to drop missing values. Dropping along</span>
<span class="sd">            multiple dimensions simultaneously is not yet supported.</span>
<span class="sd">        how : {&quot;any&quot;, &quot;all&quot;}, default: &quot;any&quot;</span>
<span class="sd">            - any : if any NA values are present, drop that label</span>
<span class="sd">            - all : if all values are NA, drop that label</span>

<span class="sd">        thresh : int or None, optional</span>
<span class="sd">            If supplied, require this many non-NA values (summed over all the subset variables).</span>
<span class="sd">        subset : iterable of hashable or None, optional</span>
<span class="sd">            Which variables to check for missing values. By default, all</span>
<span class="sd">            variables in the dataset are checked.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; dataset = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;temperature&quot;: (</span>
<span class="sd">        ...             [&quot;time&quot;, &quot;location&quot;],</span>
<span class="sd">        ...             [[23.4, 24.1], [np.nan, 22.1], [21.8, 24.2], [20.5, 25.3]],</span>
<span class="sd">        ...         )</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;time&quot;: [1, 2, 3, 4], &quot;location&quot;: [&quot;A&quot;, &quot;B&quot;]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; dataset</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 104B</span>
<span class="sd">        Dimensions:      (time: 4, location: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) int64 32B 1 2 3 4</span>
<span class="sd">          * location     (location) &lt;U1 8B &#39;A&#39; &#39;B&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time, location) float64 64B 23.4 24.1 nan ... 24.2 20.5 25.3</span>

<span class="sd">        Drop NaN values from the dataset</span>

<span class="sd">        &gt;&gt;&gt; dataset.dropna(dim=&quot;time&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 80B</span>
<span class="sd">        Dimensions:      (time: 3, location: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) int64 24B 1 3 4</span>
<span class="sd">          * location     (location) &lt;U1 8B &#39;A&#39; &#39;B&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time, location) float64 48B 23.4 24.1 21.8 24.2 20.5 25.3</span>

<span class="sd">        Drop labels with any NaN values</span>

<span class="sd">        &gt;&gt;&gt; dataset.dropna(dim=&quot;time&quot;, how=&quot;any&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 80B</span>
<span class="sd">        Dimensions:      (time: 3, location: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) int64 24B 1 3 4</span>
<span class="sd">          * location     (location) &lt;U1 8B &#39;A&#39; &#39;B&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time, location) float64 48B 23.4 24.1 21.8 24.2 20.5 25.3</span>

<span class="sd">        Drop labels with all NAN values</span>

<span class="sd">        &gt;&gt;&gt; dataset.dropna(dim=&quot;time&quot;, how=&quot;all&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 104B</span>
<span class="sd">        Dimensions:      (time: 4, location: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) int64 32B 1 2 3 4</span>
<span class="sd">          * location     (location) &lt;U1 8B &#39;A&#39; &#39;B&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time, location) float64 64B 23.4 24.1 nan ... 24.2 20.5 25.3</span>

<span class="sd">        Drop labels with less than 2 non-NA values</span>

<span class="sd">        &gt;&gt;&gt; dataset.dropna(dim=&quot;time&quot;, thresh=2)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 80B</span>
<span class="sd">        Dimensions:      (time: 3, location: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time         (time) int64 24B 1 3 4</span>
<span class="sd">          * location     (location) &lt;U1 8B &#39;A&#39; &#39;B&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature  (time, location) float64 48B 23.4 24.1 21.8 24.2 20.5 25.3</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.dropna</span>
<span class="sd">        pandas.DataFrame.dropna</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: consider supporting multiple dimensions? Or not, given that</span>
        <span class="c1"># there are some ugly edge cases, e.g., pandas&#39;s dropna differs</span>
        <span class="c1"># depending on the order of the supplied axes.</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">!r}</span><span class="s2"> not found in data dimensions </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>

        <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># for type checking</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">subset</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">]</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
                <span class="n">size</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">thresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">thresh</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;any&quot;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">count</span> <span class="o">==</span> <span class="n">size</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid how option: </span><span class="si">{</span><span class="n">how</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;must specify how or thresh&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">mask</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill missing values in this object.</span>

<span class="sd">        This operation follows the normal broadcasting and alignment rules that</span>
<span class="sd">        xarray uses for binary arithmetic, except the result is aligned to this</span>
<span class="sd">        object (``join=&#39;left&#39;``) instead of aligned to the intersection of</span>
<span class="sd">        index coordinates (``join=&#39;inner&#39;``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar, ndarray, DataArray, dict or Dataset</span>
<span class="sd">            Used to fill all matching missing values in this dataset&#39;s data</span>
<span class="sd">            variables. Scalars, ndarrays or DataArrays arguments are used to</span>
<span class="sd">            fill all data with aligned coordinates (for DataArrays).</span>
<span class="sd">            Dictionaries or datasets match data variables and then align</span>
<span class="sd">            coordinates if necessary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;A&quot;: (&quot;x&quot;, [np.nan, 2, np.nan, 0]),</span>
<span class="sd">        ...         &quot;B&quot;: (&quot;x&quot;, [3, 4, np.nan, 1]),</span>
<span class="sd">        ...         &quot;C&quot;: (&quot;x&quot;, [np.nan, np.nan, np.nan, 5]),</span>
<span class="sd">        ...         &quot;D&quot;: (&quot;x&quot;, [np.nan, 3, np.nan, 4]),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;x&quot;: [0, 1, 2, 3]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 160B</span>
<span class="sd">        Dimensions:  (x: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 32B 0 1 2 3</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x) float64 32B nan 2.0 nan 0.0</span>
<span class="sd">            B        (x) float64 32B 3.0 4.0 nan 1.0</span>
<span class="sd">            C        (x) float64 32B nan nan nan 5.0</span>
<span class="sd">            D        (x) float64 32B nan 3.0 nan 4.0</span>

<span class="sd">        Replace all `NaN` values with 0s.</span>

<span class="sd">        &gt;&gt;&gt; ds.fillna(0)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 160B</span>
<span class="sd">        Dimensions:  (x: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 32B 0 1 2 3</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x) float64 32B 0.0 2.0 0.0 0.0</span>
<span class="sd">            B        (x) float64 32B 3.0 4.0 0.0 1.0</span>
<span class="sd">            C        (x) float64 32B 0.0 0.0 0.0 5.0</span>
<span class="sd">            D        (x) float64 32B 0.0 3.0 0.0 4.0</span>

<span class="sd">        Replace all `NaN` elements in column ‘A’, ‘B’, ‘C’, and ‘D’, with 0, 1, 2, and 3 respectively.</span>

<span class="sd">        &gt;&gt;&gt; values = {&quot;A&quot;: 0, &quot;B&quot;: 1, &quot;C&quot;: 2, &quot;D&quot;: 3}</span>
<span class="sd">        &gt;&gt;&gt; ds.fillna(value=values)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 160B</span>
<span class="sd">        Dimensions:  (x: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 32B 0 1 2 3</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x) float64 32B 0.0 2.0 0.0 0.0</span>
<span class="sd">            B        (x) float64 32B 3.0 4.0 1.0 1.0</span>
<span class="sd">            C        (x) float64 32B 2.0 2.0 2.0 5.0</span>
<span class="sd">            D        (x) float64 32B 3.0 3.0 3.0 4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="n">value_keys</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;data_vars&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">value_keys</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;all variables in the argument to `fillna` &quot;</span>
                    <span class="s2">&quot;must be contained in the original dataset&quot;</span>
                <span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">interpolate_na</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">InterpOptions</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_coordinate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">max_gap</span><span class="p">:</span> <span class="p">(</span>
            <span class="nb">int</span>
            <span class="o">|</span> <span class="nb">float</span>
            <span class="o">|</span> <span class="nb">str</span>
            <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span>
            <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span>
            <span class="o">|</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span>
            <span class="o">|</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill in NaNs by interpolating according to different methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : Hashable or None, optional</span>
<span class="sd">            Specifies the dimension along which to interpolate.</span>
<span class="sd">        method : {&quot;linear&quot;, &quot;nearest&quot;, &quot;zero&quot;, &quot;slinear&quot;, &quot;quadratic&quot;, &quot;cubic&quot;, &quot;polynomial&quot;, \</span>
<span class="sd">            &quot;barycentric&quot;, &quot;krogh&quot;, &quot;pchip&quot;, &quot;spline&quot;, &quot;akima&quot;}, default: &quot;linear&quot;</span>
<span class="sd">            String indicating which method to use for interpolation:</span>

<span class="sd">            - &#39;linear&#39;: linear interpolation. Additional keyword</span>
<span class="sd">              arguments are passed to :py:func:`numpy.interp`</span>
<span class="sd">            - &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;polynomial&#39;:</span>
<span class="sd">              are passed to :py:func:`scipy.interpolate.interp1d`. If</span>
<span class="sd">              ``method=&#39;polynomial&#39;``, the ``order`` keyword argument must also be</span>
<span class="sd">              provided.</span>
<span class="sd">            - &#39;barycentric&#39;, &#39;krogh&#39;, &#39;pchip&#39;, &#39;spline&#39;, &#39;akima&#39;: use their</span>
<span class="sd">              respective :py:class:`scipy.interpolate` classes.</span>

<span class="sd">        use_coordinate : bool or Hashable, default: True</span>
<span class="sd">            Specifies which index to use as the x values in the interpolation</span>
<span class="sd">            formulated as `y = f(x)`. If False, values are treated as if</span>
<span class="sd">            equally-spaced along ``dim``. If True, the IndexVariable `dim` is</span>
<span class="sd">            used. If ``use_coordinate`` is a string, it specifies the name of a</span>
<span class="sd">            coordinate variable to use as the index.</span>
<span class="sd">        limit : int, default: None</span>
<span class="sd">            Maximum number of consecutive NaNs to fill. Must be greater than 0</span>
<span class="sd">            or None for no limit. This filling is done regardless of the size of</span>
<span class="sd">            the gap in the data. To only interpolate over gaps less than a given length,</span>
<span class="sd">            see ``max_gap``.</span>
<span class="sd">        max_gap : int, float, str, pandas.Timedelta, numpy.timedelta64, datetime.timedelta \</span>
<span class="sd">            or None, default: None</span>
<span class="sd">            Maximum size of gap, a continuous sequence of NaNs, that will be filled.</span>
<span class="sd">            Use None for no limit. When interpolating along a datetime64 dimension</span>
<span class="sd">            and ``use_coordinate=True``, ``max_gap`` can be one of the following:</span>

<span class="sd">            - a string that is valid input for pandas.to_timedelta</span>
<span class="sd">            - a :py:class:`numpy.timedelta64` object</span>
<span class="sd">            - a :py:class:`pandas.Timedelta` object</span>
<span class="sd">            - a :py:class:`datetime.timedelta` object</span>

<span class="sd">            Otherwise, ``max_gap`` must be an int or a float. Use of ``max_gap`` with unlabeled</span>
<span class="sd">            dimensions has not been implemented yet. Gap length is defined as the difference</span>
<span class="sd">            between coordinate values at the first data point after a gap and the last value</span>
<span class="sd">            before a gap. For gaps at the beginning (end), gap length is defined as the difference</span>
<span class="sd">            between coordinate values at the first (last) valid data point and the first (last) NaN.</span>
<span class="sd">            For example, consider::</span>

<span class="sd">                &lt;xarray.DataArray (x: 9)&gt;</span>
<span class="sd">                array([nan, nan, nan,  1., nan, nan,  4., nan, nan])</span>
<span class="sd">                Coordinates:</span>
<span class="sd">                  * x        (x) int64 0 1 2 3 4 5 6 7 8</span>

<span class="sd">            The gap lengths are 3-0 = 3; 6-3 = 3; and 8-6 = 2 respectively</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            parameters passed verbatim to the underlying interpolation function</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        interpolated: Dataset</span>
<span class="sd">            Filled in Dataset.</span>

<span class="sd">        Warning</span>
<span class="sd">        --------</span>
<span class="sd">        When passing fill_value as a keyword argument with method=&quot;linear&quot;, it does not use</span>
<span class="sd">        ``numpy.interp`` but it uses ``scipy.interpolate.interp1d``, which provides the fill_value parameter.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.interp</span>
<span class="sd">        scipy.interpolate</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;A&quot;: (&quot;x&quot;, [np.nan, 2, 3, np.nan, 0]),</span>
<span class="sd">        ...         &quot;B&quot;: (&quot;x&quot;, [3, 4, np.nan, 1, 7]),</span>
<span class="sd">        ...         &quot;C&quot;: (&quot;x&quot;, [np.nan, np.nan, np.nan, 5, 0]),</span>
<span class="sd">        ...         &quot;D&quot;: (&quot;x&quot;, [np.nan, 3, np.nan, -1, 4]),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;x&quot;: [0, 1, 2, 3, 4]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 200B</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 40B 0 1 2 3 4</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x) float64 40B nan 2.0 3.0 nan 0.0</span>
<span class="sd">            B        (x) float64 40B 3.0 4.0 nan 1.0 7.0</span>
<span class="sd">            C        (x) float64 40B nan nan nan 5.0 0.0</span>
<span class="sd">            D        (x) float64 40B nan 3.0 nan -1.0 4.0</span>

<span class="sd">        &gt;&gt;&gt; ds.interpolate_na(dim=&quot;x&quot;, method=&quot;linear&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 200B</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 40B 0 1 2 3 4</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x) float64 40B nan 2.0 3.0 1.5 0.0</span>
<span class="sd">            B        (x) float64 40B 3.0 4.0 2.5 1.0 7.0</span>
<span class="sd">            C        (x) float64 40B nan nan nan 5.0 0.0</span>
<span class="sd">            D        (x) float64 40B nan 3.0 1.0 -1.0 4.0</span>

<span class="sd">        &gt;&gt;&gt; ds.interpolate_na(dim=&quot;x&quot;, method=&quot;linear&quot;, fill_value=&quot;extrapolate&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 200B</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 40B 0 1 2 3 4</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x) float64 40B 1.0 2.0 3.0 1.5 0.0</span>
<span class="sd">            B        (x) float64 40B 3.0 4.0 2.5 1.0 7.0</span>
<span class="sd">            C        (x) float64 40B 20.0 15.0 10.0 5.0 0.0</span>
<span class="sd">            D        (x) float64 40B 5.0 3.0 1.0 -1.0 4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.missing</span> <span class="kn">import</span> <span class="n">_apply_over_vars_with_dim</span><span class="p">,</span> <span class="n">interp_na</span>

        <span class="n">new</span> <span class="o">=</span> <span class="n">_apply_over_vars_with_dim</span><span class="p">(</span>
            <span class="n">interp_na</span><span class="p">,</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">use_coordinate</span><span class="o">=</span><span class="n">use_coordinate</span><span class="p">,</span>
            <span class="n">max_gap</span><span class="o">=</span><span class="n">max_gap</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">ffill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill NaN values by propagating values forward</span>

<span class="sd">        *Requires bottleneck.*</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : Hashable</span>
<span class="sd">            Specifies the dimension along which to propagate values when filling.</span>
<span class="sd">        limit : int or None, optional</span>
<span class="sd">            The maximum number of consecutive NaN values to forward fill. In</span>
<span class="sd">            other words, if there is a gap with more than this number of</span>
<span class="sd">            consecutive NaNs, it will only be partially filled. Must be greater</span>
<span class="sd">            than 0 or None for no limit. Must be None or greater than or equal</span>
<span class="sd">            to axis length if filling along chunked axes (dimensions).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time = pd.date_range(&quot;2023-01-01&quot;, periods=10, freq=&quot;D&quot;)</span>
<span class="sd">        &gt;&gt;&gt; data = np.array(</span>
<span class="sd">        ...     [1, np.nan, np.nan, np.nan, 5, np.nan, np.nan, 8, np.nan, 10]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; dataset = xr.Dataset({&quot;data&quot;: ((&quot;time&quot;,), data)}, coords={&quot;time&quot;: time})</span>
<span class="sd">        &gt;&gt;&gt; dataset</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 160B</span>
<span class="sd">        Dimensions:  (time: 10)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time     (time) datetime64[ns] 80B 2023-01-01 2023-01-02 ... 2023-01-10</span>
<span class="sd">        Data variables:</span>
<span class="sd">            data     (time) float64 80B 1.0 nan nan nan 5.0 nan nan 8.0 nan 10.0</span>

<span class="sd">        # Perform forward fill (ffill) on the dataset</span>

<span class="sd">        &gt;&gt;&gt; dataset.ffill(dim=&quot;time&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 160B</span>
<span class="sd">        Dimensions:  (time: 10)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time     (time) datetime64[ns] 80B 2023-01-01 2023-01-02 ... 2023-01-10</span>
<span class="sd">        Data variables:</span>
<span class="sd">            data     (time) float64 80B 1.0 1.0 1.0 1.0 5.0 5.0 5.0 8.0 8.0 10.0</span>

<span class="sd">        # Limit the forward filling to a maximum of 2 consecutive NaN values</span>

<span class="sd">        &gt;&gt;&gt; dataset.ffill(dim=&quot;time&quot;, limit=2)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 160B</span>
<span class="sd">        Dimensions:  (time: 10)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time     (time) datetime64[ns] 80B 2023-01-01 2023-01-02 ... 2023-01-10</span>
<span class="sd">        Data variables:</span>
<span class="sd">            data     (time) float64 80B 1.0 1.0 1.0 nan 5.0 5.0 5.0 8.0 8.0 10.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.bfill</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.missing</span> <span class="kn">import</span> <span class="n">_apply_over_vars_with_dim</span><span class="p">,</span> <span class="n">ffill</span>

        <span class="n">new</span> <span class="o">=</span> <span class="n">_apply_over_vars_with_dim</span><span class="p">(</span><span class="n">ffill</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">bfill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill NaN values by propagating values backward</span>

<span class="sd">        *Requires bottleneck.*</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : Hashable</span>
<span class="sd">            Specifies the dimension along which to propagate values when</span>
<span class="sd">            filling.</span>
<span class="sd">        limit : int or None, optional</span>
<span class="sd">            The maximum number of consecutive NaN values to backward fill. In</span>
<span class="sd">            other words, if there is a gap with more than this number of</span>
<span class="sd">            consecutive NaNs, it will only be partially filled. Must be greater</span>
<span class="sd">            than 0 or None for no limit. Must be None or greater than or equal</span>
<span class="sd">            to axis length if filling along chunked axes (dimensions).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time = pd.date_range(&quot;2023-01-01&quot;, periods=10, freq=&quot;D&quot;)</span>
<span class="sd">        &gt;&gt;&gt; data = np.array(</span>
<span class="sd">        ...     [1, np.nan, np.nan, np.nan, 5, np.nan, np.nan, 8, np.nan, 10]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; dataset = xr.Dataset({&quot;data&quot;: ((&quot;time&quot;,), data)}, coords={&quot;time&quot;: time})</span>
<span class="sd">        &gt;&gt;&gt; dataset</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 160B</span>
<span class="sd">        Dimensions:  (time: 10)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time     (time) datetime64[ns] 80B 2023-01-01 2023-01-02 ... 2023-01-10</span>
<span class="sd">        Data variables:</span>
<span class="sd">            data     (time) float64 80B 1.0 nan nan nan 5.0 nan nan 8.0 nan 10.0</span>

<span class="sd">        # filled dataset, fills NaN values by propagating values backward</span>

<span class="sd">        &gt;&gt;&gt; dataset.bfill(dim=&quot;time&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 160B</span>
<span class="sd">        Dimensions:  (time: 10)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time     (time) datetime64[ns] 80B 2023-01-01 2023-01-02 ... 2023-01-10</span>
<span class="sd">        Data variables:</span>
<span class="sd">            data     (time) float64 80B 1.0 5.0 5.0 5.0 5.0 8.0 8.0 8.0 10.0 10.0</span>

<span class="sd">        # Limit the backward filling to a maximum of 2 consecutive NaN values</span>

<span class="sd">        &gt;&gt;&gt; dataset.bfill(dim=&quot;time&quot;, limit=2)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 160B</span>
<span class="sd">        Dimensions:  (time: 10)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time     (time) datetime64[ns] 80B 2023-01-01 2023-01-02 ... 2023-01-10</span>
<span class="sd">        Data variables:</span>
<span class="sd">            data     (time) float64 80B 1.0 nan 5.0 5.0 5.0 8.0 8.0 8.0 10.0 10.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.ffill</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.missing</span> <span class="kn">import</span> <span class="n">_apply_over_vars_with_dim</span><span class="p">,</span> <span class="n">bfill</span>

        <span class="n">new</span> <span class="o">=</span> <span class="n">_apply_over_vars_with_dim</span><span class="p">(</span><span class="n">bfill</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">combine_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Combine two Datasets, default to data_vars of self.</span>

<span class="sd">        The new coordinates follow the normal broadcasting and alignment rules</span>
<span class="sd">        of ``join=&#39;outer&#39;``.  Vacant cells in the expanded coordinates are</span>
<span class="sd">        filled with np.nan.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Dataset</span>
<span class="sd">            Used to fill all matching missing values in this array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span> <span class="n">dataset_join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reduce this dataset by applying `func` along some dimension(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            Function which can be called in the form</span>
<span class="sd">            `f(x, axis=axis, **kwargs)` to return the result of reducing an</span>
<span class="sd">            np.ndarray over an integer valued axis.</span>
<span class="sd">        dim : str, Iterable of Hashable or None, optional</span>
<span class="sd">            Dimension(s) over which to apply `func`. By default `func` is</span>
<span class="sd">            applied over all dimensions.</span>
<span class="sd">        keep_attrs : bool or None, optional</span>
<span class="sd">            If True, the dataset&#39;s attributes (`attrs`) will be copied from</span>
<span class="sd">            the original object to the new one.  If False (default), the new</span>
<span class="sd">            object will be returned without attributes.</span>
<span class="sd">        keepdims : bool, default: False</span>
<span class="sd">            If True, the dimensions which are reduced are left in the result</span>
<span class="sd">            as dimensions of size one. Coordinates that use these dimensions</span>
<span class="sd">            are removed.</span>
<span class="sd">        numeric_only : bool, default: False</span>
<span class="sd">            If True, only apply ``func`` to variables with a numeric dtype.</span>
<span class="sd">        **kwargs : Any</span>
<span class="sd">            Additional keyword arguments passed on to ``func``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reduced : Dataset</span>
<span class="sd">            Dataset with this object&#39;s DataArrays replaced with new DataArrays</span>
<span class="sd">            of summarized data and the indicated dimension(s) removed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; dataset = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;math_scores&quot;: (</span>
<span class="sd">        ...             [&quot;student&quot;, &quot;test&quot;],</span>
<span class="sd">        ...             [[90, 85, 92], [78, 80, 85], [95, 92, 98]],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...         &quot;english_scores&quot;: (</span>
<span class="sd">        ...             [&quot;student&quot;, &quot;test&quot;],</span>
<span class="sd">        ...             [[88, 90, 92], [75, 82, 79], [93, 96, 91]],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={</span>
<span class="sd">        ...         &quot;student&quot;: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;],</span>
<span class="sd">        ...         &quot;test&quot;: [&quot;Test 1&quot;, &quot;Test 2&quot;, &quot;Test 3&quot;],</span>
<span class="sd">        ...     },</span>
<span class="sd">        ... )</span>

<span class="sd">        # Calculate the 75th percentile of math scores for each student using np.percentile</span>

<span class="sd">        &gt;&gt;&gt; percentile_scores = dataset.reduce(np.percentile, q=75, dim=&quot;test&quot;)</span>
<span class="sd">        &gt;&gt;&gt; percentile_scores</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 132B</span>
<span class="sd">        Dimensions:         (student: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * student         (student) &lt;U7 84B &#39;Alice&#39; &#39;Bob&#39; &#39;Charlie&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            math_scores     (student) float64 24B 91.0 82.5 96.5</span>
<span class="sd">            english_scores  (student) float64 24B 91.0 80.5 94.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;axis&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;passing &#39;axis&#39; to Dataset reduce methods is ambiguous.&quot;</span>
                <span class="s2">&quot; Please use &#39;dim&#39; instead.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dim</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="n">missing_dimensions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">missing_dimensions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Dimensions </span><span class="si">{</span><span class="n">missing_dimensions</span><span class="si">}</span><span class="s2"> not found in data dimensions </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">keep_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep_attrs</span> <span class="o">=</span> <span class="n">_get_keep_attrs</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">reduce_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">reduce_dims</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="c1"># Some reduction functions (e.g. std, var) need to run on variables</span>
                    <span class="c1"># that don&#39;t have the reduce dims: PR5393</span>
                    <span class="ow">not</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="p">(</span>
                        <span class="ow">not</span> <span class="n">reduce_dims</span>
                        <span class="ow">or</span> <span class="ow">not</span> <span class="n">numeric_only</span>
                        <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">):</span>
                    <span class="c1"># prefer to aggregate over axis=None rather than</span>
                    <span class="c1"># axis=(0, 1) if they will be equivalent, because</span>
                    <span class="c1"># the former is often more efficient</span>
                    <span class="c1"># keep single-element dims as list, to support Hashables</span>
                    <span class="n">reduce_maybe_single</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="kc">None</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduce_dims</span><span class="p">)</span> <span class="o">==</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span>
                        <span class="k">else</span> <span class="n">reduce_dims</span>
                    <span class="p">)</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
                        <span class="n">func</span><span class="p">,</span>
                        <span class="n">dim</span><span class="o">=</span><span class="n">reduce_maybe_single</span><span class="p">,</span>
                        <span class="n">keep_attrs</span><span class="o">=</span><span class="n">keep_attrs</span><span class="p">,</span>
                        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">}</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">}</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="k">if</span> <span class="n">keep_attrs</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a function to each data variable in this dataset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            Function which can be called in the form `func(x, *args, **kwargs)`</span>
<span class="sd">            to transform each DataArray `x` in this dataset into another</span>
<span class="sd">            DataArray.</span>
<span class="sd">        keep_attrs : bool or None, optional</span>
<span class="sd">            If True, both the dataset&#39;s and variables&#39; attributes (`attrs`) will be</span>
<span class="sd">            copied from the original objects to the new ones. If False, the new dataset</span>
<span class="sd">            and variables will be returned without copying the attributes.</span>
<span class="sd">        args : iterable, optional</span>
<span class="sd">            Positional arguments passed on to `func`.</span>
<span class="sd">        **kwargs : Any</span>
<span class="sd">            Keyword arguments passed on to `func`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        applied : Dataset</span>
<span class="sd">            Resulting dataset from applying ``func`` to each data variable.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; da = xr.DataArray(np.random.randn(2, 3))</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;foo&quot;: da, &quot;bar&quot;: (&quot;x&quot;, [-1, 2])})</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 64B</span>
<span class="sd">        Dimensions:  (dim_0: 2, dim_1: 3, x: 2)</span>
<span class="sd">        Dimensions without coordinates: dim_0, dim_1, x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (dim_0, dim_1) float64 48B 1.764 0.4002 0.9787 2.241 1.868 -0.9773</span>
<span class="sd">            bar      (x) int64 16B -1 2</span>
<span class="sd">        &gt;&gt;&gt; ds.map(np.fabs)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 64B</span>
<span class="sd">        Dimensions:  (dim_0: 2, dim_1: 3, x: 2)</span>
<span class="sd">        Dimensions without coordinates: dim_0, dim_1, x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (dim_0, dim_1) float64 48B 1.764 0.4002 0.9787 2.241 1.868 0.9773</span>
<span class="sd">            bar      (x) float64 16B 1.0 2.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">keep_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep_attrs</span> <span class="o">=</span> <span class="n">_get_keep_attrs</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">maybe_wrap_array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">keep_attrs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">v</span><span class="o">.</span><span class="n">_copy_attrs_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="k">if</span> <span class="n">keep_attrs</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">variables</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Backward compatible implementation of ``map``</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.map</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Dataset.apply may be deprecated in the future. Using Dataset.map is encouraged&quot;</span><span class="p">,</span>
            <span class="ne">PendingDeprecationWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">keep_attrs</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">assign</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">variables_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assign new data variables to a Dataset, returning a new object</span>
<span class="sd">        with all the original variables in addition to the new ones.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variables : mapping of hashable to Any</span>
<span class="sd">            Mapping from variables names to the new values. If the new values</span>
<span class="sd">            are callable, they are computed on the Dataset and assigned to new</span>
<span class="sd">            data variables. If the values are not callable, (e.g. a DataArray,</span>
<span class="sd">            scalar, or array), they are simply assigned.</span>
<span class="sd">        **variables_kwargs</span>
<span class="sd">            The keyword arguments form of ``variables``.</span>
<span class="sd">            One of variables or variables_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ds : Dataset</span>
<span class="sd">            A new Dataset with the new variables in addition to all the</span>
<span class="sd">            existing variables.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Since ``kwargs`` is a dictionary, the order of your arguments may not</span>
<span class="sd">        be preserved, and so the order of the new variables is not well</span>
<span class="sd">        defined. Assigning multiple variables within the same ``assign`` is</span>
<span class="sd">        possible, but you cannot reference other variables created within the</span>
<span class="sd">        same ``assign`` call.</span>

<span class="sd">        The new assigned variables that replace existing coordinates in the</span>
<span class="sd">        original dataset are still listed as coordinates in the returned</span>
<span class="sd">        Dataset.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.DataFrame.assign</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;temperature_c&quot;: (</span>
<span class="sd">        ...             (&quot;lat&quot;, &quot;lon&quot;),</span>
<span class="sd">        ...             20 * np.random.rand(4).reshape(2, 2),</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...         &quot;precipitation&quot;: ((&quot;lat&quot;, &quot;lon&quot;), np.random.rand(4).reshape(2, 2)),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;lat&quot;: [10, 20], &quot;lon&quot;: [150, 160]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 96B</span>
<span class="sd">        Dimensions:        (lat: 2, lon: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * lat            (lat) int64 16B 10 20</span>
<span class="sd">          * lon            (lon) int64 16B 150 160</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature_c  (lat, lon) float64 32B 10.98 14.3 12.06 10.9</span>
<span class="sd">            precipitation  (lat, lon) float64 32B 0.4237 0.6459 0.4376 0.8918</span>

<span class="sd">        Where the value is a callable, evaluated on dataset:</span>

<span class="sd">        &gt;&gt;&gt; x.assign(temperature_f=lambda x: x.temperature_c * 9 / 5 + 32)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 128B</span>
<span class="sd">        Dimensions:        (lat: 2, lon: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * lat            (lat) int64 16B 10 20</span>
<span class="sd">          * lon            (lon) int64 16B 150 160</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature_c  (lat, lon) float64 32B 10.98 14.3 12.06 10.9</span>
<span class="sd">            precipitation  (lat, lon) float64 32B 0.4237 0.6459 0.4376 0.8918</span>
<span class="sd">            temperature_f  (lat, lon) float64 32B 51.76 57.75 53.7 51.62</span>

<span class="sd">        Alternatively, the same behavior can be achieved by directly referencing an existing dataarray:</span>

<span class="sd">        &gt;&gt;&gt; x.assign(temperature_f=x[&quot;temperature_c&quot;] * 9 / 5 + 32)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 128B</span>
<span class="sd">        Dimensions:        (lat: 2, lon: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * lat            (lat) int64 16B 10 20</span>
<span class="sd">          * lon            (lon) int64 16B 150 160</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature_c  (lat, lon) float64 32B 10.98 14.3 12.06 10.9</span>
<span class="sd">            precipitation  (lat, lon) float64 32B 0.4237 0.6459 0.4376 0.8918</span>
<span class="sd">            temperature_f  (lat, lon) float64 32B 51.76 57.75 53.7 51.62</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">variables_kwargs</span><span class="p">,</span> <span class="s2">&quot;assign&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># do all calculations first...</span>
        <span class="n">results</span><span class="p">:</span> <span class="n">CoercibleMapping</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_calc_assign_results</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>

        <span class="c1"># split data variables to add/replace vs. coordinates to replace</span>
        <span class="n">results_data_vars</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">CoercibleValue</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">results_coords</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">CoercibleValue</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">:</span>
                <span class="n">results_coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results_data_vars</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="c1"># ... and then assign</span>
        <span class="n">data</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">results_coords</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">results_data_vars</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">to_dataarray</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert this dataset into an xarray.DataArray</span>

<span class="sd">        The data variables of this dataset will be broadcast against each other</span>
<span class="sd">        and stacked along the first axis of the new array. All coordinates of</span>
<span class="sd">        this dataset will remain coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : Hashable, default: &quot;variable&quot;</span>
<span class="sd">            Name of the new dimension.</span>
<span class="sd">        name : Hashable or None, optional</span>
<span class="sd">            Name of the new data array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array : xarray.DataArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="n">data_vars</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">]</span>
        <span class="n">broadcast_vars</span> <span class="o">=</span> <span class="n">broadcast_variables</span><span class="p">(</span><span class="o">*</span><span class="n">data_vars</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">duck_array_ops</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">broadcast_vars</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,)</span> <span class="o">+</span> <span class="n">broadcast_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">variable</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">filter_indexes_from_coords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
        <span class="n">new_dim_index</span> <span class="o">=</span> <span class="n">PandasIndex</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">),</span> <span class="n">dim</span><span class="p">)</span>
        <span class="n">indexes</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_dim_index</span>
        <span class="n">coords</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_dim_index</span><span class="o">.</span><span class="n">create_variables</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">DataArray</span><span class="o">.</span><span class="n">_construct_direct</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deprecated version of to_dataarray&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dataarray</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_normalize_dim_order</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dim_order</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the validity of the provided dimensions if any and return the mapping</span>
<span class="sd">        between dimension name and their size.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim_order: Sequence of Hashable or None, optional</span>
<span class="sd">            Dimension order to validate (default to the alphabetical order if None).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : dict[Hashable, int]</span>
<span class="sd">            Validated dimensions mapping.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">dim_order</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;dim_order </span><span class="si">{</span><span class="n">dim_order</span><span class="si">}</span><span class="s2"> does not match the set of dimensions of this &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Dataset: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">ordered_dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dim_order</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">ordered_dims</span>

    <span class="k">def</span> <span class="nf">to_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert this dataset into a pandas object without changing the number of dimensions.</span>

<span class="sd">        The type of the returned object depends on the number of Dataset</span>
<span class="sd">        dimensions:</span>

<span class="sd">        * 0D -&gt; `pandas.Series`</span>
<span class="sd">        * 1D -&gt; `pandas.DataFrame`</span>

<span class="sd">        Only works for Datasets with 1 or fewer dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;cannot convert Datasets with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2"> dimensions into &quot;</span>
            <span class="s2">&quot;pandas objects without changing the number of dimensions. &quot;</span>
            <span class="s2">&quot;Please use Dataset.to_dataframe() instead.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ordered_dims</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
        <span class="n">columns_in_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
        <span class="n">non_extension_array_columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">k</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">columns_in_order</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">extension_array_columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">k</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">columns_in_order</span>
            <span class="k">if</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="n">ordered_dims</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">non_extension_array_columns</span>
        <span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">to_index</span><span class="p">([</span><span class="o">*</span><span class="n">ordered_dims</span><span class="p">])</span>
        <span class="n">broadcasted_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">non_extension_array_columns</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">extension_array_column</span> <span class="ow">in</span> <span class="n">extension_array_columns</span><span class="p">:</span>
            <span class="n">extension_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">extension_array_column</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">array</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">extension_array_column</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">data</span>
            <span class="n">extension_array_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="p">{</span><span class="n">extension_array_column</span><span class="p">:</span> <span class="n">extension_array</span><span class="p">},</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">extension_array_column</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">extension_array_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">extension_array_column</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span>
                <span class="mi">0</span>
            <span class="p">]</span>
            <span class="n">broadcasted_df</span> <span class="o">=</span> <span class="n">broadcasted_df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">extension_array_df</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">broadcasted_df</span><span class="p">[</span><span class="n">columns_in_order</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim_order</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert this dataset into a pandas.DataFrame.</span>

<span class="sd">        Non-index variables in this dataset form the columns of the</span>
<span class="sd">        DataFrame. The DataFrame is indexed by the Cartesian product of</span>
<span class="sd">        this dataset&#39;s indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim_order: Sequence of Hashable or None, optional</span>
<span class="sd">            Hierarchical dimension order for the resulting dataframe. All</span>
<span class="sd">            arrays are transposed to this order and then written out as flat</span>
<span class="sd">            vectors in contiguous order, so the last dimension in this list</span>
<span class="sd">            will be contiguous in the resulting DataFrame. This has a major</span>
<span class="sd">            influence on which operations are efficient on the resulting</span>
<span class="sd">            dataframe.</span>

<span class="sd">            If provided, must include all dimensions of this dataset. By</span>
<span class="sd">            default, dimensions are sorted alphabetically.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : DataFrame</span>
<span class="sd">            Dataset as a pandas DataFrame.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ordered_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_dim_order</span><span class="p">(</span><span class="n">dim_order</span><span class="o">=</span><span class="n">dim_order</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dataframe</span><span class="p">(</span><span class="n">ordered_dims</span><span class="o">=</span><span class="n">ordered_dims</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_sparse_data_from_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">arrays</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">dims</span><span class="p">:</span> <span class="nb">tuple</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">sparse</span> <span class="kn">import</span> <span class="n">COO</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">idx</span><span class="o">.</span><span class="n">codes</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">is_sorted</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lev</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">idx</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">is_sorted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">size</span><span class="p">,)</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
            <span class="c1"># In virtually all real use cases, the sparse array will now have</span>
            <span class="c1"># missing values and needs a fill_value. For consistency, don&#39;t</span>
            <span class="c1"># special case the rare exceptions (e.g., dtype=int without a</span>
            <span class="c1"># MultiIndex).</span>
            <span class="n">dtype</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">xrdtypes</span><span class="o">.</span><span class="n">maybe_promote</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">COO</span><span class="p">(</span>
                <span class="n">coords</span><span class="p">,</span>
                <span class="n">values</span><span class="p">,</span>
                <span class="n">shape</span><span class="p">,</span>
                <span class="n">has_duplicates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="nb">sorted</span><span class="o">=</span><span class="n">is_sorted</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_numpy_data_from_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">arrays</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">dims</span><span class="p">:</span> <span class="nb">tuple</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># NB: similar, more general logic, now exists in</span>
        <span class="c1"># variable.unstack_once; we could consider combining them at some</span>
        <span class="c1"># point.</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lev</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">idx</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span>

        <span class="c1"># We already verified that the MultiIndex has all unique values, so</span>
        <span class="c1"># there are missing values if and only if the size of output arrays is</span>
        <span class="c1"># larger that the index.</span>
        <span class="n">missing_values</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
            <span class="c1"># NumPy indexing is much faster than using DataFrame.reindex() to</span>
            <span class="c1"># fill in missing values:</span>
            <span class="c1"># https://stackoverflow.com/a/35049899/809705</span>
            <span class="k">if</span> <span class="n">missing_values</span><span class="p">:</span>
                <span class="n">dtype</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">xrdtypes</span><span class="o">.</span><span class="n">maybe_promote</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If there are no missing values, keep the existing dtype</span>
                <span class="c1"># instead of promoting to support NA, e.g., keep integer</span>
                <span class="c1"># columns as integers.</span>
                <span class="c1"># TODO: consider removing this special case, which doesn&#39;t</span>
                <span class="c1"># exist for sparse=True.</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dataframe</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a pandas.DataFrame into an xarray.Dataset</span>

<span class="sd">        Each column will be converted into an independent variable in the</span>
<span class="sd">        Dataset. If the dataframe&#39;s index is a MultiIndex, it will be expanded</span>
<span class="sd">        into a tensor product of one-dimensional indices (filling in missing</span>
<span class="sd">        values with NaN). If you rather preserve the MultiIndex use</span>
<span class="sd">        `xr.Dataset(df)`. This method will produce a Dataset very similar to</span>
<span class="sd">        that on which the &#39;to_dataframe&#39; method was called, except with</span>
<span class="sd">        possibly redundant dimensions (since all dataset variables will have</span>
<span class="sd">        the same dimensionality).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataframe : DataFrame</span>
<span class="sd">            DataFrame from which to copy data and indices.</span>
<span class="sd">        sparse : bool, default: False</span>
<span class="sd">            If true, create a sparse arrays instead of dense numpy arrays. This</span>
<span class="sd">            can potentially save a large amount of memory if the DataFrame has</span>
<span class="sd">            a MultiIndex. Requires the sparse package (sparse.pydata.org).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        New Dataset.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        xarray.DataArray.from_series</span>
<span class="sd">        pandas.DataFrame.to_xarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add an option to remove dimensions along which the variables</span>
        <span class="c1"># are constant, to enable consistent serialization to/from a dataframe,</span>
        <span class="c1"># even if some variables have different dimensionality.</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot convert DataFrame with non-unique columns&quot;</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">remove_unused_levels_categories</span><span class="p">(</span><span class="n">dataframe</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">idx</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;cannot convert a DataFrame with a non-unique MultiIndex into xarray&quot;</span>
            <span class="p">)</span>

        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">extension_arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">v</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">DatetimeArray</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">TimedeltaArray</span>
            <span class="p">):</span>
                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">extension_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

        <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">index_vars</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;level_</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n</span>  <span class="c1"># type: ignore[redundant-expr]</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">lev</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">idx</span><span class="o">.</span><span class="n">levels</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">xr_idx</span> <span class="o">=</span> <span class="n">PandasIndex</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
                <span class="n">indexes</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr_idx</span>
                <span class="n">index_vars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">xr_idx</span><span class="o">.</span><span class="n">create_variables</span><span class="p">())</span>
            <span class="n">arrays</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">extension_arrays</span><span class="p">]</span>
            <span class="n">extension_arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_name</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;index&quot;</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">index_name</span><span class="p">,)</span>
            <span class="n">xr_idx</span> <span class="o">=</span> <span class="n">PandasIndex</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">index_name</span><span class="p">)</span>
            <span class="n">indexes</span><span class="p">[</span><span class="n">index_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr_idx</span>
            <span class="n">index_vars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">xr_idx</span><span class="o">.</span><span class="n">create_variables</span><span class="p">())</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_construct_direct</span><span class="p">(</span><span class="n">index_vars</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">index_vars</span><span class="p">),</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_set_sparse_data_from_dataframe</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_set_numpy_data_from_dataframe</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">extension_array</span> <span class="ow">in</span> <span class="n">extension_arrays</span><span class="p">:</span>
            <span class="n">obj</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">extension_array</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span><span class="p">[</span><span class="n">dataframe</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataframe</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="k">else</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">to_dask_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dim_order</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">set_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DaskDataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this dataset into a dask.dataframe.DataFrame.</span>

<span class="sd">        The dimensions, coordinates and data variables in this dataset form</span>
<span class="sd">        the columns of the DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim_order : list, optional</span>
<span class="sd">            Hierarchical dimension order for the resulting dataframe. All</span>
<span class="sd">            arrays are transposed to this order and then written out as flat</span>
<span class="sd">            vectors in contiguous order, so the last dimension in this list</span>
<span class="sd">            will be contiguous in the resulting DataFrame. This has a major</span>
<span class="sd">            influence on which operations are efficient on the resulting dask</span>
<span class="sd">            dataframe.</span>

<span class="sd">            If provided, must include all dimensions of this dataset. By</span>
<span class="sd">            default, dimensions are sorted alphabetically.</span>
<span class="sd">        set_index : bool, default: False</span>
<span class="sd">            If set_index=True, the dask DataFrame is indexed by this dataset&#39;s</span>
<span class="sd">            coordinate. Since dask DataFrames do not support multi-indexes,</span>
<span class="sd">            set_index only works if the dataset only contains one dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dask.dataframe.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
        <span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>

        <span class="n">ordered_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_dim_order</span><span class="p">(</span><span class="n">dim_order</span><span class="o">=</span><span class="n">dim_order</span><span class="p">)</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered_dims</span><span class="p">)</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>

        <span class="n">ds_chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span>

        <span class="n">series_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">df_meta</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># dimension without a matching coordinate</span>
                <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">((</span><span class="n">name</span><span class="p">,),</span> <span class="n">data</span><span class="p">)</span>

            <span class="c1"># IndexVariable objects have a dummy .chunk() method</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">IndexVariable</span><span class="p">):</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">to_base_variable</span><span class="p">()</span>

            <span class="c1"># Make sure var is a dask array, otherwise the array can become too large</span>
            <span class="c1"># when it is broadcasted to several dimensions:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_duck_dask_array</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">chunk</span><span class="p">()</span>

            <span class="c1"># Broadcast then flatten the array:</span>
            <span class="n">var_new_dims</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="n">ordered_dims</span><span class="p">)</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">ds_chunks</span><span class="p">)</span>
            <span class="n">dask_array</span> <span class="o">=</span> <span class="n">var_new_dims</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">series</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_dask_array</span><span class="p">(</span><span class="n">dask_array</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">df_meta</span><span class="p">)</span>
            <span class="n">series_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">series_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">set_index</span><span class="p">:</span>
            <span class="n">dim_order</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">ordered_dims</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim_order</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="p">(</span><span class="n">dim</span><span class="p">,)</span> <span class="o">=</span> <span class="n">dim_order</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># triggers an error about multi-indexes, even if only one</span>
                <span class="c1"># dimension is passed</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">dim_order</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;list&quot;</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;list&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this dataset to a dictionary following xarray naming</span>
<span class="sd">        conventions.</span>

<span class="sd">        Converts all variables and attributes to native Python objects</span>
<span class="sd">        Useful for converting to json. To avoid datetime incompatibility</span>
<span class="sd">        use decode_times=False kwarg in xarrray.open_dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : bool or {&quot;list&quot;, &quot;array&quot;}, default: &quot;list&quot;</span>
<span class="sd">            Whether to include the actual data in the dictionary. When set to</span>
<span class="sd">            False, returns just the schema. If set to &quot;array&quot;, returns data as</span>
<span class="sd">            underlying array type. If set to &quot;list&quot; (or True for backwards</span>
<span class="sd">            compatibility), returns data in lists of Python data types. Note</span>
<span class="sd">            that for obtaining the &quot;list&quot; output efficiently, use</span>
<span class="sd">            `ds.compute().to_dict(data=&quot;list&quot;)`.</span>

<span class="sd">        encoding : bool, default: False</span>
<span class="sd">            Whether to include the Dataset&#39;s encoding in the dictionary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        d : dict</span>
<span class="sd">            Dict with keys: &quot;coords&quot;, &quot;attrs&quot;, &quot;dims&quot;, &quot;data_vars&quot; and optionally</span>
<span class="sd">            &quot;encoding&quot;.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.from_dict</span>
<span class="sd">        DataArray.to_dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;coords&quot;</span><span class="p">:</span> <span class="p">{},</span>
            <span class="s2">&quot;attrs&quot;</span><span class="p">:</span> <span class="n">decode_numpy_dict_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">),</span>
            <span class="s2">&quot;dims&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">),</span>
            <span class="s2">&quot;data_vars&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)}</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;data_vars&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)}</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">encoding</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;encoding&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a dictionary into an xarray.Dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d : dict-like</span>
<span class="sd">            Mapping with a minimum structure of</span>
<span class="sd">                ``{&quot;var_0&quot;: {&quot;dims&quot;: [..], &quot;data&quot;: [..]}, \</span>
<span class="sd">                            ...}``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.to_dict</span>
<span class="sd">        DataArray.from_dict</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; d = {</span>
<span class="sd">        ...     &quot;t&quot;: {&quot;dims&quot;: (&quot;t&quot;), &quot;data&quot;: [0, 1, 2]},</span>
<span class="sd">        ...     &quot;a&quot;: {&quot;dims&quot;: (&quot;t&quot;), &quot;data&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]},</span>
<span class="sd">        ...     &quot;b&quot;: {&quot;dims&quot;: (&quot;t&quot;), &quot;data&quot;: [10, 20, 30]},</span>
<span class="sd">        ... }</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset.from_dict(d)</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 60B</span>
<span class="sd">        Dimensions:  (t: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * t        (t) int64 24B 0 1 2</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (t) &lt;U1 12B &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">            b        (t) int64 24B 10 20 30</span>

<span class="sd">        &gt;&gt;&gt; d = {</span>
<span class="sd">        ...     &quot;coords&quot;: {</span>
<span class="sd">        ...         &quot;t&quot;: {&quot;dims&quot;: &quot;t&quot;, &quot;data&quot;: [0, 1, 2], &quot;attrs&quot;: {&quot;units&quot;: &quot;s&quot;}}</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     &quot;attrs&quot;: {&quot;title&quot;: &quot;air temperature&quot;},</span>
<span class="sd">        ...     &quot;dims&quot;: &quot;t&quot;,</span>
<span class="sd">        ...     &quot;data_vars&quot;: {</span>
<span class="sd">        ...         &quot;a&quot;: {&quot;dims&quot;: &quot;t&quot;, &quot;data&quot;: [10, 20, 30]},</span>
<span class="sd">        ...         &quot;b&quot;: {&quot;dims&quot;: &quot;t&quot;, &quot;data&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]},</span>
<span class="sd">        ...     },</span>
<span class="sd">        ... }</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset.from_dict(d)</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 60B</span>
<span class="sd">        Dimensions:  (t: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * t        (t) int64 24B 0 1 2</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (t) int64 24B 10 20 30</span>
<span class="sd">            b        (t) &lt;U1 12B &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">        Attributes:</span>
<span class="sd">            title:    air temperature</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">variables</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">{</span><span class="s2">&quot;coords&quot;</span><span class="p">,</span> <span class="s2">&quot;data_vars&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">d</span><span class="p">)):</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">itertools</span>

            <span class="n">variables</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;coords&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;data_vars&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">variable_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;dims&quot;</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;attrs&quot;</span><span class="p">),</span> <span class="n">v</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;encoding&quot;</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span>
            <span class="p">}</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot convert dict without the key &#39;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">variable_dict</span><span class="p">)</span>

        <span class="c1"># what if coords aren&#39;t dims?</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;coords&quot;</span><span class="p">,</span> <span class="p">{}))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dims&quot;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">set_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;attrs&quot;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;encoding&quot;</span><span class="p">,</span> <span class="p">{}))</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_unary_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">keep_attrs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;keep_attrs&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep_attrs</span> <span class="o">=</span> <span class="n">_get_keep_attrs</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">keep_attrs</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">_attrs</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="k">if</span> <span class="n">keep_attrs</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_binary_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">reflexive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>
        <span class="kn">from</span> <span class="nn">xarray.core.groupby</span> <span class="kn">import</span> <span class="n">GroupBy</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">GroupBy</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="n">align_type</span> <span class="o">=</span> <span class="n">OPTIONS</span><span class="p">[</span><span class="s2">&quot;arithmetic_join&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">join</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">join</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataArray</span> <span class="o">|</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">align_type</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">f</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">reflexive</span> <span class="k">else</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_binary_op</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">align_type</span><span class="p">)</span>
        <span class="n">keep_attrs</span> <span class="o">=</span> <span class="n">_get_keep_attrs</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep_attrs</span><span class="p">:</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span>
        <span class="k">return</span> <span class="n">ds</span>

    <span class="k">def</span> <span class="nf">_inplace_binary_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>
        <span class="kn">from</span> <span class="nn">xarray.core.groupby</span> <span class="kn">import</span> <span class="n">GroupBy</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">GroupBy</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;in-place operations between a Dataset and &quot;</span>
                <span class="s2">&quot;a grouped object are not permitted&quot;</span>
            <span class="p">)</span>
        <span class="c1"># we don&#39;t actually modify arrays in-place with in-place Dataset</span>
        <span class="c1"># arithmetic -- this lets us automatically align things</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataArray</span> <span class="o">|</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">inplace_to_noninplace_op</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_binary_op</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">_coord_names</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">_indexes</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_calculate_binary_op</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">apply_over_both</span><span class="p">(</span><span class="n">lhs_data_vars</span><span class="p">,</span> <span class="n">rhs_data_vars</span><span class="p">,</span> <span class="n">lhs_vars</span><span class="p">,</span> <span class="n">rhs_vars</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">inplace</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="n">lhs_data_vars</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">rhs_data_vars</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;datasets must have the same data variables &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for in-place arithmetic operations: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">lhs_data_vars</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">rhs_data_vars</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">dest_vars</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lhs_data_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rhs_data_vars</span><span class="p">:</span>
                    <span class="n">dest_vars</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">lhs_vars</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">rhs_vars</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">join</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;outer&quot;</span><span class="p">]:</span>
                    <span class="n">dest_vars</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">lhs_vars</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rhs_data_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dest_vars</span> <span class="ow">and</span> <span class="n">join</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;outer&quot;</span><span class="p">]:</span>
                    <span class="n">dest_vars</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">rhs_vars</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dest_vars</span>

        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="c1"># can&#39;t use our shortcut of doing the binary operation with</span>
            <span class="c1"># Variable objects, so apply over our data vars instead.</span>
            <span class="n">new_data_vars</span> <span class="o">=</span> <span class="n">apply_over_both</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="n">other</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_data_vars</span><span class="p">)</span>

        <span class="n">other_coords</span><span class="p">:</span> <span class="n">Coordinates</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;coords&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">other_coords</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="n">new_vars</span> <span class="o">=</span> <span class="n">apply_over_both</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">variables</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_variable</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="n">new_vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">other_variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_vars</span><span class="p">)</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="n">calculate_dimensions</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ds</span>

    <span class="k">def</span> <span class="nf">_copy_attrs_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">attrs</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span>

    <span class="nd">@_deprecate_positional_args</span><span class="p">(</span><span class="s2">&quot;v2023.10.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;upper&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the n-th order discrete difference along given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : Hashable</span>
<span class="sd">            Dimension over which to calculate the finite difference.</span>
<span class="sd">        n : int, default: 1</span>
<span class="sd">            The number of times values are differenced.</span>
<span class="sd">        label : {&quot;upper&quot;, &quot;lower&quot;}, default: &quot;upper&quot;</span>
<span class="sd">            The new coordinate in dimension ``dim`` will have the</span>
<span class="sd">            values of either the minuend&#39;s or subtrahend&#39;s coordinate</span>
<span class="sd">            for values &#39;upper&#39; and &#39;lower&#39;, respectively.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        difference : Dataset</span>
<span class="sd">            The n-th order finite difference of this object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        `n` matches numpy&#39;s behavior and is different from pandas&#39; first argument named</span>
<span class="sd">        `periods`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;foo&quot;: (&quot;x&quot;, [5, 5, 6, 6])})</span>
<span class="sd">        &gt;&gt;&gt; ds.diff(&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 24B</span>
<span class="sd">        Dimensions:  (x: 3)</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (x) int64 24B 0 1 0</span>
<span class="sd">        &gt;&gt;&gt; ds.diff(&quot;x&quot;, 2)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 16B</span>
<span class="sd">        Dimensions:  (x: 2)</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (x) int64 16B 1 -1</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.differentiate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;order `n` must be non-negative but got </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># prepare slices</span>
        <span class="n">slice_start</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)}</span>
        <span class="n">slice_end</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)}</span>

        <span class="c1"># prepare new coordinate</span>
        <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">slice_new</span> <span class="o">=</span> <span class="n">slice_end</span>
        <span class="k">elif</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">slice_new</span> <span class="o">=</span> <span class="n">slice_start</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The &#39;label&#39; argument has to be either &#39;upper&#39; or &#39;lower&#39;&quot;</span><span class="p">)</span>

        <span class="n">indexes</span><span class="p">,</span> <span class="n">index_vars</span> <span class="o">=</span> <span class="n">isel_indexes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">,</span> <span class="n">slice_new</span><span class="p">)</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">index_vars</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">slice_end</span><span class="p">)</span> <span class="o">-</span> <span class="n">var</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">slice_start</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">slice_new</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="n">difference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">difference</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">difference</span>

    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shifts</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">xrdtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="o">**</span><span class="n">shifts_kwargs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shift this dataset by an offset along one or more dimensions.</span>

<span class="sd">        Only data variables are moved; coordinates stay in place. This is</span>
<span class="sd">        consistent with the behavior of ``shift`` in pandas.</span>

<span class="sd">        Values shifted from beyond array bounds will appear at one end of</span>
<span class="sd">        each dimension, which are filled according to `fill_value`. For periodic</span>
<span class="sd">        offsets instead see `roll`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shifts : mapping of hashable to int</span>
<span class="sd">            Integer offset to shift along each of the given dimensions.</span>
<span class="sd">            Positive offsets shift to the right; negative offsets shift to the</span>
<span class="sd">            left.</span>
<span class="sd">        fill_value : scalar or dict-like, optional</span>
<span class="sd">            Value to use for newly missing values. If a dict-like, maps</span>
<span class="sd">            variable names (including coordinates) to fill values.</span>
<span class="sd">        **shifts_kwargs</span>
<span class="sd">            The keyword arguments form of ``shifts``.</span>
<span class="sd">            One of shifts or shifts_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifted : Dataset</span>
<span class="sd">            Dataset with the same coordinates and attributes but shifted data</span>
<span class="sd">            variables.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        roll</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;foo&quot;: (&quot;x&quot;, list(&quot;abcde&quot;))})</span>
<span class="sd">        &gt;&gt;&gt; ds.shift(x=2)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 40B</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (x) object 40B nan nan &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span> <span class="n">shifts_kwargs</span><span class="p">,</span> <span class="s2">&quot;shift&quot;</span><span class="p">)</span>
        <span class="n">invalid</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">shifts</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">invalid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Dimensions </span><span class="si">{</span><span class="n">invalid</span><span class="si">}</span><span class="s2"> not found in data dimensions </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                <span class="n">fill_value_</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">fill_value</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">xrdtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
                    <span class="k">else</span> <span class="n">fill_value</span>
                <span class="p">)</span>

                <span class="n">var_shifts</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">shifts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value_</span><span class="p">,</span> <span class="n">shifts</span><span class="o">=</span><span class="n">var_shifts</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">roll</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shifts</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">roll_coords</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">shifts_kwargs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Roll this dataset by an offset along one or more dimensions.</span>

<span class="sd">        Unlike shift, roll treats the given dimensions as periodic, so will not</span>
<span class="sd">        create any missing values to be filled.</span>

<span class="sd">        Also unlike shift, roll may rotate all variables, including coordinates</span>
<span class="sd">        if specified. The direction of rotation is consistent with</span>
<span class="sd">        :py:func:`numpy.roll`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shifts : mapping of hashable to int, optional</span>
<span class="sd">            A dict with keys matching dimensions and values given</span>
<span class="sd">            by integers to rotate each of the given dimensions. Positive</span>
<span class="sd">            offsets roll to the right; negative offsets roll to the left.</span>
<span class="sd">        roll_coords : bool, default: False</span>
<span class="sd">            Indicates whether to roll the coordinates by the offset too.</span>
<span class="sd">        **shifts_kwargs : {dim: offset, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``shifts``.</span>
<span class="sd">            One of shifts or shifts_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rolled : Dataset</span>
<span class="sd">            Dataset with the same attributes but rolled data and coordinates.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        shift</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;foo&quot;: (&quot;x&quot;, list(&quot;abcde&quot;))}, coords={&quot;x&quot;: np.arange(5)})</span>
<span class="sd">        &gt;&gt;&gt; ds.roll(x=2)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 60B</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 40B 0 1 2 3 4</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (x) &lt;U1 20B &#39;d&#39; &#39;e&#39; &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>

<span class="sd">        &gt;&gt;&gt; ds.roll(x=2, roll_coords=True)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 60B</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 40B 3 4 0 1 2</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (x) &lt;U1 20B &#39;d&#39; &#39;e&#39; &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span> <span class="n">shifts_kwargs</span><span class="p">,</span> <span class="s2">&quot;roll&quot;</span><span class="p">)</span>
        <span class="n">invalid</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">shifts</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">invalid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Dimensions </span><span class="si">{</span><span class="n">invalid</span><span class="si">}</span><span class="s2"> not found in data dimensions </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">unrolled_vars</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">roll_coords</span><span class="p">:</span>
            <span class="n">indexes</span><span class="p">,</span> <span class="n">index_vars</span> <span class="o">=</span> <span class="n">roll_indexes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="p">,</span> <span class="n">shifts</span><span class="p">)</span>
            <span class="n">unrolled_vars</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>
            <span class="n">index_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
            <span class="n">unrolled_vars</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">index_vars</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_vars</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unrolled_vars</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span>
                    <span class="n">shifts</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">s</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shifts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sortby</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">Hashable</span>
            <span class="o">|</span> <span class="n">DataArray</span>
            <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span> <span class="o">|</span> <span class="n">DataArray</span><span class="p">]</span>
            <span class="o">|</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Self</span><span class="p">],</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">DataArray</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span> <span class="o">|</span> <span class="n">DataArray</span><span class="p">]]</span>
        <span class="p">),</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort object by labels or values (along an axis).</span>

<span class="sd">        Sorts the dataset, either along specified dimensions,</span>
<span class="sd">        or according to values of 1-D dataarrays that share dimension</span>
<span class="sd">        with calling object.</span>

<span class="sd">        If the input variables are dataarrays, then the dataarrays are aligned</span>
<span class="sd">        (via left-join) to the calling object prior to sorting by cell values.</span>
<span class="sd">        NaNs are sorted to the end, following Numpy convention.</span>

<span class="sd">        If multiple sorts along the same dimension is</span>
<span class="sd">        given, numpy&#39;s lexsort is performed along that dimension:</span>
<span class="sd">        https://numpy.org/doc/stable/reference/generated/numpy.lexsort.html</span>
<span class="sd">        and the FIRST key in the sequence is used as the primary sort key,</span>
<span class="sd">        followed by the 2nd key, etc.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variables : Hashable, DataArray, sequence of Hashable or DataArray, or Callable</span>
<span class="sd">            1D DataArray objects or name(s) of 1D variable(s) in coords whose values are</span>
<span class="sd">            used to sort this array. If a callable, the callable is passed this object,</span>
<span class="sd">            and the result is used as the value for cond.</span>
<span class="sd">        ascending : bool, default: True</span>
<span class="sd">            Whether to sort by ascending or descending order.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorted : Dataset</span>
<span class="sd">            A new dataset where all the specified dims are sorted by dim</span>
<span class="sd">            labels.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.sortby</span>
<span class="sd">        numpy.sort</span>
<span class="sd">        pandas.sort_values</span>
<span class="sd">        pandas.sort_index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;A&quot;: ((&quot;x&quot;, &quot;y&quot;), [[1, 2], [3, 4]]),</span>
<span class="sd">        ...         &quot;B&quot;: ((&quot;x&quot;, &quot;y&quot;), [[5, 6], [7, 8]]),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={&quot;x&quot;: [&quot;b&quot;, &quot;a&quot;], &quot;y&quot;: [1, 0]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds.sortby(&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 88B</span>
<span class="sd">        Dimensions:  (x: 2, y: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U1 8B &#39;a&#39; &#39;b&#39;</span>
<span class="sd">          * y        (y) int64 16B 1 0</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x, y) int64 32B 3 4 1 2</span>
<span class="sd">            B        (x, y) int64 32B 7 8 5 6</span>
<span class="sd">        &gt;&gt;&gt; ds.sortby(lambda x: -x[&quot;y&quot;])</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 88B</span>
<span class="sd">        Dimensions:  (x: 2, y: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U1 8B &#39;b&#39; &#39;a&#39;</span>
<span class="sd">          * y        (y) int64 16B 1 0</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (x, y) int64 32B 1 2 3 4</span>
<span class="sd">            B        (x, y) int64 32B 5 6 7 8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">variables</span><span class="p">):</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="n">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">variables</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">]</span>
        <span class="n">aligned_vars</span> <span class="o">=</span> <span class="n">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">aligned_self</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;Self&quot;</span><span class="p">,</span> <span class="n">aligned_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">aligned_other_vars</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">tuple</span><span class="p">[</span><span class="n">DataArray</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">aligned_vars</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">vars_by_dim</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">data_array</span> <span class="ow">in</span> <span class="n">aligned_other_vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input DataArray is not 1-D.&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="n">key</span><span class="p">,)</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">dims</span>
            <span class="n">vars_by_dim</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">arrays</span> <span class="ow">in</span> <span class="n">vars_by_dim</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">arrays</span><span class="p">)))</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span> <span class="k">if</span> <span class="n">ascending</span> <span class="k">else</span> <span class="n">order</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">aligned_self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

    <span class="nd">@_deprecate_positional_args</span><span class="p">(</span><span class="s2">&quot;v2023.10.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">QuantileMethods</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">interpolation</span><span class="p">:</span> <span class="n">QuantileMethods</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the qth quantile of the data along the specified dimension.</span>

<span class="sd">        Returns the qth quantiles(s) of the array elements for each variable</span>
<span class="sd">        in the Dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q : float or array-like of float</span>
<span class="sd">            Quantile to compute, which must be between 0 and 1 inclusive.</span>
<span class="sd">        dim : str or Iterable of Hashable, optional</span>
<span class="sd">            Dimension(s) over which to apply quantile.</span>
<span class="sd">        method : str, default: &quot;linear&quot;</span>
<span class="sd">            This optional parameter specifies the interpolation method to use when the</span>
<span class="sd">            desired quantile lies between two data points. The options sorted by their R</span>
<span class="sd">            type as summarized in the H&amp;F paper [1]_ are:</span>

<span class="sd">                1. &quot;inverted_cdf&quot;</span>
<span class="sd">                2. &quot;averaged_inverted_cdf&quot;</span>
<span class="sd">                3. &quot;closest_observation&quot;</span>
<span class="sd">                4. &quot;interpolated_inverted_cdf&quot;</span>
<span class="sd">                5. &quot;hazen&quot;</span>
<span class="sd">                6. &quot;weibull&quot;</span>
<span class="sd">                7. &quot;linear&quot;  (default)</span>
<span class="sd">                8. &quot;median_unbiased&quot;</span>
<span class="sd">                9. &quot;normal_unbiased&quot;</span>

<span class="sd">            The first three methods are discontiuous.  The following discontinuous</span>
<span class="sd">            variations of the default &quot;linear&quot; (7.) option are also available:</span>

<span class="sd">                * &quot;lower&quot;</span>
<span class="sd">                * &quot;higher&quot;</span>
<span class="sd">                * &quot;midpoint&quot;</span>
<span class="sd">                * &quot;nearest&quot;</span>

<span class="sd">            See :py:func:`numpy.quantile` or [1]_ for details. The &quot;method&quot; argument</span>
<span class="sd">            was previously called &quot;interpolation&quot;, renamed in accordance with numpy</span>
<span class="sd">            version 1.22.0.</span>

<span class="sd">        keep_attrs : bool, optional</span>
<span class="sd">            If True, the dataset&#39;s attributes (`attrs`) will be copied from</span>
<span class="sd">            the original object to the new one.  If False (default), the new</span>
<span class="sd">            object will be returned without attributes.</span>
<span class="sd">        numeric_only : bool, optional</span>
<span class="sd">            If True, only apply ``func`` to variables with a numeric dtype.</span>
<span class="sd">        skipna : bool, optional</span>
<span class="sd">            If True, skip missing values (as marked by NaN). By default, only</span>
<span class="sd">            skips missing values for float dtypes; other dtypes either do not</span>
<span class="sd">            have a sentinel missing value (int) or skipna=True has not been</span>
<span class="sd">            implemented (object, datetime64 or timedelta64).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        quantiles : Dataset</span>
<span class="sd">            If `q` is a single quantile, then the result is a scalar for each</span>
<span class="sd">            variable in data_vars. If multiple percentiles are given, first</span>
<span class="sd">            axis of the result corresponds to the quantile and a quantile</span>
<span class="sd">            dimension is added to the return Dataset. The other dimensions are</span>
<span class="sd">            the dimensions that remain after the reduction of the array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.nanquantile, numpy.quantile, pandas.Series.quantile, DataArray.quantile</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     {&quot;a&quot;: ((&quot;x&quot;, &quot;y&quot;), [[0.7, 4.2, 9.4, 1.5], [6.5, 7.3, 2.6, 1.9]])},</span>
<span class="sd">        ...     coords={&quot;x&quot;: [7, 9], &quot;y&quot;: [1, 1.5, 2, 2.5]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds.quantile(0)  # or ds.quantile(0, dim=...)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 16B</span>
<span class="sd">        Dimensions:   ()</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            quantile  float64 8B 0.0</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a         float64 8B 0.7</span>
<span class="sd">        &gt;&gt;&gt; ds.quantile(0, dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 72B</span>
<span class="sd">        Dimensions:   (y: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y         (y) float64 32B 1.0 1.5 2.0 2.5</span>
<span class="sd">            quantile  float64 8B 0.0</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a         (y) float64 32B 0.7 4.2 2.6 1.5</span>
<span class="sd">        &gt;&gt;&gt; ds.quantile([0, 0.5, 1])</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 48B</span>
<span class="sd">        Dimensions:   (quantile: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * quantile  (quantile) float64 24B 0.0 0.5 1.0</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a         (quantile) float64 24B 0.7 3.4 9.4</span>
<span class="sd">        &gt;&gt;&gt; ds.quantile([0, 0.5, 1], dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 152B</span>
<span class="sd">        Dimensions:   (quantile: 3, y: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y         (y) float64 32B 1.0 1.5 2.0 2.5</span>
<span class="sd">          * quantile  (quantile) float64 24B 0.0 0.5 1.0</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a         (quantile, y) float64 96B 0.7 4.2 2.6 1.5 3.6 ... 6.5 7.3 9.4 1.9</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] R. J. Hyndman and Y. Fan,</span>
<span class="sd">           &quot;Sample quantiles in statistical packages,&quot;</span>
<span class="sd">           The American Statistician, 50(4), pp. 361-365, 1996</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># interpolation renamed to method in version 0.21.0</span>
        <span class="c1"># check here and in variable to avoid repeated warnings</span>
        <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The `interpolation` argument to quantile was renamed to `method`.&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot pass interpolation and method keywords!&quot;</span><span class="p">)</span>

            <span class="n">method</span> <span class="o">=</span> <span class="n">interpolation</span>

        <span class="n">dims</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dim</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="n">invalid_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">invalid_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Dimensions </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">invalid_dims</span><span class="p">)</span><span class="si">}</span><span class="s2"> not found in data dimensions </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">reduce_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">reduce_dims</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="ow">not</span> <span class="n">numeric_only</span>
                        <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span>
                    <span class="p">):</span>
                        <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>
                            <span class="n">q</span><span class="p">,</span>
                            <span class="n">dim</span><span class="o">=</span><span class="n">reduce_dims</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                            <span class="n">keep_attrs</span><span class="o">=</span><span class="n">keep_attrs</span><span class="p">,</span>
                            <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                        <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="c1"># construct the new dataset</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">}</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">keep_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep_attrs</span> <span class="o">=</span> <span class="n">_get_keep_attrs</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="k">if</span> <span class="n">keep_attrs</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">quantile</span><span class="o">=</span><span class="n">q</span><span class="p">)</span>

    <span class="nd">@_deprecate_positional_args</span><span class="p">(</span><span class="s2">&quot;v2023.10.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">pct</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ranks the data.</span>

<span class="sd">        Equal values are assigned a rank that is the average of the ranks that</span>
<span class="sd">        would have been otherwise assigned to all of the values within</span>
<span class="sd">        that set.</span>
<span class="sd">        Ranks begin at 1, not 0. If pct is True, computes percentage ranks.</span>

<span class="sd">        NaNs in the input array are returned as NaNs.</span>

<span class="sd">        The `bottleneck` library is required.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : Hashable</span>
<span class="sd">            Dimension over which to compute rank.</span>
<span class="sd">        pct : bool, default: False</span>
<span class="sd">            If True, compute percentage ranks, otherwise compute integer ranks.</span>
<span class="sd">        keep_attrs : bool or None, optional</span>
<span class="sd">            If True, the dataset&#39;s attributes (`attrs`) will be copied from</span>
<span class="sd">            the original object to the new one.  If False, the new</span>
<span class="sd">            object will be returned without attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ranked : Dataset</span>
<span class="sd">            Variables that do not depend on `dim` are dropped.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">OPTIONS</span><span class="p">[</span><span class="s2">&quot;use_bottleneck&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;rank requires bottleneck to be enabled.&quot;</span>
                <span class="s2">&quot; Call `xr.set_options(use_bottleneck=True)` to enable it.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">!r}</span><span class="s2"> not found in data dimensions </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">pct</span><span class="o">=</span><span class="n">pct</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep_attrs</span> <span class="o">=</span> <span class="n">_get_keep_attrs</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="k">if</span> <span class="n">keep_attrs</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coord</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="n">edge_order</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">datetime_unit</span><span class="p">:</span> <span class="n">DatetimeUnitOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate with the second order accurate central</span>
<span class="sd">        differences.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This feature is limited to simple cartesian geometry, i.e. coord</span>
<span class="sd">            must be one dimensional.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord : Hashable</span>
<span class="sd">            The coordinate to be used to compute the gradient.</span>
<span class="sd">        edge_order : {1, 2}, default: 1</span>
<span class="sd">            N-th order accurate differences at the boundaries.</span>
<span class="sd">        datetime_unit : None or {&quot;Y&quot;, &quot;M&quot;, &quot;W&quot;, &quot;D&quot;, &quot;h&quot;, &quot;m&quot;, &quot;s&quot;, &quot;ms&quot;, \</span>
<span class="sd">            &quot;us&quot;, &quot;ns&quot;, &quot;ps&quot;, &quot;fs&quot;, &quot;as&quot;, None}, default: None</span>
<span class="sd">            Unit to compute gradient. Only valid for datetime coordinate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        differentiated: Dataset</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.gradient: corresponding numpy function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.variable</span> <span class="kn">import</span> <span class="n">Variable</span>

        <span class="k">if</span> <span class="n">coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="ow">and</span> <span class="n">coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">variables_and_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Coordinate </span><span class="si">{</span><span class="n">coord</span><span class="si">!r}</span><span class="s2"> not found in variables or dimensions </span><span class="si">{</span><span class="n">variables_and_dims</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="n">coord_var</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span><span class="o">.</span><span class="n">variable</span>
        <span class="k">if</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Coordinate </span><span class="si">{</span><span class="n">coord</span><span class="si">}</span><span class="s2"> must be 1 dimensional but is </span><span class="si">{</span><span class="n">coord_var</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="s2">&quot; dimensional&quot;</span>
            <span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">_contains_datetime_like_objects</span><span class="p">(</span><span class="n">coord_var</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;mM&quot;</span> <span class="ow">and</span> <span class="n">datetime_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">datetime_unit</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="s2">&quot;DatetimeUnitOptions&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime_data</span><span class="p">(</span><span class="n">coord_var</span><span class="o">.</span><span class="n">dtype</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">datetime_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">datetime_unit</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span>  <span class="c1"># Default to seconds for cftime objects</span>
            <span class="n">coord_var</span> <span class="o">=</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">_to_numeric</span><span class="p">(</span><span class="n">datetime_unit</span><span class="o">=</span><span class="n">datetime_unit</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span> <span class="ow">and</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_contains_datetime_like_objects</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">_to_numeric</span><span class="p">(</span><span class="n">datetime_unit</span><span class="o">=</span><span class="n">datetime_unit</span><span class="p">)</span>
                <span class="n">grad</span> <span class="o">=</span> <span class="n">duck_array_ops</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">coord_var</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">get_axis_num</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">grad</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coord</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="n">datetime_unit</span><span class="p">:</span> <span class="n">DatetimeUnitOptions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Integrate along the given coordinate using the trapezoidal rule.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This feature is limited to simple cartesian geometry, i.e. coord</span>
<span class="sd">            must be one dimensional.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord : hashable, or sequence of hashable</span>
<span class="sd">            Coordinate(s) used for the integration.</span>
<span class="sd">        datetime_unit : {&#39;Y&#39;, &#39;M&#39;, &#39;W&#39;, &#39;D&#39;, &#39;h&#39;, &#39;m&#39;, &#39;s&#39;, &#39;ms&#39;, &#39;us&#39;, &#39;ns&#39;, \</span>
<span class="sd">                        &#39;ps&#39;, &#39;fs&#39;, &#39;as&#39;, None}, optional</span>
<span class="sd">            Specify the unit if datetime coordinate is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        integrated : Dataset</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.integrate</span>
<span class="sd">        numpy.trapz : corresponding numpy function</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     data_vars={&quot;a&quot;: (&quot;x&quot;, [5, 5, 6, 6]), &quot;b&quot;: (&quot;x&quot;, [1, 2, 1, 0])},</span>
<span class="sd">        ...     coords={&quot;x&quot;: [0, 1, 2, 3], &quot;y&quot;: (&quot;x&quot;, [1, 7, 3, 5])},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 128B</span>
<span class="sd">        Dimensions:  (x: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 32B 0 1 2 3</span>
<span class="sd">            y        (x) int64 32B 1 7 3 5</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) int64 32B 5 5 6 6</span>
<span class="sd">            b        (x) int64 32B 1 2 1 0</span>
<span class="sd">        &gt;&gt;&gt; ds.integrate(&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 16B</span>
<span class="sd">        Dimensions:  ()</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        float64 8B 16.5</span>
<span class="sd">            b        float64 8B 3.5</span>
<span class="sd">        &gt;&gt;&gt; ds.integrate(&quot;y&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 16B</span>
<span class="sd">        Dimensions:  ()</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        float64 8B 20.0</span>
<span class="sd">            b        float64 8B 4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="p">(</span><span class="n">coord</span><span class="p">,)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coord</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_integrate_one</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">datetime_unit</span><span class="o">=</span><span class="n">datetime_unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_integrate_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">datetime_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">xarray.core.variable</span> <span class="kn">import</span> <span class="n">Variable</span>

        <span class="k">if</span> <span class="n">coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="ow">and</span> <span class="n">coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">variables_and_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Coordinate </span><span class="si">{</span><span class="n">coord</span><span class="si">!r}</span><span class="s2"> not found in variables or dimensions </span><span class="si">{</span><span class="n">variables_and_dims</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="n">coord_var</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span><span class="o">.</span><span class="n">variable</span>
        <span class="k">if</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Coordinate </span><span class="si">{</span><span class="n">coord</span><span class="si">}</span><span class="s2"> must be 1 dimensional but is </span><span class="si">{</span><span class="n">coord_var</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="s2">&quot; dimensional&quot;</span>
            <span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">_contains_datetime_like_objects</span><span class="p">(</span><span class="n">coord_var</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;mM&quot;</span> <span class="ow">and</span> <span class="n">datetime_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">datetime_unit</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime_data</span><span class="p">(</span><span class="n">coord_var</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">datetime_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">datetime_unit</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span>  <span class="c1"># Default to seconds for cftime objects</span>
            <span class="n">coord_var</span> <span class="o">=</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">datetime_to_numeric</span><span class="p">(</span><span class="n">coord_var</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">datetime_unit</span><span class="o">=</span><span class="n">datetime_unit</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span> <span class="ow">or</span> <span class="n">cumulative</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="n">coord_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span> <span class="ow">and</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">_contains_datetime_like_objects</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">datetime_to_numeric</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">datetime_unit</span><span class="o">=</span><span class="n">datetime_unit</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cumulative</span><span class="p">:</span>
                        <span class="n">integ</span> <span class="o">=</span> <span class="n">duck_array_ops</span><span class="o">.</span><span class="n">cumulative_trapezoid</span><span class="p">(</span>
                            <span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">get_axis_num</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">v_dims</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">integ</span> <span class="o">=</span> <span class="n">duck_array_ops</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span>
                            <span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">coord_var</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">get_axis_num</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">v_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
                        <span class="n">v_dims</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">v_dims</span><span class="p">,</span> <span class="n">integ</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span>
            <span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="o">=</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">cumulative_integrate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coord</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="n">datetime_unit</span><span class="p">:</span> <span class="n">DatetimeUnitOptions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Integrate along the given coordinate using the trapezoidal rule.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This feature is limited to simple cartesian geometry, i.e. coord</span>
<span class="sd">            must be one dimensional.</span>

<span class="sd">            The first entry of the cumulative integral of each variable is always 0, in</span>
<span class="sd">            order to keep the length of the dimension unchanged between input and</span>
<span class="sd">            output.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord : hashable, or sequence of hashable</span>
<span class="sd">            Coordinate(s) used for the integration.</span>
<span class="sd">        datetime_unit : {&#39;Y&#39;, &#39;M&#39;, &#39;W&#39;, &#39;D&#39;, &#39;h&#39;, &#39;m&#39;, &#39;s&#39;, &#39;ms&#39;, &#39;us&#39;, &#39;ns&#39;, \</span>
<span class="sd">                        &#39;ps&#39;, &#39;fs&#39;, &#39;as&#39;, None}, optional</span>
<span class="sd">            Specify the unit if datetime coordinate is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        integrated : Dataset</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.cumulative_integrate</span>
<span class="sd">        scipy.integrate.cumulative_trapezoid : corresponding scipy function</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     data_vars={&quot;a&quot;: (&quot;x&quot;, [5, 5, 6, 6]), &quot;b&quot;: (&quot;x&quot;, [1, 2, 1, 0])},</span>
<span class="sd">        ...     coords={&quot;x&quot;: [0, 1, 2, 3], &quot;y&quot;: (&quot;x&quot;, [1, 7, 3, 5])},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 128B</span>
<span class="sd">        Dimensions:  (x: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 32B 0 1 2 3</span>
<span class="sd">            y        (x) int64 32B 1 7 3 5</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) int64 32B 5 5 6 6</span>
<span class="sd">            b        (x) int64 32B 1 2 1 0</span>
<span class="sd">        &gt;&gt;&gt; ds.cumulative_integrate(&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 128B</span>
<span class="sd">        Dimensions:  (x: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 32B 0 1 2 3</span>
<span class="sd">            y        (x) int64 32B 1 7 3 5</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) float64 32B 0.0 5.0 10.5 16.5</span>
<span class="sd">            b        (x) float64 32B 0.0 1.5 3.0 3.5</span>
<span class="sd">        &gt;&gt;&gt; ds.cumulative_integrate(&quot;y&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 128B</span>
<span class="sd">        Dimensions:  (x: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 32B 0 1 2 3</span>
<span class="sd">            y        (x) int64 32B 1 7 3 5</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) float64 32B 0.0 30.0 8.0 20.0</span>
<span class="sd">            b        (x) float64 32B 0.0 9.0 3.0 4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="p">(</span><span class="n">coord</span><span class="p">,)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coord</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_integrate_one</span><span class="p">(</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">datetime_unit</span><span class="o">=</span><span class="n">datetime_unit</span><span class="p">,</span> <span class="n">cumulative</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The real part of each data variable.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.real</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">keep_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The imaginary part of each data variable.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.imag</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">keep_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">plot</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">UncachedAccessor</span><span class="p">(</span><span class="n">DatasetPlotAccessor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">filter_by_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``Dataset`` with variables that match specific conditions.</span>

<span class="sd">        Can pass in ``key=value`` or ``key=callable``.  A Dataset is returned</span>
<span class="sd">        containing only the variables for which all the filter tests pass.</span>
<span class="sd">        These tests are either ``key=value`` for which the attribute ``key``</span>
<span class="sd">        has the exact value ``value`` or the callable passed into</span>
<span class="sd">        ``key=callable`` returns True. The callable will be passed a single</span>
<span class="sd">        value, either the value of the attribute ``key`` or ``None`` if the</span>
<span class="sd">        DataArray does not have an attribute with the name ``key``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            key : str</span>
<span class="sd">                Attribute name.</span>
<span class="sd">            value : callable or obj</span>
<span class="sd">                If value is a callable, it should return a boolean in the form</span>
<span class="sd">                of bool = func(attr) where attr is da.attrs[key].</span>
<span class="sd">                Otherwise, value will be compared to the each</span>
<span class="sd">                DataArray&#39;s attrs[key].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new : Dataset</span>
<span class="sd">            New dataset with variables filtered by attribute.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; temp = 15 + 8 * np.random.randn(2, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; precip = 10 * np.random.rand(2, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; lon = [[-99.83, -99.32], [-99.79, -99.23]]</span>
<span class="sd">        &gt;&gt;&gt; lat = [[42.25, 42.21], [42.63, 42.59]]</span>
<span class="sd">        &gt;&gt;&gt; dims = [&quot;x&quot;, &quot;y&quot;, &quot;time&quot;]</span>
<span class="sd">        &gt;&gt;&gt; temp_attr = dict(standard_name=&quot;air_potential_temperature&quot;)</span>
<span class="sd">        &gt;&gt;&gt; precip_attr = dict(standard_name=&quot;convective_precipitation_flux&quot;)</span>

<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     dict(</span>
<span class="sd">        ...         temperature=(dims, temp, temp_attr),</span>
<span class="sd">        ...         precipitation=(dims, precip, precip_attr),</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ...     coords=dict(</span>
<span class="sd">        ...         lon=([&quot;x&quot;, &quot;y&quot;], lon),</span>
<span class="sd">        ...         lat=([&quot;x&quot;, &quot;y&quot;], lat),</span>
<span class="sd">        ...         time=pd.date_range(&quot;2014-09-06&quot;, periods=3),</span>
<span class="sd">        ...         reference_time=pd.Timestamp(&quot;2014-09-05&quot;),</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ... )</span>

<span class="sd">        Get variables matching a specific standard_name:</span>

<span class="sd">        &gt;&gt;&gt; ds.filter_by_attrs(standard_name=&quot;convective_precipitation_flux&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 192B</span>
<span class="sd">        Dimensions:         (x: 2, y: 2, time: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            lon             (x, y) float64 32B -99.83 -99.32 -99.79 -99.23</span>
<span class="sd">            lat             (x, y) float64 32B 42.25 42.21 42.63 42.59</span>
<span class="sd">          * time            (time) datetime64[ns] 24B 2014-09-06 2014-09-07 2014-09-08</span>
<span class="sd">            reference_time  datetime64[ns] 8B 2014-09-05</span>
<span class="sd">        Dimensions without coordinates: x, y</span>
<span class="sd">        Data variables:</span>
<span class="sd">            precipitation   (x, y, time) float64 96B 5.68 9.256 0.7104 ... 4.615 7.805</span>

<span class="sd">        Get all variables that have a standard_name attribute:</span>

<span class="sd">        &gt;&gt;&gt; standard_name = lambda v: v is not None</span>
<span class="sd">        &gt;&gt;&gt; ds.filter_by_attrs(standard_name=standard_name)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 288B</span>
<span class="sd">        Dimensions:         (x: 2, y: 2, time: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            lon             (x, y) float64 32B -99.83 -99.32 -99.79 -99.23</span>
<span class="sd">            lat             (x, y) float64 32B 42.25 42.21 42.63 42.59</span>
<span class="sd">          * time            (time) datetime64[ns] 24B 2014-09-06 2014-09-07 2014-09-08</span>
<span class="sd">            reference_time  datetime64[ns] 8B 2014-09-05</span>
<span class="sd">        Dimensions without coordinates: x, y</span>
<span class="sd">        Data variables:</span>
<span class="sd">            temperature     (x, y, time) float64 96B 29.11 18.2 22.83 ... 16.15 26.63</span>
<span class="sd">            precipitation   (x, y, time) float64 96B 5.68 9.256 0.7104 ... 4.615 7.805</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">has_value_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">attr_value</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">callable</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pattern</span><span class="p">(</span><span class="n">attr_value</span><span class="p">))</span> <span class="ow">or</span> <span class="n">attr_value</span> <span class="o">==</span> <span class="n">pattern</span><span class="p">:</span>
                    <span class="n">has_value_flag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">has_value_flag</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">has_value_flag</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">selection</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">unify_chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unify chunk size along all chunked dimensions of this Dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset with consistent chunk sizes for all dask-array variables</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.array.core.unify_chunks</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">unify_chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">map_blocks</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">T_Xarray</span><span class="p">],</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">template</span><span class="p">:</span> <span class="n">DataArray</span> <span class="o">|</span> <span class="n">Dataset</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T_Xarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a function to each block of this Dataset.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This method is experimental and its signature may change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            User-provided function that accepts a Dataset as its first</span>
<span class="sd">            parameter. The function will receive a subset or &#39;block&#39; of this Dataset (see below),</span>
<span class="sd">            corresponding to one chunk along each chunked dimension. ``func`` will be</span>
<span class="sd">            executed as ``func(subset_dataset, *subset_args, **kwargs)``.</span>

<span class="sd">            This function must return either a single DataArray or a single Dataset.</span>

<span class="sd">            This function cannot add a new chunked dimension.</span>
<span class="sd">        args : sequence</span>
<span class="sd">            Passed to func after unpacking and subsetting any xarray objects by blocks.</span>
<span class="sd">            xarray objects in args must be aligned with obj, otherwise an error is raised.</span>
<span class="sd">        kwargs : Mapping or None</span>
<span class="sd">            Passed verbatim to func after unpacking. xarray objects, if any, will not be</span>
<span class="sd">            subset to blocks. Passing dask collections in kwargs is not allowed.</span>
<span class="sd">        template : DataArray, Dataset or None, optional</span>
<span class="sd">            xarray object representing the final result after compute is called. If not provided,</span>
<span class="sd">            the function will be first run on mocked-up data, that looks like this object but</span>
<span class="sd">            has sizes 0, to determine properties of the returned object such as dtype,</span>
<span class="sd">            variable names, attributes, new dimensions and new indexes (if any).</span>
<span class="sd">            ``template`` must be provided if the function changes the size of existing dimensions.</span>
<span class="sd">            When provided, ``attrs`` on variables in `template` are copied over to the result. Any</span>
<span class="sd">            ``attrs`` set by ``func`` will be ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A single DataArray or Dataset with dask backend, reassembled from the outputs of the</span>
<span class="sd">        function.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function is designed for when ``func`` needs to manipulate a whole xarray object</span>
<span class="sd">        subset to each block. Each block is loaded into memory. In the more common case where</span>
<span class="sd">        ``func`` can work on numpy arrays, it is recommended to use ``apply_ufunc``.</span>

<span class="sd">        If none of the variables in this object is backed by dask arrays, calling this function is</span>
<span class="sd">        equivalent to calling ``func(obj, *args, **kwargs)``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.array.map_blocks, xarray.apply_ufunc, xarray.Dataset.map_blocks</span>
<span class="sd">        xarray.DataArray.map_blocks</span>

<span class="sd">        :doc:`xarray-tutorial:advanced/map_blocks/map_blocks`</span>
<span class="sd">            Advanced Tutorial on map_blocks with dask</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Calculate an anomaly from climatology using ``.groupby()``. Using</span>
<span class="sd">        ``xr.map_blocks()`` allows for parallel operations with knowledge of ``xarray``,</span>
<span class="sd">        its indices, and its methods like ``.groupby()``.</span>

<span class="sd">        &gt;&gt;&gt; def calculate_anomaly(da, groupby_type=&quot;time.month&quot;):</span>
<span class="sd">        ...     gb = da.groupby(groupby_type)</span>
<span class="sd">        ...     clim = gb.mean(dim=&quot;time&quot;)</span>
<span class="sd">        ...     return gb - clim</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; time = xr.cftime_range(&quot;1990-01&quot;, &quot;1992-01&quot;, freq=&quot;ME&quot;)</span>
<span class="sd">        &gt;&gt;&gt; month = xr.DataArray(time.month, coords={&quot;time&quot;: time}, dims=[&quot;time&quot;])</span>
<span class="sd">        &gt;&gt;&gt; np.random.seed(123)</span>
<span class="sd">        &gt;&gt;&gt; array = xr.DataArray(</span>
<span class="sd">        ...     np.random.rand(len(time)),</span>
<span class="sd">        ...     dims=[&quot;time&quot;],</span>
<span class="sd">        ...     coords={&quot;time&quot;: time, &quot;month&quot;: month},</span>
<span class="sd">        ... ).chunk()</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;a&quot;: array})</span>
<span class="sd">        &gt;&gt;&gt; ds.map_blocks(calculate_anomaly, template=ds).compute()</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 576B</span>
<span class="sd">        Dimensions:  (time: 24)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time     (time) object 192B 1990-01-31 00:00:00 ... 1991-12-31 00:00:00</span>
<span class="sd">            month    (time) int64 192B 1 2 3 4 5 6 7 8 9 10 ... 3 4 5 6 7 8 9 10 11 12</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (time) float64 192B 0.1289 0.1132 -0.0856 ... 0.1906 -0.05901</span>

<span class="sd">        Note that one must explicitly use ``args=[]`` and ``kwargs={}`` to pass arguments</span>
<span class="sd">        to the function being applied in ``xr.map_blocks()``:</span>

<span class="sd">        &gt;&gt;&gt; ds.map_blocks(</span>
<span class="sd">        ...     calculate_anomaly,</span>
<span class="sd">        ...     kwargs={&quot;groupby_type&quot;: &quot;time.year&quot;},</span>
<span class="sd">        ...     template=ds,</span>
<span class="sd">        ... )</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 576B</span>
<span class="sd">        Dimensions:  (time: 24)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time     (time) object 192B 1990-01-31 00:00:00 ... 1991-12-31 00:00:00</span>
<span class="sd">            month    (time) int64 192B dask.array&lt;chunksize=(24,), meta=np.ndarray&gt;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (time) float64 192B dask.array&lt;chunksize=(24,), meta=np.ndarray&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.parallel</span> <span class="kn">import</span> <span class="n">map_blocks</span>

        <span class="k">return</span> <span class="n">map_blocks</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">polyfit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="n">deg</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">rcond</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">w</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">full</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cov</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;unscaled&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Least squares polynomial fit.</span>

<span class="sd">        This replicates the behaviour of `numpy.polyfit` but differs by skipping</span>
<span class="sd">        invalid values when `skipna = True`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : hashable</span>
<span class="sd">            Coordinate along which to fit the polynomials.</span>
<span class="sd">        deg : int</span>
<span class="sd">            Degree of the fitting polynomial.</span>
<span class="sd">        skipna : bool or None, optional</span>
<span class="sd">            If True, removes all invalid values before fitting each 1D slices of the array.</span>
<span class="sd">            Default is True if data is stored in a dask.array or if there is any</span>
<span class="sd">            invalid values, False otherwise.</span>
<span class="sd">        rcond : float or None, optional</span>
<span class="sd">            Relative condition number to the fit.</span>
<span class="sd">        w : hashable or Any, optional</span>
<span class="sd">            Weights to apply to the y-coordinate of the sample points.</span>
<span class="sd">            Can be an array-like object or the name of a coordinate in the dataset.</span>
<span class="sd">        full : bool, default: False</span>
<span class="sd">            Whether to return the residuals, matrix rank and singular values in addition</span>
<span class="sd">            to the coefficients.</span>
<span class="sd">        cov : bool or &quot;unscaled&quot;, default: False</span>
<span class="sd">            Whether to return to the covariance matrix in addition to the coefficients.</span>
<span class="sd">            The matrix is not scaled if `cov=&#39;unscaled&#39;`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        polyfit_results : Dataset</span>
<span class="sd">            A single dataset which contains (for each &quot;var&quot; in the input dataset):</span>

<span class="sd">            [var]_polyfit_coefficients</span>
<span class="sd">                The coefficients of the best fit for each variable in this dataset.</span>
<span class="sd">            [var]_polyfit_residuals</span>
<span class="sd">                The residuals of the least-square computation for each variable (only included if `full=True`)</span>
<span class="sd">                When the matrix rank is deficient, np.nan is returned.</span>
<span class="sd">            [dim]_matrix_rank</span>
<span class="sd">                The effective rank of the scaled Vandermonde coefficient matrix (only included if `full=True`)</span>
<span class="sd">                The rank is computed ignoring the NaN values that might be skipped.</span>
<span class="sd">            [dim]_singular_values</span>
<span class="sd">                The singular values of the scaled Vandermonde coefficient matrix (only included if `full=True`)</span>
<span class="sd">            [var]_polyfit_covariance</span>
<span class="sd">                The covariance matrix of the polynomial coefficient estimates (only included if `full=False` and `cov=True`)</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        RankWarning</span>
<span class="sd">            The rank of the coefficient matrix in the least-squares fit is deficient.</span>
<span class="sd">            The warning is not raised with in-memory (not dask) data and `full=True`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.polyfit</span>
<span class="sd">        numpy.polyval</span>
<span class="sd">        xarray.polyval</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">skipna_da</span> <span class="o">=</span> <span class="n">skipna</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">get_clean_interp_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">xname</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_&quot;</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">deg</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rcond</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rcond</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>

        <span class="c1"># Weights:</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">):</span>
                <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected a 1-d array for weights.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected w and </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> to have the same length&quot;</span><span class="p">)</span>
            <span class="n">lhs</span> <span class="o">*=</span> <span class="n">w</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># Scaling</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">lhs</span> <span class="o">*</span> <span class="n">lhs</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">lhs</span> <span class="o">/=</span> <span class="n">scale</span>

        <span class="n">degree_dim</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_temp_dimname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="s2">&quot;degree&quot;</span><span class="p">)</span>

        <span class="n">rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">xname</span> <span class="o">+</span> <span class="s2">&quot;matrix_rank&quot;</span><span class="p">)</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">rank</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">rank</span>
            <span class="n">_sing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">sing</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span>
                <span class="n">_sing</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">degree_dim</span><span class="p">,),</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="n">degree_dim</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">rank</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)},</span>
                <span class="n">name</span><span class="o">=</span><span class="n">xname</span> <span class="o">+</span> <span class="s2">&quot;singular_values&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">sing</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">sing</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">is_duck_dask_array</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">rank</span> <span class="o">!=</span> <span class="n">order</span> <span class="ow">or</span> <span class="n">full</span> <span class="ow">or</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="c1"># Current algorithm with dask and skipna=False neither supports</span>
                <span class="c1"># deficient ranks nor does it output the &quot;full&quot; info (issue dask/dask#6516)</span>
                <span class="n">skipna_da</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">skipna_da</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">isnull</span><span class="p">()))</span>

            <span class="n">dims_to_stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">dimname</span> <span class="k">for</span> <span class="n">dimname</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">dimname</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">]</span>
            <span class="n">stacked_coords</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">dims_to_stack</span><span class="p">:</span>
                <span class="n">stacked_dim</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_temp_dimname</span><span class="p">(</span><span class="n">dims_to_stack</span><span class="p">,</span> <span class="s2">&quot;stacked&quot;</span><span class="p">)</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="o">*</span><span class="n">dims_to_stack</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">stacked_dim</span><span class="p">:</span> <span class="n">dims_to_stack</span><span class="p">}</span>
                <span class="p">)</span>
                <span class="n">stacked_coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">stacked_dim</span><span class="p">:</span> <span class="n">rhs</span><span class="p">[</span><span class="n">stacked_dim</span><span class="p">]}</span>
                <span class="n">scale_da</span> <span class="o">=</span> <span class="n">scale</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">da</span>
                <span class="n">scale_da</span> <span class="o">=</span> <span class="n">scale</span>

            <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span> <span class="o">*</span> <span class="n">w</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">full</span><span class="p">:</span>  <span class="c1"># Copy np.polyfit behavior</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">RankWarning</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Raise only once per variable</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;once&quot;</span><span class="p">,</span> <span class="n">RankWarning</span><span class="p">)</span>

                <span class="n">coeffs</span><span class="p">,</span> <span class="n">residuals</span> <span class="o">=</span> <span class="n">duck_array_ops</span><span class="o">.</span><span class="n">least_squares</span><span class="p">(</span>
                    <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="n">rcond</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna_da</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Thus a ReprObject =&gt; polyfit was called on a DataArray</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

            <span class="n">coeffs</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span>
                <span class="n">coeffs</span> <span class="o">/</span> <span class="n">scale_da</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="n">degree_dim</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">stacked_coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="n">degree_dim</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">order</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">stacked_coords</span><span class="p">},</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;polyfit_coefficients&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">dims_to_stack</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="n">stacked_dim</span><span class="p">)</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">coeffs</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeffs</span>

            <span class="k">if</span> <span class="n">full</span> <span class="ow">or</span> <span class="p">(</span><span class="n">cov</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">):</span>
                <span class="n">residuals</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span>
                    <span class="n">residuals</span> <span class="k">if</span> <span class="n">dims_to_stack</span> <span class="k">else</span> <span class="n">residuals</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
                    <span class="n">dims</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">stacked_coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                    <span class="n">coords</span><span class="o">=</span><span class="n">stacked_coords</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;polyfit_residuals&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">dims_to_stack</span><span class="p">:</span>
                    <span class="n">residuals</span> <span class="o">=</span> <span class="n">residuals</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="n">stacked_dim</span><span class="p">)</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">residuals</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">residuals</span>

            <span class="k">if</span> <span class="n">cov</span><span class="p">:</span>
                <span class="n">Vbase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lhs</span><span class="p">))</span>
                <span class="n">Vbase</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cov</span> <span class="o">==</span> <span class="s2">&quot;unscaled&quot;</span><span class="p">:</span>
                    <span class="n">fac</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">order</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;The number of data points must exceed order to scale the covariance matrix.&quot;</span>
                        <span class="p">)</span>
                    <span class="n">fac</span> <span class="o">=</span> <span class="n">residuals</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">order</span><span class="p">)</span>
                <span class="n">covariance</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">Vbase</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;cov_i&quot;</span><span class="p">,</span> <span class="s2">&quot;cov_j&quot;</span><span class="p">))</span> <span class="o">*</span> <span class="n">fac</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;polyfit_covariance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">covariance</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">data_vars</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">pad</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pad_width</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">PadModeOptions</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
        <span class="n">stat_length</span><span class="p">:</span> <span class="p">(</span>
            <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">constant_values</span><span class="p">:</span> <span class="n">T_DatasetPadConstantValues</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end_values</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reflect_type</span><span class="p">:</span> <span class="n">PadReflectOptions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">pad_width_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pad this dataset along one or more dimensions.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This function is experimental and its behaviour is likely to change</span>
<span class="sd">            especially regarding padding of dimension coordinates (or IndexVariables).</span>

<span class="sd">        When using one of the modes (&quot;edge&quot;, &quot;reflect&quot;, &quot;symmetric&quot;, &quot;wrap&quot;),</span>
<span class="sd">        coordinates will be padded with the same mode, otherwise coordinates</span>
<span class="sd">        are padded using the &quot;constant&quot; mode with fill_value dtypes.NA.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pad_width : mapping of hashable to tuple of int</span>
<span class="sd">            Mapping with the form of {dim: (pad_before, pad_after)}</span>
<span class="sd">            describing the number of values padded along each dimension.</span>
<span class="sd">            {dim: pad} is a shortcut for pad_before = pad_after = pad</span>
<span class="sd">        mode : {&quot;constant&quot;, &quot;edge&quot;, &quot;linear_ramp&quot;, &quot;maximum&quot;, &quot;mean&quot;, &quot;median&quot;, \</span>
<span class="sd">            &quot;minimum&quot;, &quot;reflect&quot;, &quot;symmetric&quot;, &quot;wrap&quot;}, default: &quot;constant&quot;</span>
<span class="sd">            How to pad the DataArray (taken from numpy docs):</span>

<span class="sd">            - &quot;constant&quot;: Pads with a constant value.</span>
<span class="sd">            - &quot;edge&quot;: Pads with the edge values of array.</span>
<span class="sd">            - &quot;linear_ramp&quot;: Pads with the linear ramp between end_value and the</span>
<span class="sd">              array edge value.</span>
<span class="sd">            - &quot;maximum&quot;: Pads with the maximum value of all or part of the</span>
<span class="sd">              vector along each axis.</span>
<span class="sd">            - &quot;mean&quot;: Pads with the mean value of all or part of the</span>
<span class="sd">              vector along each axis.</span>
<span class="sd">            - &quot;median&quot;: Pads with the median value of all or part of the</span>
<span class="sd">              vector along each axis.</span>
<span class="sd">            - &quot;minimum&quot;: Pads with the minimum value of all or part of the</span>
<span class="sd">              vector along each axis.</span>
<span class="sd">            - &quot;reflect&quot;: Pads with the reflection of the vector mirrored on</span>
<span class="sd">              the first and last values of the vector along each axis.</span>
<span class="sd">            - &quot;symmetric&quot;: Pads with the reflection of the vector mirrored</span>
<span class="sd">              along the edge of the array.</span>
<span class="sd">            - &quot;wrap&quot;: Pads with the wrap of the vector along the axis.</span>
<span class="sd">              The first values are used to pad the end and the</span>
<span class="sd">              end values are used to pad the beginning.</span>

<span class="sd">        stat_length : int, tuple or mapping of hashable to tuple, default: None</span>
<span class="sd">            Used in &#39;maximum&#39;, &#39;mean&#39;, &#39;median&#39;, and &#39;minimum&#39;.  Number of</span>
<span class="sd">            values at edge of each axis used to calculate the statistic value.</span>
<span class="sd">            {dim_1: (before_1, after_1), ... dim_N: (before_N, after_N)} unique</span>
<span class="sd">            statistic lengths along each dimension.</span>
<span class="sd">            ((before, after),) yields same before and after statistic lengths</span>
<span class="sd">            for each dimension.</span>
<span class="sd">            (stat_length,) or int is a shortcut for before = after = statistic</span>
<span class="sd">            length for all axes.</span>
<span class="sd">            Default is ``None``, to use the entire axis.</span>
<span class="sd">        constant_values : scalar, tuple, mapping of dim name to scalar or tuple, or \</span>
<span class="sd">            mapping of var name to scalar, tuple or to mapping of dim name to scalar or tuple, default: None</span>
<span class="sd">            Used in &#39;constant&#39;. The values to set the padded values for each data variable / axis.</span>
<span class="sd">            ``{var_1: {dim_1: (before_1, after_1), ... dim_N: (before_N, after_N)}, ...</span>
<span class="sd">            var_M: (before, after)}`` unique pad constants per data variable.</span>
<span class="sd">            ``{dim_1: (before_1, after_1), ... dim_N: (before_N, after_N)}`` unique</span>
<span class="sd">            pad constants along each dimension.</span>
<span class="sd">            ``((before, after),)`` yields same before and after constants for each</span>
<span class="sd">            dimension.</span>
<span class="sd">            ``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for</span>
<span class="sd">            all dimensions.</span>
<span class="sd">            Default is ``None``, pads with ``np.nan``.</span>
<span class="sd">        end_values : scalar, tuple or mapping of hashable to tuple, default: None</span>
<span class="sd">            Used in &#39;linear_ramp&#39;.  The values used for the ending value of the</span>
<span class="sd">            linear_ramp and that will form the edge of the padded array.</span>
<span class="sd">            ``{dim_1: (before_1, after_1), ... dim_N: (before_N, after_N)}`` unique</span>
<span class="sd">            end values along each dimension.</span>
<span class="sd">            ``((before, after),)`` yields same before and after end values for each</span>
<span class="sd">            axis.</span>
<span class="sd">            ``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for</span>
<span class="sd">            all axes.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        reflect_type : {&quot;even&quot;, &quot;odd&quot;, None}, optional</span>
<span class="sd">            Used in &quot;reflect&quot;, and &quot;symmetric&quot;.  The &quot;even&quot; style is the</span>
<span class="sd">            default with an unaltered reflection around the edge value.  For</span>
<span class="sd">            the &quot;odd&quot; style, the extended part of the array is created by</span>
<span class="sd">            subtracting the reflected values from two times the edge value.</span>
<span class="sd">        keep_attrs : bool or None, optional</span>
<span class="sd">            If True, the attributes (``attrs``) will be copied from the</span>
<span class="sd">            original object to the new one. If False, the new object</span>
<span class="sd">            will be returned without attributes.</span>
<span class="sd">        **pad_width_kwargs</span>
<span class="sd">            The keyword arguments form of ``pad_width``.</span>
<span class="sd">            One of ``pad_width`` or ``pad_width_kwargs`` must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        padded : Dataset</span>
<span class="sd">            Dataset with the padded coordinates and data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.shift, Dataset.roll, Dataset.bfill, Dataset.ffill, numpy.pad, dask.array.pad</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        By default when ``mode=&quot;constant&quot;`` and ``constant_values=None``, integer types will be</span>
<span class="sd">        promoted to ``float`` and padded with ``np.nan``. To avoid type promotion</span>
<span class="sd">        specify ``constant_values=np.nan``</span>

<span class="sd">        Padding coordinates will drop their corresponding index (if any) and will reset default</span>
<span class="sd">        indexes for dimension coordinates.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;foo&quot;: (&quot;x&quot;, range(5))})</span>
<span class="sd">        &gt;&gt;&gt; ds.pad(x=(1, 2))</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 64B</span>
<span class="sd">        Dimensions:  (x: 8)</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (x) float64 64B nan 0.0 1.0 2.0 3.0 4.0 nan nan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pad_width</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">pad_width_kwargs</span><span class="p">,</span> <span class="s2">&quot;pad&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="s2">&quot;wrap&quot;</span><span class="p">):</span>
            <span class="n">coord_pad_mode</span> <span class="o">=</span> <span class="n">mode</span>
            <span class="n">coord_pad_options</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;stat_length&quot;</span><span class="p">:</span> <span class="n">stat_length</span><span class="p">,</span>
                <span class="s2">&quot;constant_values&quot;</span><span class="p">:</span> <span class="n">constant_values</span><span class="p">,</span>
                <span class="s2">&quot;end_values&quot;</span><span class="p">:</span> <span class="n">end_values</span><span class="p">,</span>
                <span class="s2">&quot;reflect_type&quot;</span><span class="p">:</span> <span class="n">reflect_type</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coord_pad_mode</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span>
            <span class="n">coord_pad_options</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">keep_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep_attrs</span> <span class="o">=</span> <span class="n">_get_keep_attrs</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># keep indexes that won&#39;t be affected by pad and drop all other indexes</span>
        <span class="n">xindexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span>
        <span class="n">pad_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">pad_width</span><span class="p">)</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">xindexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pad_dims</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">xindexes</span><span class="o">.</span><span class="n">get_all_dims</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                <span class="n">indexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">var_pad_width</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pad_width</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">}</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">var_pad_width</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">constant_values</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">constant_values</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">filtered_constant_values</span> <span class="o">=</span> <span class="n">constant_values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">constant_values</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                        <span class="n">filtered_constant_values</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">constant_values</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span>
                        <span class="p">}</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">filtered_constant_values</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># TODO: https://github.com/pydata/xarray/pull/9353#discussion_r1724018352</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">filtered_constant_values</span> <span class="o">=</span> <span class="n">constant_values</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                    <span class="n">pad_width</span><span class="o">=</span><span class="n">var_pad_width</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                    <span class="n">stat_length</span><span class="o">=</span><span class="n">stat_length</span><span class="p">,</span>
                    <span class="n">constant_values</span><span class="o">=</span><span class="n">filtered_constant_values</span><span class="p">,</span>
                    <span class="n">end_values</span><span class="o">=</span><span class="n">end_values</span><span class="p">,</span>
                    <span class="n">reflect_type</span><span class="o">=</span><span class="n">reflect_type</span><span class="p">,</span>
                    <span class="n">keep_attrs</span><span class="o">=</span><span class="n">keep_attrs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                    <span class="n">pad_width</span><span class="o">=</span><span class="n">var_pad_width</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">coord_pad_mode</span><span class="p">,</span>
                    <span class="n">keep_attrs</span><span class="o">=</span><span class="n">keep_attrs</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">coord_pad_options</span><span class="p">,</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="p">)</span>
                <span class="c1"># reset default index of dimension coordinates</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span> <span class="o">==</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">dim_var</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]}</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">PandasIndex</span><span class="o">.</span><span class="n">from_variables</span><span class="p">(</span><span class="n">dim_var</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
                    <span class="n">index_vars</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">create_variables</span><span class="p">(</span><span class="n">dim_var</span><span class="p">)</span>
                    <span class="n">indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="k">if</span> <span class="n">keep_attrs</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_with_new_dims</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">)</span>

    <span class="nd">@_deprecate_positional_args</span><span class="p">(</span><span class="s2">&quot;v2023.10.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">idxmin</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">xrdtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the coordinate label of the minimum value along a dimension.</span>

<span class="sd">        Returns a new `Dataset` named after the dimension with the values of</span>
<span class="sd">        the coordinate labels along that dimension corresponding to minimum</span>
<span class="sd">        values along that dimension.</span>

<span class="sd">        In comparison to :py:meth:`~Dataset.argmin`, this returns the</span>
<span class="sd">        coordinate label while :py:meth:`~Dataset.argmin` returns the index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : Hashable, optional</span>
<span class="sd">            Dimension over which to apply `idxmin`.  This is optional for 1D</span>
<span class="sd">            variables, but required for variables with 2 or more dimensions.</span>
<span class="sd">        skipna : bool or None, optional</span>
<span class="sd">            If True, skip missing values (as marked by NaN). By default, only</span>
<span class="sd">            skips missing values for ``float``, ``complex``, and ``object``</span>
<span class="sd">            dtypes; other dtypes either do not have a sentinel missing value</span>
<span class="sd">            (``int``) or ``skipna=True`` has not been implemented</span>
<span class="sd">            (``datetime64`` or ``timedelta64``).</span>
<span class="sd">        fill_value : Any, default: NaN</span>
<span class="sd">            Value to be filled in case all of the values along a dimension are</span>
<span class="sd">            null.  By default this is NaN.  The fill value and result are</span>
<span class="sd">            automatically converted to a compatible dtype if possible.</span>
<span class="sd">            Ignored if ``skipna`` is False.</span>
<span class="sd">        keep_attrs : bool or None, optional</span>
<span class="sd">            If True, the attributes (``attrs``) will be copied from the</span>
<span class="sd">            original object to the new one. If False, the new object</span>
<span class="sd">            will be returned without attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reduced : Dataset</span>
<span class="sd">            New `Dataset` object with `idxmin` applied to its data and the</span>
<span class="sd">            indicated dimension removed.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.idxmin, Dataset.idxmax, Dataset.min, Dataset.argmin</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; array1 = xr.DataArray(</span>
<span class="sd">        ...     [0, 2, 1, 0, -2], dims=&quot;x&quot;, coords={&quot;x&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]}</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; array2 = xr.DataArray(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         [2.0, 1.0, 2.0, 0.0, -2.0],</span>
<span class="sd">        ...         [-4.0, np.nan, 2.0, np.nan, -2.0],</span>
<span class="sd">        ...         [np.nan, np.nan, 1.0, np.nan, np.nan],</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     dims=[&quot;y&quot;, &quot;x&quot;],</span>
<span class="sd">        ...     coords={&quot;y&quot;: [-1, 0, 1], &quot;x&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;int&quot;: array1, &quot;float&quot;: array2})</span>
<span class="sd">        &gt;&gt;&gt; ds.min(dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 56B</span>
<span class="sd">        Dimensions:  (y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 24B -1 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            int      int64 8B -2</span>
<span class="sd">            float    (y) float64 24B -2.0 -4.0 1.0</span>
<span class="sd">        &gt;&gt;&gt; ds.argmin(dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 56B</span>
<span class="sd">        Dimensions:  (y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 24B -1 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            int      int64 8B 4</span>
<span class="sd">            float    (y) int64 24B 4 0 2</span>
<span class="sd">        &gt;&gt;&gt; ds.idxmin(dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 52B</span>
<span class="sd">        Dimensions:  (y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 24B -1 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            int      &lt;U1 4B &#39;e&#39;</span>
<span class="sd">            float    (y) object 24B &#39;e&#39; &#39;a&#39; &#39;c&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="n">methodcaller</span><span class="p">(</span>
                <span class="s2">&quot;idxmin&quot;</span><span class="p">,</span>
                <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
                <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">keep_attrs</span><span class="o">=</span><span class="n">keep_attrs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@_deprecate_positional_args</span><span class="p">(</span><span class="s2">&quot;v2023.10.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">idxmax</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">xrdtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the coordinate label of the maximum value along a dimension.</span>

<span class="sd">        Returns a new `Dataset` named after the dimension with the values of</span>
<span class="sd">        the coordinate labels along that dimension corresponding to maximum</span>
<span class="sd">        values along that dimension.</span>

<span class="sd">        In comparison to :py:meth:`~Dataset.argmax`, this returns the</span>
<span class="sd">        coordinate label while :py:meth:`~Dataset.argmax` returns the index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : str, optional</span>
<span class="sd">            Dimension over which to apply `idxmax`.  This is optional for 1D</span>
<span class="sd">            variables, but required for variables with 2 or more dimensions.</span>
<span class="sd">        skipna : bool or None, optional</span>
<span class="sd">            If True, skip missing values (as marked by NaN). By default, only</span>
<span class="sd">            skips missing values for ``float``, ``complex``, and ``object``</span>
<span class="sd">            dtypes; other dtypes either do not have a sentinel missing value</span>
<span class="sd">            (``int``) or ``skipna=True`` has not been implemented</span>
<span class="sd">            (``datetime64`` or ``timedelta64``).</span>
<span class="sd">        fill_value : Any, default: NaN</span>
<span class="sd">            Value to be filled in case all of the values along a dimension are</span>
<span class="sd">            null.  By default this is NaN.  The fill value and result are</span>
<span class="sd">            automatically converted to a compatible dtype if possible.</span>
<span class="sd">            Ignored if ``skipna`` is False.</span>
<span class="sd">        keep_attrs : bool or None, optional</span>
<span class="sd">            If True, the attributes (``attrs``) will be copied from the</span>
<span class="sd">            original object to the new one. If False, the new object</span>
<span class="sd">            will be returned without attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reduced : Dataset</span>
<span class="sd">            New `Dataset` object with `idxmax` applied to its data and the</span>
<span class="sd">            indicated dimension removed.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.idxmax, Dataset.idxmin, Dataset.max, Dataset.argmax</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; array1 = xr.DataArray(</span>
<span class="sd">        ...     [0, 2, 1, 0, -2], dims=&quot;x&quot;, coords={&quot;x&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]}</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; array2 = xr.DataArray(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         [2.0, 1.0, 2.0, 0.0, -2.0],</span>
<span class="sd">        ...         [-4.0, np.nan, 2.0, np.nan, -2.0],</span>
<span class="sd">        ...         [np.nan, np.nan, 1.0, np.nan, np.nan],</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     dims=[&quot;y&quot;, &quot;x&quot;],</span>
<span class="sd">        ...     coords={&quot;y&quot;: [-1, 0, 1], &quot;x&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]},</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;int&quot;: array1, &quot;float&quot;: array2})</span>
<span class="sd">        &gt;&gt;&gt; ds.max(dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 56B</span>
<span class="sd">        Dimensions:  (y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 24B -1 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            int      int64 8B 2</span>
<span class="sd">            float    (y) float64 24B 2.0 2.0 1.0</span>
<span class="sd">        &gt;&gt;&gt; ds.argmax(dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 56B</span>
<span class="sd">        Dimensions:  (y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 24B -1 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            int      int64 8B 1</span>
<span class="sd">            float    (y) int64 24B 0 2 2</span>
<span class="sd">        &gt;&gt;&gt; ds.idxmax(dim=&quot;x&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 52B</span>
<span class="sd">        Dimensions:  (y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * y        (y) int64 24B -1 0 1</span>
<span class="sd">        Data variables:</span>
<span class="sd">            int      &lt;U1 4B &#39;b&#39;</span>
<span class="sd">            float    (y) object 24B &#39;a&#39; &#39;c&#39; &#39;c&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="n">methodcaller</span><span class="p">(</span>
                <span class="s2">&quot;idxmax&quot;</span><span class="p">,</span>
                <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
                <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">keep_attrs</span><span class="o">=</span><span class="n">keep_attrs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Indices of the minima of the member variables.</span>

<span class="sd">        If there are multiple minima, the indices of the first one found will be</span>
<span class="sd">        returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : Hashable, optional</span>
<span class="sd">            The dimension over which to find the minimum. By default, finds minimum over</span>
<span class="sd">            all dimensions - for now returning an int for backward compatibility, but</span>
<span class="sd">            this is deprecated, in future will be an error, since DataArray.argmin will</span>
<span class="sd">            return a dict with indices for all dimensions, which does not make sense for</span>
<span class="sd">            a Dataset.</span>
<span class="sd">        keep_attrs : bool, optional</span>
<span class="sd">            If True, the attributes (`attrs`) will be copied from the original</span>
<span class="sd">            object to the new one.  If False (default), the new object will be</span>
<span class="sd">            returned without attributes.</span>
<span class="sd">        skipna : bool, optional</span>
<span class="sd">            If True, skip missing values (as marked by NaN). By default, only</span>
<span class="sd">            skips missing values for float dtypes; other dtypes either do not</span>
<span class="sd">            have a sentinel missing value (int) or skipna=True has not been</span>
<span class="sd">            implemented (object, datetime64 or timedelta64).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : Dataset</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; dataset = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;math_scores&quot;: (</span>
<span class="sd">        ...             [&quot;student&quot;, &quot;test&quot;],</span>
<span class="sd">        ...             [[90, 85, 79], [78, 80, 85], [95, 92, 98]],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...         &quot;english_scores&quot;: (</span>
<span class="sd">        ...             [&quot;student&quot;, &quot;test&quot;],</span>
<span class="sd">        ...             [[88, 90, 92], [75, 82, 79], [39, 96, 78]],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={</span>
<span class="sd">        ...         &quot;student&quot;: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;],</span>
<span class="sd">        ...         &quot;test&quot;: [&quot;Test 1&quot;, &quot;Test 2&quot;, &quot;Test 3&quot;],</span>
<span class="sd">        ...     },</span>
<span class="sd">        ... )</span>

<span class="sd">        # Indices of the minimum values along the &#39;student&#39; dimension are calculated</span>

<span class="sd">        &gt;&gt;&gt; argmin_indices = dataset.argmin(dim=&quot;student&quot;)</span>

<span class="sd">        &gt;&gt;&gt; min_score_in_math = dataset[&quot;student&quot;].isel(</span>
<span class="sd">        ...     student=argmin_indices[&quot;math_scores&quot;]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; min_score_in_math</span>
<span class="sd">        &lt;xarray.DataArray &#39;student&#39; (test: 3)&gt; Size: 84B</span>
<span class="sd">        array([&#39;Bob&#39;, &#39;Bob&#39;, &#39;Alice&#39;], dtype=&#39;&lt;U7&#39;)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            student  (test) &lt;U7 84B &#39;Bob&#39; &#39;Bob&#39; &#39;Alice&#39;</span>
<span class="sd">          * test     (test) &lt;U6 72B &#39;Test 1&#39; &#39;Test 2&#39; &#39;Test 3&#39;</span>

<span class="sd">        &gt;&gt;&gt; min_score_in_english = dataset[&quot;student&quot;].isel(</span>
<span class="sd">        ...     student=argmin_indices[&quot;english_scores&quot;]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; min_score_in_english</span>
<span class="sd">        &lt;xarray.DataArray &#39;student&#39; (test: 3)&gt; Size: 84B</span>
<span class="sd">        array([&#39;Charlie&#39;, &#39;Bob&#39;, &#39;Charlie&#39;], dtype=&#39;&lt;U7&#39;)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            student  (test) &lt;U7 84B &#39;Charlie&#39; &#39;Bob&#39; &#39;Charlie&#39;</span>
<span class="sd">          * test     (test) &lt;U6 72B &#39;Test 1&#39; &#39;Test 2&#39; &#39;Test 3&#39;</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.idxmin</span>
<span class="sd">        DataArray.argmin</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Once the behaviour of DataArray.argmin() and Variable.argmin() without &quot;</span>
                <span class="s2">&quot;dim changes to return a dict of indices of each dimension, for &quot;</span>
                <span class="s2">&quot;consistency it will be an error to call Dataset.argmin() with no argument,&quot;</span>
                <span class="s2">&quot;since we don&#39;t return a dict of Datasets.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="o">...</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># Return int index if single dimension is passed, and is not part of a</span>
            <span class="c1"># sequence</span>
            <span class="n">argmin_func</span> <span class="o">=</span> <span class="n">duck_array_ops</span><span class="o">.</span><span class="n">argmin</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
                <span class="n">argmin_func</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="n">dim</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;When dim is a sequence or ..., DataArray.argmin() returns a dict. &quot;</span>
                <span class="s2">&quot;dicts cannot be contained in a Dataset, so cannot call &quot;</span>
                <span class="s2">&quot;Dataset.argmin() with a sequence or ... for dim&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Indices of the maxima of the member variables.</span>

<span class="sd">        If there are multiple maxima, the indices of the first one found will be</span>
<span class="sd">        returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : str, optional</span>
<span class="sd">            The dimension over which to find the maximum. By default, finds maximum over</span>
<span class="sd">            all dimensions - for now returning an int for backward compatibility, but</span>
<span class="sd">            this is deprecated, in future will be an error, since DataArray.argmax will</span>
<span class="sd">            return a dict with indices for all dimensions, which does not make sense for</span>
<span class="sd">            a Dataset.</span>
<span class="sd">        keep_attrs : bool, optional</span>
<span class="sd">            If True, the attributes (`attrs`) will be copied from the original</span>
<span class="sd">            object to the new one.  If False (default), the new object will be</span>
<span class="sd">            returned without attributes.</span>
<span class="sd">        skipna : bool, optional</span>
<span class="sd">            If True, skip missing values (as marked by NaN). By default, only</span>
<span class="sd">            skips missing values for float dtypes; other dtypes either do not</span>
<span class="sd">            have a sentinel missing value (int) or skipna=True has not been</span>
<span class="sd">            implemented (object, datetime64 or timedelta64).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : Dataset</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; dataset = xr.Dataset(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;math_scores&quot;: (</span>
<span class="sd">        ...             [&quot;student&quot;, &quot;test&quot;],</span>
<span class="sd">        ...             [[90, 85, 92], [78, 80, 85], [95, 92, 98]],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...         &quot;english_scores&quot;: (</span>
<span class="sd">        ...             [&quot;student&quot;, &quot;test&quot;],</span>
<span class="sd">        ...             [[88, 90, 92], [75, 82, 79], [93, 96, 91]],</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     },</span>
<span class="sd">        ...     coords={</span>
<span class="sd">        ...         &quot;student&quot;: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;],</span>
<span class="sd">        ...         &quot;test&quot;: [&quot;Test 1&quot;, &quot;Test 2&quot;, &quot;Test 3&quot;],</span>
<span class="sd">        ...     },</span>
<span class="sd">        ... )</span>

<span class="sd">        # Indices of the maximum values along the &#39;student&#39; dimension are calculated</span>

<span class="sd">        &gt;&gt;&gt; argmax_indices = dataset.argmax(dim=&quot;test&quot;)</span>

<span class="sd">        &gt;&gt;&gt; argmax_indices</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 132B</span>
<span class="sd">        Dimensions:         (student: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * student         (student) &lt;U7 84B &#39;Alice&#39; &#39;Bob&#39; &#39;Charlie&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            math_scores     (student) int64 24B 2 2 2</span>
<span class="sd">            english_scores  (student) int64 24B 2 1 1</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.argmax</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Once the behaviour of DataArray.argmin() and Variable.argmin() without &quot;</span>
                <span class="s2">&quot;dim changes to return a dict of indices of each dimension, for &quot;</span>
                <span class="s2">&quot;consistency it will be an error to call Dataset.argmin() with no argument,&quot;</span>
                <span class="s2">&quot;since we don&#39;t return a dict of Datasets.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="o">...</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># Return int index if single dimension is passed, and is not part of a</span>
            <span class="c1"># sequence</span>
            <span class="n">argmax_func</span> <span class="o">=</span> <span class="n">duck_array_ops</span><span class="o">.</span><span class="n">argmax</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
                <span class="n">argmax_func</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="n">dim</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;When dim is a sequence or ..., DataArray.argmin() returns a dict. &quot;</span>
                <span class="s2">&quot;dicts cannot be contained in a Dataset, so cannot call &quot;</span>
                <span class="s2">&quot;Dataset.argmin() with a sequence or ... for dim&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">parser</span><span class="p">:</span> <span class="n">QueryParserOptions</span> <span class="o">=</span> <span class="s2">&quot;pandas&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span> <span class="o">|</span> <span class="n">T_DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate an expression supplied as a string in the context of the dataset.</span>

<span class="sd">        This is currently experimental; the API may change particularly around</span>
<span class="sd">        assignments, which currently return a ``Dataset`` with the additional variable.</span>
<span class="sd">        Currently only the ``python`` engine is supported, which has the same</span>
<span class="sd">        performance as executing in python.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        statement : str</span>
<span class="sd">            String containing the Python-like expression to evaluate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : Dataset or DataArray, depending on whether ``statement`` contains an</span>
<span class="sd">        assignment.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     {&quot;a&quot;: (&quot;x&quot;, np.arange(0, 5, 1)), &quot;b&quot;: (&quot;x&quot;, np.linspace(0, 1, 5))}</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 80B</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) int64 40B 0 1 2 3 4</span>
<span class="sd">            b        (x) float64 40B 0.0 0.25 0.5 0.75 1.0</span>

<span class="sd">        &gt;&gt;&gt; ds.eval(&quot;a + b&quot;)</span>
<span class="sd">        &lt;xarray.DataArray (x: 5)&gt; Size: 40B</span>
<span class="sd">        array([0.  , 1.25, 2.5 , 3.75, 5.  ])</span>
<span class="sd">        Dimensions without coordinates: x</span>

<span class="sd">        &gt;&gt;&gt; ds.eval(&quot;c = a + b&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 120B</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) int64 40B 0 1 2 3 4</span>
<span class="sd">            b        (x) float64 40B 0.0 0.25 0.5 0.75 1.0</span>
<span class="sd">            c        (x) float64 40B 0.0 1.25 2.5 3.75 5.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span>  <span class="c1"># type: ignore[return-value]</span>
            <span class="n">statement</span><span class="p">,</span>
            <span class="n">resolvers</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">],</span>
            <span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">,</span>
            <span class="c1"># Because numexpr returns a numpy array, using that engine results in</span>
            <span class="c1"># different behavior. We&#39;d be very open to a contribution handling this.</span>
            <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;python&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">queries</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parser</span><span class="p">:</span> <span class="n">QueryParserOptions</span> <span class="o">=</span> <span class="s2">&quot;pandas&quot;</span><span class="p">,</span>
        <span class="n">engine</span><span class="p">:</span> <span class="n">QueryEngineOptions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">missing_dims</span><span class="p">:</span> <span class="n">ErrorOptionsWithWarn</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">queries_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new dataset with each array indexed along the specified</span>
<span class="sd">        dimension(s), where the indexers are given as strings containing</span>
<span class="sd">        Python expressions to be evaluated against the data variables in the</span>
<span class="sd">        dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        queries : dict-like, optional</span>
<span class="sd">            A dict-like with keys matching dimensions and values given by strings</span>
<span class="sd">            containing Python expressions to be evaluated against the data variables</span>
<span class="sd">            in the dataset. The expressions will be evaluated using the pandas</span>
<span class="sd">            eval() function, and can contain any valid Python expressions but cannot</span>
<span class="sd">            contain any Python statements.</span>
<span class="sd">        parser : {&quot;pandas&quot;, &quot;python&quot;}, default: &quot;pandas&quot;</span>
<span class="sd">            The parser to use to construct the syntax tree from the expression.</span>
<span class="sd">            The default of &#39;pandas&#39; parses code slightly different than standard</span>
<span class="sd">            Python. Alternatively, you can parse an expression using the &#39;python&#39;</span>
<span class="sd">            parser to retain strict Python semantics.</span>
<span class="sd">        engine : {&quot;python&quot;, &quot;numexpr&quot;, None}, default: None</span>
<span class="sd">            The engine used to evaluate the expression. Supported engines are:</span>

<span class="sd">            - None: tries to use numexpr, falls back to python</span>
<span class="sd">            - &quot;numexpr&quot;: evaluates expressions using numexpr</span>
<span class="sd">            - &quot;python&quot;: performs operations as if you had eval’d in top level python</span>

<span class="sd">        missing_dims : {&quot;raise&quot;, &quot;warn&quot;, &quot;ignore&quot;}, default: &quot;raise&quot;</span>
<span class="sd">            What to do if dimensions that should be selected from are not present in the</span>
<span class="sd">            Dataset:</span>

<span class="sd">            - &quot;raise&quot;: raise an exception</span>
<span class="sd">            - &quot;warn&quot;: raise a warning, and ignore the missing dimensions</span>
<span class="sd">            - &quot;ignore&quot;: ignore the missing dimensions</span>

<span class="sd">        **queries_kwargs : {dim: query, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``queries``.</span>
<span class="sd">            One of queries or queries_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : Dataset</span>
<span class="sd">            A new Dataset with the same contents as this dataset, except each</span>
<span class="sd">            array and dimension is indexed by the results of the appropriate</span>
<span class="sd">            queries.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.isel</span>
<span class="sd">        pandas.eval</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a = np.arange(0, 5, 1)</span>
<span class="sd">        &gt;&gt;&gt; b = np.linspace(0, 1, 5)</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset({&quot;a&quot;: (&quot;x&quot;, a), &quot;b&quot;: (&quot;x&quot;, b)})</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 80B</span>
<span class="sd">        Dimensions:  (x: 5)</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) int64 40B 0 1 2 3 4</span>
<span class="sd">            b        (x) float64 40B 0.0 0.25 0.5 0.75 1.0</span>
<span class="sd">        &gt;&gt;&gt; ds.query(x=&quot;a &gt; 2&quot;)</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 32B</span>
<span class="sd">        Dimensions:  (x: 2)</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x) int64 16B 3 4</span>
<span class="sd">            b        (x) float64 16B 0.75 1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># allow queries to be given either as a dict or as kwargs</span>
        <span class="n">queries</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">queries_kwargs</span><span class="p">,</span> <span class="s2">&quot;query&quot;</span><span class="p">)</span>

        <span class="c1"># check queries</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">queries</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;expr for dim </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> must be a string to be evaluated, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="si">}</span><span class="s2"> given&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># evaluate the queries to create the indexers</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">dim</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">resolvers</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">],</span> <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">queries</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># apply the selection</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">missing_dims</span><span class="o">=</span><span class="n">missing_dims</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">curvefit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coords</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">DataArray</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="n">DataArray</span><span class="p">],</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">reduce_dims</span><span class="p">:</span> <span class="n">Dims</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">p0</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">DataArray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bounds</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span> <span class="o">|</span> <span class="n">DataArray</span><span class="p">,</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">DataArray</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">param_names</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">ErrorOptions</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Curve fitting optimization for arbitrary functions.</span>

<span class="sd">        Wraps `scipy.optimize.curve_fit` with `apply_ufunc`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : hashable, DataArray, or sequence of hashable or DataArray</span>
<span class="sd">            Independent coordinate(s) over which to perform the curve fitting. Must share</span>
<span class="sd">            at least one dimension with the calling object. When fitting multi-dimensional</span>
<span class="sd">            functions, supply `coords` as a sequence in the same order as arguments in</span>
<span class="sd">            `func`. To fit along existing dimensions of the calling object, `coords` can</span>
<span class="sd">            also be specified as a str or sequence of strs.</span>
<span class="sd">        func : callable</span>
<span class="sd">            User specified function in the form `f(x, *params)` which returns a numpy</span>
<span class="sd">            array of length `len(x)`. `params` are the fittable parameters which are optimized</span>
<span class="sd">            by scipy curve_fit. `x` can also be specified as a sequence containing multiple</span>
<span class="sd">            coordinates, e.g. `f((x0, x1), *params)`.</span>
<span class="sd">        reduce_dims : str, Iterable of Hashable or None, optional</span>
<span class="sd">            Additional dimension(s) over which to aggregate while fitting. For example,</span>
<span class="sd">            calling `ds.curvefit(coords=&#39;time&#39;, reduce_dims=[&#39;lat&#39;, &#39;lon&#39;], ...)` will</span>
<span class="sd">            aggregate all lat and lon points and fit the specified function along the</span>
<span class="sd">            time dimension.</span>
<span class="sd">        skipna : bool, default: True</span>
<span class="sd">            Whether to skip missing values when fitting. Default is True.</span>
<span class="sd">        p0 : dict-like, optional</span>
<span class="sd">            Optional dictionary of parameter names to initial guesses passed to the</span>
<span class="sd">            `curve_fit` `p0` arg. If the values are DataArrays, they will be appropriately</span>
<span class="sd">            broadcast to the coordinates of the array. If none or only some parameters are</span>
<span class="sd">            passed, the rest will be assigned initial values following the default scipy</span>
<span class="sd">            behavior.</span>
<span class="sd">        bounds : dict-like, optional</span>
<span class="sd">            Optional dictionary of parameter names to tuples of bounding values passed to the</span>
<span class="sd">            `curve_fit` `bounds` arg. If any of the bounds are DataArrays, they will be</span>
<span class="sd">            appropriately broadcast to the coordinates of the array. If none or only some</span>
<span class="sd">            parameters are passed, the rest will be unbounded following the default scipy</span>
<span class="sd">            behavior.</span>
<span class="sd">        param_names : sequence of hashable, optional</span>
<span class="sd">            Sequence of names for the fittable parameters of `func`. If not supplied,</span>
<span class="sd">            this will be automatically determined by arguments of `func`. `param_names`</span>
<span class="sd">            should be manually supplied when fitting a function that takes a variable</span>
<span class="sd">            number of parameters.</span>
<span class="sd">        errors : {&quot;raise&quot;, &quot;ignore&quot;}, default: &quot;raise&quot;</span>
<span class="sd">            If &#39;raise&#39;, any errors from the `scipy.optimize_curve_fit` optimization will</span>
<span class="sd">            raise an exception. If &#39;ignore&#39;, the coefficients and covariances for the</span>
<span class="sd">            coordinates where the fitting failed will be NaN.</span>
<span class="sd">        **kwargs : optional</span>
<span class="sd">            Additional keyword arguments to passed to scipy curve_fit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        curvefit_results : Dataset</span>
<span class="sd">            A single dataset which contains:</span>

<span class="sd">            [var]_curvefit_coefficients</span>
<span class="sd">                The coefficients of the best fit.</span>
<span class="sd">            [var]_curvefit_covariance</span>
<span class="sd">                The covariance matrix of the coefficient estimates.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.polyfit</span>
<span class="sd">        scipy.optimize.curve_fit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>

        <span class="kn">from</span> <span class="nn">xarray.core.alignment</span> <span class="kn">import</span> <span class="n">broadcast</span>
        <span class="kn">from</span> <span class="nn">xarray.core.computation</span> <span class="kn">import</span> <span class="n">apply_ufunc</span>
        <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">_THIS_ARRAY</span><span class="p">,</span> <span class="n">DataArray</span>

        <span class="k">if</span> <span class="n">p0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">reduce_dims_</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reduce_dims</span><span class="p">:</span>
            <span class="n">reduce_dims_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reduce_dims</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reduce_dims</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">reduce_dims_</span> <span class="o">=</span> <span class="p">[</span><span class="n">reduce_dims</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reduce_dims_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">reduce_dims</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">)</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">]</span>
        <span class="n">coords_</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">coord</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span>
        <span class="p">]</span>

        <span class="c1"># Determine whether any coords are dims on self</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords_</span><span class="p">:</span>
            <span class="n">reduce_dims_</span> <span class="o">+=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">c</span><span class="p">])]</span>
        <span class="n">reduce_dims_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">reduce_dims_</span><span class="p">))</span>
        <span class="n">preserved_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">reduce_dims_</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reduce_dims_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No arguments to `coords` were identified as a dimension on the calling &quot;</span>
                <span class="s2">&quot;object, and no dims were supplied to `reduce_dims`. This would result &quot;</span>
                <span class="s2">&quot;in fitting on scalar data.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Check that initial guess and bounds only contain coordinates that are in preserved_dims</span>
        <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">guess</span> <span class="ow">in</span> <span class="n">p0</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                <span class="n">unexpected</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">guess</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">preserved_dims</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">unexpected</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Initial guess for &#39;</span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s2">&#39; has unexpected dimensions &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">unexpected</span><span class="p">)</span><span class="si">}</span><span class="s2">. It should only have dimensions that are in data &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;dimensions </span><span class="si">{</span><span class="n">preserved_dims</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
        <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bounds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">bound</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">((</span><span class="s2">&quot;Lower&quot;</span><span class="p">,</span> <span class="s2">&quot;Upper&quot;</span><span class="p">),</span> <span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">),</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                    <span class="n">unexpected</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bound</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">preserved_dims</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">unexpected</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> bound for &#39;</span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s2">&#39; has unexpected dimensions &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">unexpected</span><span class="p">)</span><span class="si">}</span><span class="s2">. It should only have dimensions that are in data &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;dimensions </span><span class="si">{</span><span class="n">preserved_dims</span><span class="si">}</span><span class="s2">.&quot;</span>
                        <span class="p">)</span>

        <span class="k">if</span> <span class="n">errors</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="s2">&quot;ignore&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;errors must be either &quot;raise&quot; or &quot;ignore&quot;&#39;</span><span class="p">)</span>

        <span class="c1"># Broadcast all coords with each other</span>
        <span class="n">coords_</span> <span class="o">=</span> <span class="n">broadcast</span><span class="p">(</span><span class="o">*</span><span class="n">coords_</span><span class="p">)</span>
        <span class="n">coords_</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">coord</span><span class="o">.</span><span class="n">broadcast_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">preserved_dims</span><span class="p">)</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords_</span>
        <span class="p">]</span>
        <span class="n">n_coords</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_</span><span class="p">)</span>

        <span class="n">params</span><span class="p">,</span> <span class="n">func_args</span> <span class="o">=</span> <span class="n">_get_func_args</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">param_names</span><span class="p">)</span>
        <span class="n">param_defaults</span><span class="p">,</span> <span class="n">bounds_defaults</span> <span class="o">=</span> <span class="n">_initialize_curvefit_params</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">func_args</span>
        <span class="p">)</span>
        <span class="n">n_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_wrapper</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># Wrap curve_fit with raveled coordinates and pointwise NaN handling</span>
            <span class="c1"># *args contains:</span>
            <span class="c1">#   - the coordinates</span>
            <span class="c1">#   - initial guess</span>
            <span class="c1">#   - lower bounds</span>
            <span class="c1">#   - upper bounds</span>
            <span class="n">coords__</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="n">n_coords</span><span class="p">]</span>
            <span class="n">p0_</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">n_coords</span> <span class="o">+</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">n_params</span> <span class="p">:</span> <span class="n">n_coords</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">n_params</span><span class="p">]</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">n_coords</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">n_params</span> <span class="p">:</span> <span class="n">n_coords</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_params</span><span class="p">]</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">n_coords</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_params</span> <span class="p">:]</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords__</span><span class="p">])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">skipna</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                    <span class="n">popt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="n">n_params</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                    <span class="n">pcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="n">n_params</span><span class="p">,</span> <span class="n">n_params</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0_</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
                    <span class="k">raise</span>
                <span class="n">popt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="n">n_params</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">pcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="n">n_params</span><span class="p">,</span> <span class="n">n_params</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span>

        <span class="n">result</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">da</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="n">_THIS_ARRAY</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">_&quot;</span>

            <span class="n">input_core_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">reduce_dims_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_coords</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">input_core_dims</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">n_params</span><span class="p">)]</span>
            <span class="p">)</span>  <span class="c1"># core_dims for p0 and bounds</span>

            <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">apply_ufunc</span><span class="p">(</span>
                <span class="n">_wrapper</span><span class="p">,</span>
                <span class="n">da</span><span class="p">,</span>
                <span class="o">*</span><span class="n">coords_</span><span class="p">,</span>
                <span class="o">*</span><span class="n">param_defaults</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                <span class="o">*</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bounds_defaults</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span>
                <span class="o">*</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bounds_defaults</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span>
                <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="n">input_core_dims</span><span class="o">=</span><span class="n">input_core_dims</span><span class="p">,</span>
                <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;param&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;cov_i&quot;</span><span class="p">,</span> <span class="s2">&quot;cov_j&quot;</span><span class="p">]],</span>
                <span class="n">dask_gufunc_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;output_sizes&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;param&quot;</span><span class="p">:</span> <span class="n">n_params</span><span class="p">,</span>
                        <span class="s2">&quot;cov_i&quot;</span><span class="p">:</span> <span class="n">n_params</span><span class="p">,</span>
                        <span class="s2">&quot;cov_j&quot;</span><span class="p">:</span> <span class="n">n_params</span><span class="p">,</span>
                    <span class="p">},</span>
                <span class="p">},</span>
                <span class="n">output_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                <span class="n">exclude_dims</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">reduce_dims_</span><span class="p">),</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;curvefit_coefficients&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">popt</span>
            <span class="n">result</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;curvefit_covariance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcov</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;param&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">,</span> <span class="s2">&quot;cov_i&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">,</span> <span class="s2">&quot;cov_j&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@_deprecate_positional_args</span><span class="p">(</span><span class="s2">&quot;v2023.10.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">drop_duplicates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">keep</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new Dataset with duplicate dimension values removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : dimension label or labels</span>
<span class="sd">            Pass `...` to drop duplicates along all dimensions.</span>
<span class="sd">        keep : {&quot;first&quot;, &quot;last&quot;, False}, default: &quot;first&quot;</span>
<span class="sd">            Determines which duplicates (if any) to keep.</span>
<span class="sd">            - ``&quot;first&quot;`` : Drop duplicates except for the first occurrence.</span>
<span class="sd">            - ``&quot;last&quot;`` : Drop duplicates except for the last occurrence.</span>
<span class="sd">            - False : Drop all duplicates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.drop_duplicates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">dims</span><span class="p">:</span> <span class="n">Iterable</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">dim</span>

        <span class="n">missing_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">missing_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Dimensions </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missing_dims</span><span class="p">)</span><span class="si">}</span><span class="s2"> not found in data dimensions </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert_calendar</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">calendar</span><span class="p">:</span> <span class="n">CFCalendar</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span>
        <span class="n">align_on</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">missing</span><span class="p">:</span> <span class="n">Any</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_cftime</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the Dataset to another calendar.</span>

<span class="sd">        Only converts the individual timestamps, does not modify any data except</span>
<span class="sd">        in dropping invalid/surplus dates or inserting missing dates.</span>

<span class="sd">        If the source and target calendars are either no_leap, all_leap or a</span>
<span class="sd">        standard type, only the type of the time array is modified.</span>
<span class="sd">        When converting to a leap year from a non-leap year, the 29th of February</span>
<span class="sd">        is removed from the array. In the other direction the 29th of February</span>
<span class="sd">        will be missing in the output, unless `missing` is specified,</span>
<span class="sd">        in which case that value is inserted.</span>

<span class="sd">        For conversions involving `360_day` calendars, see Notes.</span>

<span class="sd">        This method is safe to use with sub-daily data as it doesn&#39;t touch the</span>
<span class="sd">        time part of the timestamps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        calendar : str</span>
<span class="sd">            The target calendar name.</span>
<span class="sd">        dim : Hashable, default: &quot;time&quot;</span>
<span class="sd">            Name of the time coordinate.</span>
<span class="sd">        align_on : {None, &#39;date&#39;, &#39;year&#39;}, optional</span>
<span class="sd">            Must be specified when either source or target is a `360_day` calendar,</span>
<span class="sd">            ignored otherwise. See Notes.</span>
<span class="sd">        missing : Any or None, optional</span>
<span class="sd">            By default, i.e. if the value is None, this method will simply attempt</span>
<span class="sd">            to convert the dates in the source calendar to the same dates in the</span>
<span class="sd">            target calendar, and drop any of those that are not possible to</span>
<span class="sd">            represent.  If a value is provided, a new time coordinate will be</span>
<span class="sd">            created in the target calendar with the same frequency as the original</span>
<span class="sd">            time coordinate; for any dates that are not present in the source, the</span>
<span class="sd">            data will be filled with this value.  Note that using this mode requires</span>
<span class="sd">            that the source data have an inferable frequency; for more information</span>
<span class="sd">            see :py:func:`xarray.infer_freq`.  For certain frequency, source, and</span>
<span class="sd">            target calendar combinations, this could result in many missing values, see notes.</span>
<span class="sd">        use_cftime : bool or None, optional</span>
<span class="sd">            Whether to use cftime objects in the output, only used if `calendar`</span>
<span class="sd">            is one of {&quot;proleptic_gregorian&quot;, &quot;gregorian&quot; or &quot;standard&quot;}.</span>
<span class="sd">            If True, the new time axis uses cftime objects.</span>
<span class="sd">            If None (default), it uses :py:class:`numpy.datetime64` values if the</span>
<span class="sd">            date range permits it, and :py:class:`cftime.datetime` objects if not.</span>
<span class="sd">            If False, it uses :py:class:`numpy.datetime64`  or fails.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>
<span class="sd">            Copy of the dataarray with the time coordinate converted to the</span>
<span class="sd">            target calendar. If &#39;missing&#39; was None (default), invalid dates in</span>
<span class="sd">            the new calendar are dropped, but missing dates are not inserted.</span>
<span class="sd">            If `missing` was given, the new data is reindexed to have a time axis</span>
<span class="sd">            with the same frequency as the source, but in the new calendar; any</span>
<span class="sd">            missing datapoints are filled with `missing`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Passing a value to `missing` is only usable if the source&#39;s time coordinate as an</span>
<span class="sd">        inferable frequencies (see :py:func:`~xarray.infer_freq`) and is only appropriate</span>
<span class="sd">        if the target coordinate, generated from this frequency, has dates equivalent to the</span>
<span class="sd">        source. It is usually **not** appropriate to use this mode with:</span>

<span class="sd">        - Period-end frequencies : &#39;A&#39;, &#39;Y&#39;, &#39;Q&#39; or &#39;M&#39;, in opposition to &#39;AS&#39; &#39;YS&#39;, &#39;QS&#39; and &#39;MS&#39;</span>
<span class="sd">        - Sub-monthly frequencies that do not divide a day evenly : &#39;W&#39;, &#39;nD&#39; where `N != 1`</span>
<span class="sd">            or &#39;mH&#39; where 24 % m != 0).</span>

<span class="sd">        If one of the source or target calendars is `&quot;360_day&quot;`, `align_on` must</span>
<span class="sd">        be specified and two options are offered.</span>

<span class="sd">        - &quot;year&quot;</span>
<span class="sd">            The dates are translated according to their relative position in the year,</span>
<span class="sd">            ignoring their original month and day information, meaning that the</span>
<span class="sd">            missing/surplus days are added/removed at regular intervals.</span>

<span class="sd">            From a `360_day` to a standard calendar, the output will be missing the</span>
<span class="sd">            following dates (day of year in parentheses):</span>

<span class="sd">            To a leap year:</span>
<span class="sd">                January 31st (31), March 31st (91), June 1st (153), July 31st (213),</span>
<span class="sd">                September 31st (275) and November 30th (335).</span>
<span class="sd">            To a non-leap year:</span>
<span class="sd">                February 6th (36), April 19th (109), July 2nd (183),</span>
<span class="sd">                September 12th (255), November 25th (329).</span>

<span class="sd">            From a standard calendar to a `&quot;360_day&quot;`, the following dates in the</span>
<span class="sd">            source array will be dropped:</span>

<span class="sd">            From a leap year:</span>
<span class="sd">                January 31st (31), April 1st (92), June 1st (153), August 1st (214),</span>
<span class="sd">                September 31st (275), December 1st (336)</span>
<span class="sd">            From a non-leap year:</span>
<span class="sd">                February 6th (37), April 20th (110), July 2nd (183),</span>
<span class="sd">                September 13th (256), November 25th (329)</span>

<span class="sd">            This option is best used on daily and subdaily data.</span>

<span class="sd">        - &quot;date&quot;</span>
<span class="sd">            The month/day information is conserved and invalid dates are dropped</span>
<span class="sd">            from the output. This means that when converting from a `&quot;360_day&quot;` to a</span>
<span class="sd">            standard calendar, all 31st (Jan, March, May, July, August, October and</span>
<span class="sd">            December) will be missing as there is no equivalent dates in the</span>
<span class="sd">            `&quot;360_day&quot;` calendar and the 29th (on non-leap years) and 30th of February</span>
<span class="sd">            will be dropped as there are no equivalent dates in a standard calendar.</span>

<span class="sd">            This option is best used with data on a frequency coarser than daily.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">convert_calendar</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">calendar</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
            <span class="n">align_on</span><span class="o">=</span><span class="n">align_on</span><span class="p">,</span>
            <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span>
            <span class="n">use_cftime</span><span class="o">=</span><span class="n">use_cftime</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">interp_calendar</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span> <span class="o">|</span> <span class="n">CFTimeIndex</span> <span class="o">|</span> <span class="n">DataArray</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolates the Dataset to another calendar based on decimal year measure.</span>

<span class="sd">        Each timestamp in `source` and `target` are first converted to their decimal</span>
<span class="sd">        year equivalent then `source` is interpolated on the target coordinate.</span>
<span class="sd">        The decimal year of a timestamp is its year plus its sub-year component</span>
<span class="sd">        converted to the fraction of its year. For example &quot;2000-03-01 12:00&quot; is</span>
<span class="sd">        2000.1653 in a standard calendar or 2000.16301 in a `&quot;noleap&quot;` calendar.</span>

<span class="sd">        This method should only be used when the time (HH:MM:SS) information of</span>
<span class="sd">        time coordinate is not important.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target: DataArray or DatetimeIndex or CFTimeIndex</span>
<span class="sd">            The target time coordinate of a valid dtype</span>
<span class="sd">            (np.datetime64 or cftime objects)</span>
<span class="sd">        dim : Hashable, default: &quot;time&quot;</span>
<span class="sd">            The time coordinate name.</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        DataArray</span>
<span class="sd">            The source interpolated on the decimal years of target,</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">interp_calendar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>

    <span class="nd">@_deprecate_positional_args</span><span class="p">(</span><span class="s2">&quot;v2024.07.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="n">GroupInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">squeeze</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">restore_coord_dims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">groupers</span><span class="p">:</span> <span class="n">Grouper</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatasetGroupBy</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a DatasetGroupBy object for performing grouped operations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        group : str or DataArray or IndexVariable or sequence of hashable or mapping of hashable to Grouper</span>
<span class="sd">            Array whose unique values should be used to group this array. If a</span>
<span class="sd">            Hashable, must be the name of a coordinate contained in this dataarray. If a dictionary,</span>
<span class="sd">            must map an existing variable name to a :py:class:`Grouper` instance.</span>
<span class="sd">        squeeze : bool, default: True</span>
<span class="sd">            If &quot;group&quot; is a dimension of any arrays in this dataset, `squeeze`</span>
<span class="sd">            controls whether the subarrays have a dimension of length 1 along</span>
<span class="sd">            that dimension or if the dimension is squeezed out.</span>
<span class="sd">        restore_coord_dims : bool, default: False</span>
<span class="sd">            If True, also restore the dimension order of multi-dimensional</span>
<span class="sd">            coordinates.</span>
<span class="sd">        **groupers : Mapping of str to Grouper or Resampler</span>
<span class="sd">            Mapping of variable name to group by to :py:class:`Grouper` or :py:class:`Resampler` object.</span>
<span class="sd">            One of ``group`` or ``groupers`` must be provided.</span>
<span class="sd">            Only a single ``grouper`` is allowed at present.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        grouped : DatasetGroupBy</span>
<span class="sd">            A `DatasetGroupBy` object patterned after `pandas.GroupBy` that can be</span>
<span class="sd">            iterated over in the form of `(unique_value, grouped_array)` pairs.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ds = xr.Dataset(</span>
<span class="sd">        ...     {&quot;foo&quot;: ((&quot;x&quot;, &quot;y&quot;), np.arange(12).reshape((4, 3)))},</span>
<span class="sd">        ...     coords={&quot;x&quot;: [10, 20, 30, 40], &quot;letters&quot;: (&quot;x&quot;, list(&quot;abba&quot;))},</span>
<span class="sd">        ... )</span>

<span class="sd">        Grouping by a single variable is easy</span>

<span class="sd">        &gt;&gt;&gt; ds.groupby(&quot;letters&quot;)</span>
<span class="sd">        &lt;DatasetGroupBy, grouped over 1 grouper(s), 2 groups in total:</span>
<span class="sd">            &#39;letters&#39;: 2 groups with labels &#39;a&#39;, &#39;b&#39;&gt;</span>

<span class="sd">        Execute a reduction</span>

<span class="sd">        &gt;&gt;&gt; ds.groupby(&quot;letters&quot;).sum()</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 64B</span>
<span class="sd">        Dimensions:  (letters: 2, y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * letters  (letters) object 16B &#39;a&#39; &#39;b&#39;</span>
<span class="sd">        Dimensions without coordinates: y</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (letters, y) float64 48B 9.0 11.0 13.0 9.0 11.0 13.0</span>

<span class="sd">        Grouping by multiple variables</span>

<span class="sd">        &gt;&gt;&gt; ds.groupby([&quot;letters&quot;, &quot;x&quot;])</span>
<span class="sd">        &lt;DatasetGroupBy, grouped over 2 grouper(s), 8 groups in total:</span>
<span class="sd">            &#39;letters&#39;: 2 groups with labels &#39;a&#39;, &#39;b&#39;</span>
<span class="sd">            &#39;x&#39;: 4 groups with labels 10, 20, 30, 40&gt;</span>

<span class="sd">        Use Grouper objects to express more complicated GroupBy operations</span>

<span class="sd">        &gt;&gt;&gt; from xarray.groupers import BinGrouper, UniqueGrouper</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; ds.groupby(x=BinGrouper(bins=[5, 15, 25]), letters=UniqueGrouper()).sum()</span>
<span class="sd">        &lt;xarray.Dataset&gt; Size: 128B</span>
<span class="sd">        Dimensions:  (y: 3, x_bins: 2, letters: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x_bins   (x_bins) object 16B (5, 15] (15, 25]</span>
<span class="sd">          * letters  (letters) object 16B &#39;a&#39; &#39;b&#39;</span>
<span class="sd">        Dimensions without coordinates: y</span>
<span class="sd">        Data variables:</span>
<span class="sd">            foo      (y, x_bins, letters) float64 96B 0.0 nan nan 3.0 ... nan nan 5.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`groupby`</span>
<span class="sd">            Users guide explanation of how to group and bin data.</span>

<span class="sd">        :doc:`xarray-tutorial:intermediate/01-high-level-computation-patterns`</span>
<span class="sd">            Tutorial on :py:func:`~xarray.Dataset.Groupby` for windowed computation.</span>

<span class="sd">        :doc:`xarray-tutorial:fundamentals/03.2_groupby_with_xarray`</span>
<span class="sd">            Tutorial on :py:func:`~xarray.Dataset.Groupby` demonstrating reductions, transformation and comparison with :py:func:`~xarray.Dataset.resample`.</span>

<span class="sd">        Dataset.groupby_bins</span>
<span class="sd">        DataArray.groupby</span>
<span class="sd">        core.groupby.DatasetGroupBy</span>
<span class="sd">        pandas.DataFrame.groupby</span>
<span class="sd">        Dataset.coarsen</span>
<span class="sd">        Dataset.resample</span>
<span class="sd">        DataArray.resample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.groupby</span> <span class="kn">import</span> <span class="p">(</span>
            <span class="n">DatasetGroupBy</span><span class="p">,</span>
            <span class="n">_parse_group_and_groupers</span><span class="p">,</span>
            <span class="n">_validate_groupby_squeeze</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">_validate_groupby_squeeze</span><span class="p">(</span><span class="n">squeeze</span><span class="p">)</span>
        <span class="n">rgroupers</span> <span class="o">=</span> <span class="n">_parse_group_and_groupers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">groupers</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DatasetGroupBy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rgroupers</span><span class="p">,</span> <span class="n">restore_coord_dims</span><span class="o">=</span><span class="n">restore_coord_dims</span><span class="p">)</span>

    <span class="nd">@_deprecate_positional_args</span><span class="p">(</span><span class="s2">&quot;v2024.07.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">groupby_bins</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">DataArray</span> <span class="o">|</span> <span class="n">IndexVariable</span><span class="p">,</span>
        <span class="n">bins</span><span class="p">:</span> <span class="n">Bins</span><span class="p">,</span>
        <span class="n">right</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">precision</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">include_lowest</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">squeeze</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">restore_coord_dims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">duplicates</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="s2">&quot;drop&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatasetGroupBy</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a DatasetGroupBy object for performing grouped operations.</span>

<span class="sd">        Rather than using all unique values of `group`, the values are discretized</span>
<span class="sd">        first by applying `pandas.cut` [1]_ to `group`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        group : Hashable, DataArray or IndexVariable</span>
<span class="sd">            Array whose binned values should be used to group this array. If a</span>
<span class="sd">            string, must be the name of a variable contained in this dataset.</span>
<span class="sd">        bins : int or array-like</span>
<span class="sd">            If bins is an int, it defines the number of equal-width bins in the</span>
<span class="sd">            range of x. However, in this case, the range of x is extended by .1%</span>
<span class="sd">            on each side to include the min or max values of x. If bins is a</span>
<span class="sd">            sequence it defines the bin edges allowing for non-uniform bin</span>
<span class="sd">            width. No extension of the range of x is done in this case.</span>
<span class="sd">        right : bool, default: True</span>
<span class="sd">            Indicates whether the bins include the rightmost edge or not. If</span>
<span class="sd">            right == True (the default), then the bins [1,2,3,4] indicate</span>
<span class="sd">            (1,2], (2,3], (3,4].</span>
<span class="sd">        labels : array-like or bool, default: None</span>
<span class="sd">            Used as labels for the resulting bins. Must be of the same length as</span>
<span class="sd">            the resulting bins. If False, string bin labels are assigned by</span>
<span class="sd">            `pandas.cut`.</span>
<span class="sd">        precision : int, default: 3</span>
<span class="sd">            The precision at which to store and display the bins labels.</span>
<span class="sd">        include_lowest : bool, default: False</span>
<span class="sd">            Whether the first interval should be left-inclusive or not.</span>
<span class="sd">        squeeze : False</span>
<span class="sd">            This argument is deprecated.</span>
<span class="sd">        restore_coord_dims : bool, default: False</span>
<span class="sd">            If True, also restore the dimension order of multi-dimensional</span>
<span class="sd">            coordinates.</span>
<span class="sd">        duplicates : {&quot;raise&quot;, &quot;drop&quot;}, default: &quot;raise&quot;</span>
<span class="sd">            If bin edges are not unique, raise ValueError or drop non-uniques.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        grouped : DatasetGroupBy</span>
<span class="sd">            A `DatasetGroupBy` object patterned after `pandas.GroupBy` that can be</span>
<span class="sd">            iterated over in the form of `(unique_value, grouped_array)` pairs.</span>
<span class="sd">            The name of the group has the added suffix `_bins` in order to</span>
<span class="sd">            distinguish it from the original variable.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`groupby`</span>
<span class="sd">            Users guide explanation of how to group and bin data.</span>
<span class="sd">        Dataset.groupby</span>
<span class="sd">        DataArray.groupby_bins</span>
<span class="sd">        core.groupby.DatasetGroupBy</span>
<span class="sd">        pandas.DataFrame.groupby</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] http://pandas.pydata.org/pandas-docs/stable/generated/pandas.cut.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.groupby</span> <span class="kn">import</span> <span class="p">(</span>
            <span class="n">DatasetGroupBy</span><span class="p">,</span>
            <span class="n">ResolvedGrouper</span><span class="p">,</span>
            <span class="n">_validate_groupby_squeeze</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="kn">from</span> <span class="nn">xarray.groupers</span> <span class="kn">import</span> <span class="n">BinGrouper</span>

        <span class="n">_validate_groupby_squeeze</span><span class="p">(</span><span class="n">squeeze</span><span class="p">)</span>
        <span class="n">grouper</span> <span class="o">=</span> <span class="n">BinGrouper</span><span class="p">(</span>
            <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span>
            <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span>
            <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">include_lowest</span><span class="o">=</span><span class="n">include_lowest</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">rgrouper</span> <span class="o">=</span> <span class="n">ResolvedGrouper</span><span class="p">(</span><span class="n">grouper</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DatasetGroupBy</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="p">(</span><span class="n">rgrouper</span><span class="p">,),</span>
            <span class="n">restore_coord_dims</span><span class="o">=</span><span class="n">restore_coord_dims</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">weighted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">DataArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatasetWeighted</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weighted Dataset operations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weights : DataArray</span>
<span class="sd">            An array of weights associated with the values in this Dataset.</span>
<span class="sd">            Each value in the data contributes to the reduction operation</span>
<span class="sd">            according to its associated weight.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        ``weights`` must be a DataArray and cannot contain missing values.</span>
<span class="sd">        Missing values can be replaced by ``weights.fillna(0)``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        core.weighted.DatasetWeighted</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.weighted</span>

<span class="sd">        :ref:`comput.weighted`</span>
<span class="sd">            User guide on weighted array reduction using :py:func:`~xarray.Dataset.weighted`</span>

<span class="sd">        :doc:`xarray-tutorial:fundamentals/03.4_weighted`</span>
<span class="sd">            Tutorial on Weighted Reduction using :py:func:`~xarray.Dataset.weighted`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.weighted</span> <span class="kn">import</span> <span class="n">DatasetWeighted</span>

        <span class="k">return</span> <span class="n">DatasetWeighted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rolling</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">window_kwargs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatasetRolling</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rolling window object for Datasets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : dict, optional</span>
<span class="sd">            Mapping from the dimension name to create the rolling iterator</span>
<span class="sd">            along (e.g. `time`) to its moving window size.</span>
<span class="sd">        min_periods : int or None, default: None</span>
<span class="sd">            Minimum number of observations in window required to have a value</span>
<span class="sd">            (otherwise result is NA). The default, None, is equivalent to</span>
<span class="sd">            setting min_periods equal to the size of the window.</span>
<span class="sd">        center : bool or Mapping to int, default: False</span>
<span class="sd">            Set the labels at the center of the window.</span>
<span class="sd">        **window_kwargs : optional</span>
<span class="sd">            The keyword arguments form of ``dim``.</span>
<span class="sd">            One of dim or window_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        core.rolling.DatasetRolling</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.cumulative</span>
<span class="sd">        DataArray.rolling</span>
<span class="sd">        core.rolling.DatasetRolling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.rolling</span> <span class="kn">import</span> <span class="n">DatasetRolling</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">window_kwargs</span><span class="p">,</span> <span class="s2">&quot;rolling&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DatasetRolling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cumulative</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="n">min_periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatasetRolling</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Accumulating object for Datasets</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dims : iterable of hashable</span>
<span class="sd">            The name(s) of the dimensions to create the cumulative window along</span>
<span class="sd">        min_periods : int, default: 1</span>
<span class="sd">            Minimum number of observations in window required to have a value</span>
<span class="sd">            (otherwise result is NA). The default is 1 (note this is different</span>
<span class="sd">            from ``Rolling``, whose default is the size of the window).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        core.rolling.DatasetRolling</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.rolling</span>
<span class="sd">        DataArray.cumulative</span>
<span class="sd">        core.rolling.DatasetRolling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.rolling</span> <span class="kn">import</span> <span class="n">DatasetRolling</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> not found in data dimensions: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">dim</span><span class="p">]}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">missing_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">missing_dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Dimensions </span><span class="si">{</span><span class="n">missing_dims</span><span class="si">}</span><span class="s2"> not found in data dimensions: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dim</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">DatasetRolling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">coarsen</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">boundary</span><span class="p">:</span> <span class="n">CoarsenBoundaryOptions</span> <span class="o">=</span> <span class="s2">&quot;exact&quot;</span><span class="p">,</span>
        <span class="n">side</span><span class="p">:</span> <span class="n">SideOptions</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">SideOptions</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="n">coord_func</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Callable</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">window_kwargs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatasetCoarsen</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Coarsen object for Datasets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : mapping of hashable to int, optional</span>
<span class="sd">            Mapping from the dimension name to the window size.</span>
<span class="sd">        boundary : {&quot;exact&quot;, &quot;trim&quot;, &quot;pad&quot;}, default: &quot;exact&quot;</span>
<span class="sd">            If &#39;exact&#39;, a ValueError will be raised if dimension size is not a</span>
<span class="sd">            multiple of the window size. If &#39;trim&#39;, the excess entries are</span>
<span class="sd">            dropped. If &#39;pad&#39;, NA will be padded.</span>
<span class="sd">        side : {&quot;left&quot;, &quot;right&quot;} or mapping of str to {&quot;left&quot;, &quot;right&quot;}, default: &quot;left&quot;</span>
<span class="sd">        coord_func : str or mapping of hashable to str, default: &quot;mean&quot;</span>
<span class="sd">            function (name) that is applied to the coordinates,</span>
<span class="sd">            or a mapping from coordinate name to function (name).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        core.rolling.DatasetCoarsen</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        core.rolling.DatasetCoarsen</span>
<span class="sd">        DataArray.coarsen</span>

<span class="sd">        :ref:`reshape.coarsen`</span>
<span class="sd">            User guide describing :py:func:`~xarray.Dataset.coarsen`</span>

<span class="sd">        :ref:`compute.coarsen`</span>
<span class="sd">            User guide on block arrgragation :py:func:`~xarray.Dataset.coarsen`</span>

<span class="sd">        :doc:`xarray-tutorial:fundamentals/03.3_windowed`</span>
<span class="sd">            Tutorial on windowed computation using :py:func:`~xarray.Dataset.coarsen`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.rolling</span> <span class="kn">import</span> <span class="n">DatasetCoarsen</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">window_kwargs</span><span class="p">,</span> <span class="s2">&quot;coarsen&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DatasetCoarsen</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">dim</span><span class="p">,</span>
            <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span>
            <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">,</span>
            <span class="n">coord_func</span><span class="o">=</span><span class="n">coord_func</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@_deprecate_positional_args</span><span class="p">(</span><span class="s2">&quot;v2024.07.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexer</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">ResampleCompatible</span> <span class="o">|</span> <span class="n">Resampler</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">closed</span><span class="p">:</span> <span class="n">SideOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="n">SideOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span> <span class="o">|</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">origin</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">DatetimeLike</span> <span class="o">=</span> <span class="s2">&quot;start_day&quot;</span><span class="p">,</span>
        <span class="n">restore_coord_dims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexer_kwargs</span><span class="p">:</span> <span class="n">ResampleCompatible</span> <span class="o">|</span> <span class="n">Resampler</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatasetResample</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a Resample object for performing resampling operations.</span>

<span class="sd">        Handles both downsampling and upsampling. The resampled</span>
<span class="sd">        dimension must be a datetime-like coordinate. If any intervals</span>
<span class="sd">        contain no values from the original object, they will be given</span>
<span class="sd">        the value ``NaN``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexer : Mapping of Hashable to str, datetime.timedelta, pd.Timedelta, pd.DateOffset, or Resampler, optional</span>
<span class="sd">            Mapping from the dimension name to resample frequency [1]_. The</span>
<span class="sd">            dimension must be datetime-like.</span>
<span class="sd">        skipna : bool, optional</span>
<span class="sd">            Whether to skip missing values when aggregating in downsampling.</span>
<span class="sd">        closed : {&quot;left&quot;, &quot;right&quot;}, optional</span>
<span class="sd">            Side of each interval to treat as closed.</span>
<span class="sd">        label : {&quot;left&quot;, &quot;right&quot;}, optional</span>
<span class="sd">            Side of each interval to use for labeling.</span>
<span class="sd">        origin : {&#39;epoch&#39;, &#39;start&#39;, &#39;start_day&#39;, &#39;end&#39;, &#39;end_day&#39;}, pd.Timestamp, datetime.datetime, np.datetime64, or cftime.datetime, default &#39;start_day&#39;</span>
<span class="sd">            The datetime on which to adjust the grouping. The timezone of origin</span>
<span class="sd">            must match the timezone of the index.</span>

<span class="sd">            If a datetime is not used, these values are also supported:</span>
<span class="sd">            - &#39;epoch&#39;: `origin` is 1970-01-01</span>
<span class="sd">            - &#39;start&#39;: `origin` is the first value of the timeseries</span>
<span class="sd">            - &#39;start_day&#39;: `origin` is the first day at midnight of the timeseries</span>
<span class="sd">            - &#39;end&#39;: `origin` is the last value of the timeseries</span>
<span class="sd">            - &#39;end_day&#39;: `origin` is the ceiling midnight of the last day</span>
<span class="sd">        offset : pd.Timedelta, datetime.timedelta, or str, default is None</span>
<span class="sd">            An offset timedelta added to the origin.</span>
<span class="sd">        restore_coord_dims : bool, optional</span>
<span class="sd">            If True, also restore the dimension order of multi-dimensional</span>
<span class="sd">            coordinates.</span>
<span class="sd">        **indexer_kwargs : str, datetime.timedelta, pd.Timedelta, pd.DateOffset, or Resampler</span>
<span class="sd">            The keyword arguments form of ``indexer``.</span>
<span class="sd">            One of indexer or indexer_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        resampled : core.resample.DataArrayResample</span>
<span class="sd">            This object resampled.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.resample</span>
<span class="sd">        pandas.Series.resample</span>
<span class="sd">        pandas.DataFrame.resample</span>
<span class="sd">        Dataset.groupby</span>
<span class="sd">        DataArray.groupby</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray.core.resample</span> <span class="kn">import</span> <span class="n">DatasetResample</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resample</span><span class="p">(</span>
            <span class="n">resample_cls</span><span class="o">=</span><span class="n">DatasetResample</span><span class="p">,</span>
            <span class="n">indexer</span><span class="o">=</span><span class="n">indexer</span><span class="p">,</span>
            <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
            <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
            <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
            <span class="n">restore_coord_dims</span><span class="o">=</span><span class="n">restore_coord_dims</span><span class="p">,</span>
            <span class="o">**</span><span class="n">indexer_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">deep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all attributes from the Dataset and its variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep : bool, default True</span>
<span class="sd">            Removes attributes from all variables.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Remove attributes from the dataset</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="p">{})</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">deep</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># Remove attributes from each variable in the dataset</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="c1"># variables don&#39;t have a `._replace` method, so we copy and then remove</span>
            <span class="c1"># attrs. If we added a `._replace` method, we could use that instead.</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">new_idx_variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Not sure this is the most elegant way of doing this, but it works.</span>
        <span class="c1"># (Should we have a more general &quot;map over all variables, including</span>
        <span class="c1"># indexes&quot; approach?)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">idx_vars</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindexes</span><span class="o">.</span><span class="n">group_by_index</span><span class="p">():</span>
            <span class="c1"># copy each coordinate variable of an index and drop their attrs</span>
            <span class="n">temp_idx_variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">idx_vars</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">temp_idx_variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">v</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># re-wrap the index object in new coordinate variables</span>
            <span class="n">new_idx_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">create_variables</span><span class="p">(</span><span class="n">temp_idx_variables</span><span class="p">))</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">new_idx_variables</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item"><!-- This will display the version of the docs -->
<p class="larch-version">🌳 Larch v6.0.26, © Copyright 2024.</p></div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.4.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>